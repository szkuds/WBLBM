<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/wblbm/operators/force/electric_force.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/force/electric_force.py" />
              <option name="originalContent" value="import jax.numpy as jnp&#10;from wblbm.operators.force.force import Force&#10;&#10;&#10;class ElectricalForce(Force):&#10;    &quot;&quot;&quot;&#10;    Subclass for electrical force with electric potential distribution.&#10;    Solves for electric potential using a separate distribution function h_i.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, nx: int, ny: int, d: int, permittivity: float):&#10;        &quot;&quot;&quot;&#10;        Initialize electrical force.&#10;        &#10;        Args:&#10;            nx: Grid size in x direction&#10;            ny: Grid size in y direction&#10;            d: Dimensionality (must be 2)&#10;            permittivity: Electric permittivity of the medium&#10;        &quot;&quot;&quot;&#10;        if d != 2:&#10;            raise ValueError(&quot;Currently supports 2D (d=2) only&quot;)&#10;&#10;        force_array = jnp.zeros((nx, ny, 1, d))&#10;        super().__init__(force_array)&#10;        self.permittivity = permittivity&#10;        self.nx = nx&#10;        self.ny = ny&#10;        self.d = d&#10;        &#10;        # Initialize h_i distribution function for electric potential&#10;        # 9 velocities for D2Q9 lattice&#10;        self.h_i = jnp.zeros((nx, ny, 9))&#10;        self.U = jnp.zeros((nx, ny))  # Electric potential field&#10;&#10;    def compute_force(&#10;        self, rho: jnp.ndarray, charge_density: jnp.ndarray&#10;    ) -&gt; jnp.ndarray:&#10;        &quot;&quot;&quot;&#10;        Compute electrical force from electric field gradient.&#10;        E = -∇U, F = q * E&#10;        &#10;        Args:&#10;            rho: Density field of shape (nx, ny, 1)&#10;            charge_density: Charge density field of shape (nx, ny)&#10;            &#10;        Returns:&#10;            Force array of shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        # Compute electric field from potential gradient&#10;        E_x = -jnp.gradient(self.U, axis=0)&#10;        E_y = -jnp.gradient(self.U, axis=1)&#10;        &#10;        force_x = charge_density * E_x&#10;        force_y = charge_density * E_y&#10;        &#10;        force_array = jnp.zeros((rho.shape[0], rho.shape[1], 1, 2))&#10;        force_array = force_array.at[:, :, 0, 0].set(force_x)&#10;        force_array = force_array.at[:, :, 0, 1].set(force_y)&#10;        &#10;        self.force = force_array&#10;        return -self.force * rho&#10;&#10;    def update_potential(self, h_i: jnp.ndarray) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Update electric potential from h_i distribution.&#10;        U = Σ h_i&#10;        &#10;        Args:&#10;            h_i: Distribution function for electric potential, shape (nx, ny, 9)&#10;        &quot;&quot;&quot;&#10;        self.h_i = h_i&#10;        self.U = jnp.sum(h_i, axis=2)&#10;&#10;&#10;def collision_h_i(h_i: jnp.ndarray, U: jnp.ndarray, tau_e: float, &#10;                   w_i: jnp.ndarray, c_s_sq: float) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Collision step for electrical potential distribution.&#10;    Relaxes h_i towards equilibrium with relaxation time tau_e.&#10;    &#10;    Args:&#10;        h_i: Distribution function for electric potential, shape (nx, ny, 9)&#10;        U: Electric potential field, shape (nx, ny)&#10;        tau_e: Relaxation time for electrical collision&#10;        w_i: Lattice weights, shape (9,)&#10;        c_s_sq: Lattice sound speed squared&#10;        &#10;    Returns:&#10;        Updated distribution function after collision&#10;    &quot;&quot;&quot;&#10;    h_eq = equilibrium_h(U, w_i)&#10;    return h_i - (1.0 / tau_e) * (h_i - h_eq)&#10;&#10;&#10;def equilibrium_h(U: jnp.ndarray, w_i: jnp.ndarray) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Equilibrium distribution for electric potential.&#10;    h_i^eq = w_i * U&#10;    &#10;    Args:&#10;        U: Electric potential field, shape (nx, ny)&#10;        w_i: Lattice weights, shape (9,)&#10;        &#10;    Returns:&#10;        Equilibrium distribution, shape (nx, ny, 9)&#10;    &quot;&quot;&quot;&#10;    return w_i[:, jnp.newaxis, jnp.newaxis] * U[jnp.newaxis, jnp.newaxis, :]" />
              <option name="updatedContent" value="import jax.numpy as jnp&#10;from wblbm.operators.force.force import Force&#10;&#10;&#10;class ElectricalForce(Force):&#10;    &quot;&quot;&quot;&#10;    Subclass for electrical force with electric potential distribution.&#10;    Solves for electric potential using a separate distribution function h_i.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, nx: int, ny: int, d: int, permittivity: float):&#10;        &quot;&quot;&quot;&#10;        Initialize electrical force.&#10;        &#10;        Args:&#10;            nx: Grid size in x direction&#10;            ny: Grid size in y direction&#10;            d: Dimensionality (must be 2)&#10;            permittivity: Electric permittivity of the medium&#10;        &quot;&quot;&quot;&#10;        if d != 2:&#10;            raise ValueError(&quot;Currently supports 2D (d=2) only&quot;)&#10;&#10;        force_array = jnp.zeros((nx, ny, 1, d))&#10;        super().__init__(force_array)&#10;        self.permittivity = permittivity&#10;        self.nx = nx&#10;        self.ny = ny&#10;        self.d = d&#10;        &#10;        # Initialize h_i distribution function for electric potential&#10;        # 9 velocities for D2Q9 lattice&#10;        self.h_i = jnp.zeros((nx, ny, 9))&#10;        self.U = jnp.zeros((nx, ny))  # Electric potential field&#10;&#10;    def compute_force(&#10;        self, rho: jnp.ndarray, charge_density: jnp.ndarray&#10;    ) -&gt; jnp.ndarray:&#10;        &quot;&quot;&quot;&#10;        Compute electrical force from electric field gradient.&#10;        E = -∇U, F = q * E&#10;        &#10;        Args:&#10;            rho: Density field of shape (nx, ny, 1)&#10;            charge_density: Charge density field of shape (nx, ny)&#10;            &#10;        Returns:&#10;            Force array of shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        # Compute electric field from potential gradient&#10;        E_x = -jnp.gradient(self.U, axis=0)&#10;        E_y = -jnp.gradient(self.U, axis=1)&#10;        &#10;        force_x = charge_density * E_x&#10;        force_y = charge_density * E_y&#10;        &#10;        force_array = jnp.zeros((rho.shape[0], rho.shape[1], 1, 2))&#10;        force_array = force_array.at[:, :, 0, 0].set(force_x)&#10;        force_array = force_array.at[:, :, 0, 1].set(force_y)&#10;        &#10;        self.force = force_array&#10;        return -self.force * rho&#10;&#10;    def update_potential(self, h_i: jnp.ndarray) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Update electric potential from h_i distribution.&#10;        U = Σ h_i&#10;        &#10;        Args:&#10;            h_i: Distribution function for electric potential, shape (nx, ny, 9)&#10;        &quot;&quot;&quot;&#10;        self.h_i = h_i&#10;        self.U = jnp.sum(h_i, axis=2)&#10;&#10;&#10;def collision_h_i(h_i: jnp.ndarray, U: jnp.ndarray, tau_e: float, &#10;                   w_i: jnp.ndarray, c_s_sq: float) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Collision step for electrical potential distribution.&#10;    Relaxes h_i towards equilibrium with relaxation time tau_e.&#10;    &#10;    Args:&#10;        h_i: Distribution function for electric potential, shape (nx, ny, 9)&#10;        U: Electric potential field, shape (nx, ny)&#10;        tau_e: Relaxation time for electrical collision&#10;        w_i: Lattice weights, shape (9,)&#10;        c_s_sq: Lattice sound speed squared&#10;        &#10;    Returns:&#10;        Updated distribution function after collision&#10;    &quot;&quot;&quot;&#10;    h_eq = equilibrium_h(U, w_i)&#10;    return h_i - (1.0 / tau_e) * (h_i - h_eq)&#10;&#10;&#10;def equilibrium_h(U: jnp.ndarray, w_i: jnp.ndarray) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Equilibrium distribution for electric potential.&#10;    h_i^eq = w_i * U&#10;    &#10;    Args:&#10;        U: Electric potential field, shape (nx, ny)&#10;        w_i: Lattice weights, shape (9,)&#10;        &#10;    Returns:&#10;        Equilibrium distribution, shape (nx, ny, 9)&#10;    &quot;&quot;&quot;&#10;    return w_i[:, jnp.newaxis, jnp.newaxis] * U[jnp.newaxis, jnp.newaxis, :]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            -(2*self.a_eos)*rho_2d + self.R_eos*self.T_eos*(1 + jnp.log(rho_2d))&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        # Julia formula:&#10;        # -(2*a_eos)*ρw[i,j] + R_eos*T_eos*(1 + log(ρw[i,j])) + ((16*R_eos*T_eos*(b_eos*ρw[i,j] -12))/((-4 + b_eos*ρw[i,j])^3))&#10;        eos_2d = (&#10;            -(2 * self.a_eos) * rho_2d&#10;            + self.R_eos * self.T_eos * (1 + jnp.log(rho_2d))&#10;            + (16 * self.R_eos * self.T_eos * (self.b_eos * rho_2d - 12))&#10;              / jnp.power((-4 + self.b_eos * rho_2d), 3)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>