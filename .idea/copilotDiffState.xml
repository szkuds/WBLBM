<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/wblbm/operators/differential/gradient.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/differential/gradient.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.wetting.wetting_util import (&#10;    determine_padding_modes,&#10;    has_wetting_bc,&#10;    apply_wetting_to_all_edges,&#10;)&#10;&#10;&#10;class Gradient:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the gradient of a field using the LBM stencil,&#10;    supporting asymmetric per-side padding.&#10;&#10;    The implementation of the gradient operator is based on https://doi.org/10.1063/5.0072221&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, lattice: Lattice, bc_config: dict = None):&#10;        self.w = lattice.w&#10;        self.c = lattice.c&#10;        self.bc_config = bc_config&#10;        self.pad_mode = determine_padding_modes(bc_config)&#10;        # Only extract wetting parameters if wetting BC is present&#10;        self.wetting_params = None&#10;        if has_wetting_bc(bc_config):&#10;            self.wetting_params = bc_config.get('wetting_params')&#10;            if self.wetting_params is None:&#10;                raise ValueError(&quot;Wetting boundary condition specified but 'wetting_params' not found in bc_config&quot;)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(self, grid, pad_mode: list = None):&#10;        &quot;&quot;&quot;&#10;        Calculate the gradient using the provided stencil and per-side boundary modes.&#10;&#10;        Args:&#10;            grid (jnp.ndarray): Input field, shape (nx, ny, 1, 1)&#10;            pad_mode (list, optional): List of padding modes for each pad step&#10;&#10;        Returns:&#10;            jnp.ndarray: Gradient field, shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        if self.wetting_params is not None:  # Only use wetting if params are available&#10;            return self._gradient_wetting(grid, pad_mode)&#10;        else:&#10;            return self._gradient_standard(grid, pad_mode)&#10;&#10;    def _gradient_standard(self, grid, pad_mode):&#10;        &quot;&quot;&quot;Standard gradient calculation.&quot;&quot;&quot;&#10;        # Use provided pad_mode or fall back to self.pad_mode&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.pad_mode&#10;&#10;        # Extract 2D data from 4D input&#10;        if grid.ndim == 4:&#10;            grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        else:&#10;            grid_2d = grid&#10;&#10;        w = self.w&#10;        c = self.c&#10;&#10;        grad_ = jnp.zeros((2, grid_2d.shape[0], grid_2d.shape[1]))&#10;&#10;        # Apply asymmetric per-side padding (same convention/order as Laplacian)&#10;        grid_padded___ = jnp.pad(grid_2d, pad_width=((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded__ = jnp.pad(grid_padded___, pad_width=((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded_ = jnp.pad(grid_padded__, pad_width=((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded_, pad_width=((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Side nodes&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;&#10;        # Corner nodes&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        grad_ = grad_.at[0, :, :].set(&#10;            3&#10;            * (&#10;                    w[1] * c[0, 1] * grid_ipos1_j0&#10;                    + w[3] * c[0, 3] * grid_ineg1_j0&#10;                    + w[5] * c[0, 5] * grid_ipos1_jpos1&#10;                    + w[6] * c[0, 6] * grid_ineg1_jpos1&#10;                    + w[7] * c[0, 7] * grid_ineg1_jneg1&#10;                    + w[8] * c[0, 8] * grid_ipos1_jneg1&#10;            )&#10;        )&#10;&#10;        grad_ = grad_.at[1, :, :].set(&#10;            3&#10;            * (&#10;                    w[2] * c[1, 2] * grid_i0_jpos1&#10;                    + w[4] * c[1, 4] * grid_i0_jneg1&#10;                    + w[5] * c[1, 5] * grid_ipos1_jpos1&#10;                    + w[6] * c[1, 6] * grid_ineg1_jpos1&#10;                    + w[7] * c[1, 7] * grid_ineg1_jneg1&#10;                    + w[8] * c[1, 8] * grid_ipos1_jneg1&#10;            )&#10;        )&#10;&#10;        # Convert to 4D format: (nx, ny, 1, 2)&#10;        grad_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 2))&#10;        grad_4d = grad_4d.at[:, :, 0, 0].set(grad_[0, :, :])&#10;        grad_4d = grad_4d.at[:, :, 0, 1].set(grad_[1, :, :])&#10;&#10;        return grad_4d&#10;&#10;    def _gradient_wetting(self, grid, pad_mode):&#10;        rho_l = self.wetting_params['rho_l']&#10;        rho_v = self.wetting_params['rho_v']&#10;        phi_left = self.wetting_params['phi_left']&#10;        phi_right = self.wetting_params['phi_right']&#10;        d_rho_left = self.wetting_params['d_rho_left']&#10;        d_rho_right = self.wetting_params['d_rho_right']&#10;        width = self.wetting_params['width']&#10;        weight = self.w&#10;        c = self.c&#10;&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.pad_mode&#10;        if grid.ndim == 4:&#10;            grid2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid2d = grid&#10;&#10;        grid_padded = jnp.pad(grid2d, ((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded, ((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Apply wetting to any relevant edge&#10;        grid_padded = apply_wetting_to_all_edges(&#10;            self, grid_padded, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width&#10;        )&#10;&#10;        # STANDARD GRADIENT STENCIL&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        grad0 = (3 * (&#10;                weight[1] * c[0, 1] * grid_ipos1_j0 +&#10;                weight[3] * c[0, 3] * grid_ineg1_j0 +&#10;                weight[5] * c[0, 5] * grid_ipos1_jpos1 +&#10;                weight[6] * c[0, 6] * grid_ineg1_jpos1 +&#10;                weight[7] * c[0, 7] * grid_ineg1_jneg1 +&#10;                weight[8] * c[0, 8] * grid_ipos1_jneg1&#10;        ))&#10;&#10;        grad1 = (3 * (&#10;                weight[2] * c[1, 2] * grid_i0_jpos1 +&#10;                weight[4] * c[1, 4] * grid_i0_jneg1 +&#10;                weight[5] * c[1, 5] * grid_ipos1_jpos1 +&#10;                weight[6] * c[1, 6] * grid_ineg1_jpos1 +&#10;                weight[7] * c[1, 7] * grid_ineg1_jneg1 +&#10;                weight[8] * c[1, 8] * grid_ipos1_jneg1&#10;        ))&#10;&#10;        grad4d = jnp.zeros(grad0.shape + (1, 2))&#10;        grad4d = grad4d.at[..., 0, 0].set(grad0)&#10;        grad4d = grad4d.at[..., 0, 1].set(grad1)&#10;        return grad4d&#10;&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.wetting.wetting_util import (&#10;    determine_padding_modes,&#10;    has_wetting_bc,&#10;    apply_wetting_to_all_edges,&#10;)&#10;&#10;&#10;class Gradient:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the gradient of a field using the LBM stencil,&#10;    supporting asymmetric per-side padding.&#10;&#10;    The implementation of the gradient operator is based on https://doi.org/10.1063/5.0072221&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, lattice: Lattice, bc_config: dict = None):&#10;        self.w = lattice.w&#10;        self.c = lattice.c&#10;        self.bc_config = bc_config&#10;        self.pad_mode = determine_padding_modes(bc_config)&#10;        # Only extract wetting parameters if wetting BC is present&#10;        self.wetting_params = None&#10;        if has_wetting_bc(bc_config):&#10;            self.wetting_params = bc_config.get('wetting_params')&#10;            if self.wetting_params is None:&#10;                raise ValueError(&quot;Wetting boundary condition specified but 'wetting_params' not found in bc_config&quot;)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(self, grid, pad_mode: list = None):&#10;        &quot;&quot;&quot;&#10;        Calculate the gradient using the provided stencil and per-side boundary modes.&#10;&#10;        Args:&#10;            grid (jnp.ndarray): Input field, shape (nx, ny, 1, 1)&#10;            pad_mode (list, optional): List of padding modes for each pad step&#10;&#10;        Returns:&#10;            jnp.ndarray: Gradient field, shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        if self.wetting_params is not None:  # Only use wetting if params are available&#10;            return self._gradient_wetting(grid, pad_mode)&#10;        else:&#10;            return self._gradient_standard(grid, pad_mode)&#10;&#10;    def _gradient_standard(self, grid, pad_mode):&#10;        &quot;&quot;&quot;Standard gradient calculation.&quot;&quot;&quot;&#10;        # Use provided pad_mode or fall back to self.pad_mode&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.pad_mode&#10;&#10;        # Extract 2D data from 4D input&#10;        if grid.ndim == 4:&#10;            grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        else:&#10;            grid_2d = grid&#10;&#10;        w = self.w&#10;        c = self.c&#10;&#10;        grad_ = jnp.zeros((2, grid_2d.shape[0], grid_2d.shape[1]))&#10;&#10;        # Apply asymmetric per-side padding (same convention/order as Laplacian)&#10;        grid_padded___ = jnp.pad(grid_2d, pad_width=((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded__ = jnp.pad(grid_padded___, pad_width=((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded_ = jnp.pad(grid_padded__, pad_width=((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded_, pad_width=((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Side nodes&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;&#10;        # Corner nodes&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        grad_ = grad_.at[0, :, :].set(&#10;            3&#10;            * (&#10;                    w[1] * c[0, 1] * grid_ipos1_j0&#10;                    + w[3] * c[0, 3] * grid_ineg1_j0&#10;                    + w[5] * c[0, 5] * grid_ipos1_jpos1&#10;                    + w[6] * c[0, 6] * grid_ineg1_jpos1&#10;                    + w[7] * c[0, 7] * grid_ineg1_jneg1&#10;                    + w[8] * c[0, 8] * grid_ipos1_jneg1&#10;            )&#10;        )&#10;&#10;        grad_ = grad_.at[1, :, :].set(&#10;            3&#10;            * (&#10;                    w[2] * c[1, 2] * grid_i0_jpos1&#10;                    + w[4] * c[1, 4] * grid_i0_jneg1&#10;                    + w[5] * c[1, 5] * grid_ipos1_jpos1&#10;                    + w[6] * c[1, 6] * grid_ineg1_jpos1&#10;                    + w[7] * c[1, 7] * grid_ineg1_jneg1&#10;                    + w[8] * c[1, 8] * grid_ipos1_jneg1&#10;            )&#10;        )&#10;&#10;        # Convert to 4D format: (nx, ny, 1, 2)&#10;        grad_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 2))&#10;        grad_4d = grad_4d.at[:, :, 0, 0].set(grad_[0, :, :])&#10;        grad_4d = grad_4d.at[:, :, 0, 1].set(grad_[1, :, :])&#10;&#10;        return grad_4d&#10;&#10;    def _gradient_wetting(self, grid, pad_mode):&#10;        rho_l = self.wetting_params['rho_l']&#10;        rho_v = self.wetting_params['rho_v']&#10;        phi_left = self.wetting_params['phi_left']&#10;        phi_right = self.wetting_params['phi_right']&#10;        d_rho_left = self.wetting_params['d_rho_left']&#10;        d_rho_right = self.wetting_params['d_rho_right']&#10;        width = self.wetting_params['width']&#10;        weight = self.w&#10;        c = self.c&#10;&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.pad_mode&#10;        if grid.ndim == 4:&#10;            grid2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid2d = grid&#10;&#10;        grid_padded = jnp.pad(grid2d, ((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded, ((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Apply wetting to any relevant edge&#10;        grid_padded = apply_wetting_to_all_edges(&#10;            self, grid_padded, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width&#10;        )&#10;&#10;        # STANDARD GRADIENT STENCIL&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        grad0 = (3 * (&#10;                weight[1] * c[0, 1] * grid_ipos1_j0 +&#10;                weight[3] * c[0, 3] * grid_ineg1_j0 +&#10;                weight[5] * c[0, 5] * grid_ipos1_jpos1 +&#10;                weight[6] * c[0, 6] * grid_ineg1_jpos1 +&#10;                weight[7] * c[0, 7] * grid_ineg1_jneg1 +&#10;                weight[8] * c[0, 8] * grid_ipos1_jneg1&#10;        ))&#10;&#10;        grad1 = (3 * (&#10;                weight[2] * c[1, 2] * grid_i0_jpos1 +&#10;                weight[4] * c[1, 4] * grid_i0_jneg1 +&#10;                weight[5] * c[1, 5] * grid_ipos1_jpos1 +&#10;                weight[6] * c[1, 6] * grid_ineg1_jpos1 +&#10;                weight[7] * c[1, 7] * grid_ineg1_jneg1 +&#10;                weight[8] * c[1, 8] * grid_ipos1_jneg1&#10;        ))&#10;&#10;        grad4d = jnp.zeros(grad0.shape + (1, 2))&#10;        grad4d = grad4d.at[..., 0, 0].set(grad0)&#10;        grad4d = grad4d.at[..., 0, 1].set(grad1)&#10;        return grad4d&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/differential/laplacian.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/differential/laplacian.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.wetting.wetting_util import (&#10;    determine_padding_modes,&#10;    has_wetting_bc,&#10;    apply_wetting_to_all_edges,&#10;)&#10;&#10;&#10;class Laplacian:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the Laplacian of a 2D grid using the LBM stencil.&#10;&#10;    The implementation of the laplacian is based on https://doi.org/10.1063/5.0072221&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, lattice: Lattice, bc_config: dict = None):&#10;        self.w = lattice.w&#10;        self.bc_config = bc_config&#10;        self.padmode = determine_padding_modes(bc_config)&#10;        # Only extract wetting parameters if wetting BC is present&#10;        self.wetting_params = None&#10;        if has_wetting_bc(bc_config):&#10;            self.wetting_params = bc_config.get('wetting_params')&#10;            if self.wetting_params is None:&#10;                raise ValueError(&quot;Wetting boundary condition specified but 'wetting_params' not found in bcconfig&quot;)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(self, grid, padmode: list = None):&#10;        &quot;&quot;&quot;&#10;        Calculate the Laplacian of a 2D grid.&#10;&#10;        Args:&#10;            grid (jnp.ndarray): Input grid, shape (nx, ny, 1, 1)&#10;            padmode (list, optional): List of padding modes for each pad step&#10;&#10;        Returns:&#10;            jnp.ndarray: Laplacian of the input grid, shape (nx, ny, 1, 1)&#10;        &quot;&quot;&quot;&#10;        if self.wetting_params is not None:  # Only use wetting if params are available&#10;            return self._laplacian_wetting(grid, padmode)&#10;        else:&#10;            return self._laplacian_standard(grid, padmode)&#10;&#10;    def _laplacian_standard(self, grid, pad_mode):&#10;        &quot;&quot;&quot;Standard laplacian calculation.&quot;&quot;&quot;&#10;        # Use provided pad_mode or fall back to self.pad_mode&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.padmode&#10;&#10;        # Extract 2D data from 4D input&#10;        if grid.ndim == 4:&#10;            grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        else:&#10;            grid_2d = grid&#10;&#10;        w = self.w&#10;&#10;        laplacian_2d = jnp.zeros_like(grid_2d)&#10;        grid_padded___ = jnp.pad(grid_2d, pad_width=((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded__ = jnp.pad(grid_padded___, pad_width=((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded_ = jnp.pad(grid_padded__, pad_width=((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded_, pad_width=((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Side nodes&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;&#10;        # Corner nodes&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        # Central node&#10;        grid_i0_j0 = grid_padded[1:-1, 1:-1]&#10;&#10;        laplacian_2d = laplacian_2d.at[:, :].set(&#10;            6&#10;            * (&#10;                    w[1] * (grid_ipos1_j0 - grid_i0_j0)&#10;                    + w[2] * (grid_i0_jpos1 - grid_i0_j0)&#10;                    + w[3] * (grid_ineg1_j0 - grid_i0_j0)&#10;                    + w[4] * (grid_i0_jneg1 - grid_i0_j0)&#10;                    + w[5] * (grid_ipos1_jpos1 - grid_i0_j0)&#10;                    + w[6] * (grid_ineg1_jpos1 - grid_i0_j0)&#10;                    + w[7] * (grid_ineg1_jneg1 - grid_i0_j0)&#10;                    + w[8] * (grid_ipos1_jneg1 - grid_i0_j0)&#10;            )&#10;        )&#10;&#10;        # Convert to 4D format: (nx, ny, 1, 1)&#10;        laplacian_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 1))&#10;        laplacian_4d = laplacian_4d.at[:, :, 0, 0].set(laplacian_2d)&#10;&#10;        return laplacian_4d&#10;&#10;    def _laplacian_wetting(self, grid, padmode):&#10;        &quot;&quot;&quot;Custom wetting laplacian implementation.&quot;&quot;&quot;&#10;        RHO_L = self.wetting_params['rho_l']&#10;        RHO_V = self.wetting_params['rho_v']&#10;        phi_left = self.wetting_params['phi_left']&#10;        phi_right = self.wetting_params['phi_right']&#10;        d_rho_left = self.wetting_params['d_rho_left']&#10;        d_rho_right = self.wetting_params['d_rho_right']&#10;        W = self.wetting_params['W']&#10;        w = self.w&#10;&#10;        effective_padmode = padmode if padmode is not None else self.padmode&#10;        if grid.ndim == 4:&#10;            grid2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid2d = grid&#10;&#10;        # Pad as usual&#10;        grid_padded = jnp.pad(grid2d, ((0, 0), (0, 1)), mode=effective_padmode[0])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 0), (1, 0)), mode=effective_padmode[1])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 1), (0, 0)), mode=effective_padmode[2])&#10;        grid_padded = jnp.pad(grid_padded, ((1, 0), (0, 0)), mode=effective_padmode[3])&#10;&#10;        # Apply wetting to any relevant edge&#10;        grid_padded = apply_wetting_to_all_edges(self, grid_padded,&#10;                                                 RHO_L, RHO_V, phi_left, phi_right, d_rho_left, d_rho_right, W)&#10;&#10;        # STANDARD LAPLACIAN STENCIL&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;        grid_i0_j0 = grid_padded[1:-1, 1:-1]&#10;&#10;        laplacian2d = 6 * (&#10;                w[1] * (grid_ipos1_j0 - grid_i0_j0) +&#10;                w[2] * (grid_i0_jpos1 - grid_i0_j0) +&#10;                w[3] * (grid_ineg1_j0 - grid_i0_j0) +&#10;                w[4] * (grid_i0_jneg1 - grid_i0_j0) +&#10;                w[5] * (grid_ipos1_jpos1 - grid_i0_j0) +&#10;                w[6] * (grid_ineg1_jpos1 - grid_i0_j0) +&#10;                w[7] * (grid_ineg1_jneg1 - grid_i0_j0) +&#10;                w[8] * (grid_ipos1_jneg1 - grid_i0_j0)&#10;        )&#10;&#10;        laplacian4d = jnp.zeros(laplacian2d.shape + (1, 1))&#10;        laplacian4d = laplacian4d.at[..., 0, 0].set(laplacian2d)&#10;        return laplacian4d" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.wetting.wetting_util import (&#10;    determine_padding_modes,&#10;    has_wetting_bc,&#10;    apply_wetting_to_all_edges,&#10;)&#10;&#10;&#10;class Laplacian:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the Laplacian of a 2D grid using the LBM stencil.&#10;&#10;    The implementation of the laplacian is based on https://doi.org/10.1063/5.0072221&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, lattice: Lattice, bc_config: dict = None):&#10;        self.w = lattice.w&#10;        self.bc_config = bc_config&#10;        self.padmode = determine_padding_modes(bc_config)&#10;        # Only extract wetting parameters if wetting BC is present&#10;        self.wetting_params = None&#10;        if has_wetting_bc(bc_config):&#10;            self.wetting_params = bc_config.get('wetting_params')&#10;            if self.wetting_params is None:&#10;                raise ValueError(&quot;Wetting boundary condition specified but 'wetting_params' not found in bcconfig&quot;)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(self, grid, padmode: list = None):&#10;        &quot;&quot;&quot;&#10;        Calculate the Laplacian of a 2D grid.&#10;&#10;        Args:&#10;            grid (jnp.ndarray): Input grid, shape (nx, ny, 1, 1)&#10;            padmode (list, optional): List of padding modes for each pad step&#10;&#10;        Returns:&#10;            jnp.ndarray: Laplacian of the input grid, shape (nx, ny, 1, 1)&#10;        &quot;&quot;&quot;&#10;        if self.wetting_params is not None:  # Only use wetting if params are available&#10;            return self._laplacian_wetting(grid, padmode)&#10;        else:&#10;            return self._laplacian_standard(grid, padmode)&#10;&#10;    def _laplacian_standard(self, grid, padmode):&#10;        &quot;&quot;&quot;Standard laplacian calculation.&quot;&quot;&quot;&#10;        effective_padmode = padmode if padmode is not None else self.padmode&#10;&#10;        if grid.ndim == 4:&#10;            grid_2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid_2d = grid&#10;&#10;        w = self.w&#10;&#10;        laplacian_2d = jnp.zeros_like(grid_2d)&#10;        grid_padded___ = jnp.pad(grid_2d, pad_width=((0, 0), (0, 1)), mode=effective_padmode[0])&#10;        grid_padded__ = jnp.pad(grid_padded___, pad_width=((0, 0), (1, 0)), mode=effective_padmode[1])&#10;        grid_padded_ = jnp.pad(grid_padded__, pad_width=((0, 1), (0, 0)), mode=effective_padmode[2])&#10;        grid_padded = jnp.pad(grid_padded_, pad_width=((1, 0), (0, 0)), mode=effective_padmode[3])&#10;&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;        grid_i0_j0 = grid_padded[1:-1, 1:-1]&#10;&#10;        laplacian_2d = laplacian_2d.at[:, :].set(&#10;            6&#10;            * (&#10;                w[1] * (grid_ipos1_j0 - grid_i0_j0)&#10;                + w[2] * (grid_i0_jpos1 - grid_i0_j0)&#10;                + w[3] * (grid_ineg1_j0 - grid_i0_j0)&#10;                + w[4] * (grid_i0_jneg1 - grid_i0_j0)&#10;                + w[5] * (grid_ipos1_jpos1 - grid_i0_j0)&#10;                + w[6] * (grid_ineg1_jpos1 - grid_i0_j0)&#10;                + w[7] * (grid_ineg1_jneg1 - grid_i0_j0)&#10;                + w[8] * (grid_ipos1_jneg1 - grid_i0_j0)&#10;            )&#10;        )&#10;&#10;        laplacian_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 1))&#10;        laplacian_4d = laplacian_4d.at[:, :, 0, 0].set(laplacian_2d)&#10;&#10;        return laplacian_4d&#10;&#10;    def _laplacian_wetting(self, grid, padmode):&#10;        &quot;&quot;&quot;Custom wetting laplacian implementation.&quot;&quot;&quot;&#10;        RHO_L = self.wetting_params['rho_l']&#10;        RHO_V = self.wetting_params['rho_v']&#10;        phi_left = self.wetting_params['phi_left']&#10;        phi_right = self.wetting_params['phi_right']&#10;        d_rho_left = self.wetting_params['d_rho_left']&#10;        d_rho_right = self.wetting_params['d_rho_right']&#10;        W = self.wetting_params['W']&#10;        w = self.w&#10;&#10;        effective_padmode = padmode if padmode is not None else self.padmode&#10;        if grid.ndim == 4:&#10;            grid2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid2d = grid&#10;&#10;        grid_padded = jnp.pad(grid2d, ((0, 0), (0, 1)), mode=effective_padmode[0])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 0), (1, 0)), mode=effective_padmode[1])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 1), (0, 0)), mode=effective_padmode[2])&#10;        grid_padded = jnp.pad(grid_padded, ((1, 0), (0, 0)), mode=effective_padmode[3])&#10;&#10;        grid_padded = apply_wetting_to_all_edges(self, grid_padded,&#10;            RHO_L, RHO_V, phi_left, phi_right, d_rho_left, d_rho_right, W)&#10;&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;        grid_i0_j0 = grid_padded[1:-1, 1:-1]&#10;&#10;        laplacian2d = 6 * (&#10;            w[1] * (grid_ipos1_j0 - grid_i0_j0) +&#10;            w[2] * (grid_i0_jpos1 - grid_i0_j0) +&#10;            w[3] * (grid_ineg1_j0 - grid_i0_j0) +&#10;            w[4] * (grid_i0_jneg1 - grid_i0_j0) +&#10;            w[5] * (grid_ipos1_jpos1 - grid_i0_j0) +&#10;            w[6] * (grid_ineg1_jpos1 - grid_i0_j0) +&#10;            w[7] * (grid_ineg1_jneg1 - grid_i0_j0) +&#10;            w[8] * (grid_ipos1_jneg1 - grid_i0_j0)&#10;        )&#10;&#10;        laplacian4d = jnp.zeros(laplacian2d.shape + (1, 1))&#10;        laplacian4d = laplacian4d.at[..., 0, 0].set(laplacian2d)&#10;        return laplacian4d" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            -(2*self.a_eos)*rho_2d + self.R_eos*self.T_eos*(1 + jnp.log(rho_2d))&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        # Julia formula:&#10;        # -(2*a_eos)*ρw[i,j] + R_eos*T_eos*(1 + log(ρw[i,j])) + ((16*R_eos*T_eos*(b_eos*ρw[i,j] -12))/((-4 + b_eos*ρw[i,j])^3))&#10;        eos_2d = (&#10;            -(2 * self.a_eos) * rho_2d&#10;            + self.R_eos * self.T_eos * (1 + jnp.log(rho_2d))&#10;            + (16 * self.R_eos * self.T_eos * (self.b_eos * rho_2d - 12))&#10;              / jnp.power((-4 + self.b_eos * rho_2d), 3)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/wetting/wetting_util.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/wetting/wetting_util.py" />
              <option name="originalContent" value="import jax.numpy as jnp&#10;&#10;def determine_padding_modes(bc_config):&#10;    if not bc_config:&#10;        return [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;    padmode = [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;    for edge, bc_type in bc_config.items():&#10;        if bc_type in [&quot;symmetry&quot;, &quot;bounce-back&quot;, &quot;wetting&quot;]:&#10;            if edge == &quot;bottom&quot;:&#10;                padmode[0] = &quot;edge&quot;&#10;            elif edge == &quot;right&quot;:&#10;                padmode[1] = &quot;edge&quot;&#10;            elif edge == &quot;top&quot;:&#10;                padmode[2] = &quot;edge&quot;&#10;            elif edge == &quot;left&quot;:&#10;                padmode[3] = &quot;edge&quot;&#10;    return padmode&#10;&#10;def has_wetting_bc(bc_config):&#10;    if not bc_config:&#10;        return False&#10;    return any(bc == &quot;wetting&quot; for key, bc in bc_config.items()&#10;               if key != 'wetting_params' and isinstance(bc, str))&#10;&#10;def apply_wetting_to_all_edges(obj, grid_padded, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width):&#10;    for edge in ['bottom', 'top', 'left', 'right']:&#10;        if obj.bc_config.get(edge) == 'wetting':&#10;            if edge == 'bottom':  # y=0 border&#10;                grid_padded = wetting_1d(grid_padded, axis=1, idx=0,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'top':  # y=-1 border&#10;                grid_padded = wetting_1d(grid_padded, axis=1, idx=-1,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'left':  # x=0 border&#10;                grid_padded = wetting_1d(grid_padded, axis=0, idx=0,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'right':  # x=-1 border&#10;                grid_padded = wetting_1d(grid_padded, axis=0, idx=-1,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;    return grid_padded&#10;&#10;def wetting_1d(arr, axis, idx, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width):&#10;    # axis == 1 for the y-edges&#10;    if axis == 1:&#10;        arr = arr.at[1:-1, idx].set(&#10;            (1 / 3 * arr[1:-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[0:-2, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[2:, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12))&#10;        # Corners&#10;        arr = arr.at[0, idx].set(&#10;            (1 / 3 * arr[0, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[1, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        arr = arr.at[-1, idx].set(&#10;            (1 / 3 * arr[-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[0, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[-2, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        edge_slice = arr[1:-1, idx]&#10;&#10;        mask1 = arr[1:-1, idx] &lt; (0.95 * rho_l + 0.05 * rho_v)&#10;        mask2 = arr[1:-1, idx] &gt; (0.95 * rho_v + 0.05 * rho_l)&#10;    # axis == 0 for the x-edges&#10;    else:&#10;        arr = arr.at[idx, -1:1].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, 1:-1] +&#10;             1 / 12 * arr[idx + 1 if idx == 0 else idx - 1, 0:-2] +&#10;             1 / 12 * arr[idx + 1 if idx == 0 else idx - 1, 2:])&#10;            / (1 / 3 + 1 / 12 + 1 / 12))&#10;        #Corners&#10;        arr = arr.at[idx, 0].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, 0] +&#10;             1 / 12 * arr[idx, -1] +&#10;             1 / 12 * arr[idx, 1]) / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        arr = arr.at[idx, -1].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, -1] +&#10;             1 / 12 * arr[idx, 0] +&#10;             1 / 12 * arr[idx, -2]) / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        edge_slice = arr[idx, 1:-1]&#10;&#10;        mask1 = arr[idx, -1:1] &lt; (0.95 * rho_l + 0.05 * rho_v)&#10;        mask2 = arr[idx, -1:1] &gt; (0.95 * rho_v + 0.05 * rho_l)&#10;&#10;    # Wetting mask logic&#10;    mask_final = mask1 * mask2&#10;&#10;    mask1_int = jnp.array(mask1, dtype=int)&#10;    diff_mask1 = jnp.diff(mask1_int)&#10;&#10;    # Determining the transition index, the [0] is used to extract only the first value&#10;    transition_index_left_mask1 = jnp.where(diff_mask1 == -1, size=1, fill_value=0)[0] + 2 * width&#10;    transition_index_right_mask1 = (jnp.where(diff_mask1 == 1, size=1, fill_value=0)[0]) - (2 * width + 1)&#10;&#10;    # Here the mask_final is split into a left and a right mask to enable the CA of the left and right side to be&#10;    # determined separately, the reason left uses the right mask is that it works as a cover.&#10;    indices = jnp.arange(mask_final.shape[0])&#10;    mask_cover_left = jnp.where(indices &gt;= transition_index_right_mask1[0], False, mask_final)&#10;    mask_cover_right = jnp.where(indices &lt;= transition_index_left_mask1[0], False, mask_final)&#10;&#10;    new_values_left = jnp.minimum(&#10;        jnp.maximum(&#10;            ((phi_left * edge_slice) - d_rho_left),&#10;            (0.95 * rho_v + 0.05 * rho_l)&#10;        ),&#10;        (0.95 * rho_l + 0.05 * rho_v)&#10;    )&#10;&#10;    new_values_right = jnp.minimum(&#10;        jnp.maximum(&#10;            ((phi_right * edge_slice) - d_rho_right),&#10;            (0.95 * rho_v + 0.05 * rho_l)&#10;        ),&#10;        (0.95 * rho_l + 0.05 * rho_v)&#10;    )&#10;    updated_slice = jnp.where(mask_cover_left, new_values_left, edge_slice)&#10;    updated_slice = jnp.where(mask_cover_right, new_values_right, updated_slice)&#10;&#10;    if axis == 1:&#10;        arr = arr.at[1:-1, idx].set(updated_slice)&#10;    else:&#10;        arr = arr.at[idx, 1:-1].set(updated_slice)&#10;    return arr&#10;" />
              <option name="updatedContent" value="import jax.numpy as jnp&#10;&#10;def determine_padding_modes(bc_config):&#10;    if not bc_config:&#10;        return [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;    padmode = [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;    for edge, bc_type in bc_config.items():&#10;        if bc_type in [&quot;symmetry&quot;, &quot;bounce-back&quot;, &quot;wetting&quot;]:&#10;            if edge == &quot;bottom&quot;:&#10;                padmode[0] = &quot;edge&quot;&#10;            elif edge == &quot;right&quot;:&#10;                padmode[1] = &quot;edge&quot;&#10;            elif edge == &quot;top&quot;:&#10;                padmode[2] = &quot;edge&quot;&#10;            elif edge == &quot;left&quot;:&#10;                padmode[3] = &quot;edge&quot;&#10;    return padmode&#10;&#10;def has_wetting_bc(bc_config):&#10;    if not bc_config:&#10;        return False&#10;    return any(bc == &quot;wetting&quot; for key, bc in bc_config.items()&#10;               if key != 'wetting_params' and isinstance(bc, str))&#10;&#10;def apply_wetting_to_all_edges(obj, grid_padded, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width):&#10;    for edge in ['bottom', 'top', 'left', 'right']:&#10;        if obj.bc_config.get(edge) == 'wetting':&#10;            if edge == 'bottom':  # y=0 border&#10;                grid_padded = wetting_1d(grid_padded, axis=1, idx=0,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'top':  # y=-1 border&#10;                grid_padded = wetting_1d(grid_padded, axis=1, idx=-1,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'left':  # x=0 border&#10;                grid_padded = wetting_1d(grid_padded, axis=0, idx=0,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'right':  # x=-1 border&#10;                grid_padded = wetting_1d(grid_padded, axis=0, idx=-1,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;    return grid_padded&#10;&#10;def wetting_1d(arr, axis, idx, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width):&#10;    # axis == 1 for the y-edges&#10;    if axis == 1:&#10;        arr = arr.at[1:-1, idx].set(&#10;            (1 / 3 * arr[1:-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[0:-2, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[2:, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12))&#10;        # Corners&#10;        arr = arr.at[0, idx].set(&#10;            (1 / 3 * arr[0, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[1, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        arr = arr.at[-1, idx].set(&#10;            (1 / 3 * arr[-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[0, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[-2, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        edge_slice = arr[1:-1, idx]&#10;&#10;        mask1 = arr[1:-1, idx] &lt; (0.95 * rho_l + 0.05 * rho_v)&#10;        mask2 = arr[1:-1, idx] &gt; (0.95 * rho_v + 0.05 * rho_l)&#10;    # axis == 0 for the x-edges&#10;    else:&#10;        arr = arr.at[idx, -1:1].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, 1:-1] +&#10;             1 / 12 * arr[idx + 1 if idx == 0 else idx - 1, 0:-2] +&#10;             1 / 12 * arr[idx + 1 if idx == 0 else idx - 1, 2:])&#10;            / (1 / 3 + 1 / 12 + 1 / 12))&#10;        #Corners&#10;        arr = arr.at[idx, 0].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, 0] +&#10;             1 / 12 * arr[idx, -1] +&#10;             1 / 12 * arr[idx, 1]) / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        arr = arr.at[idx, -1].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, -1] +&#10;             1 / 12 * arr[idx, 0] +&#10;             1 / 12 * arr[idx, -2]) / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        edge_slice = arr[idx, 1:-1]&#10;&#10;        mask1 = arr[idx, -1:1] &lt; (0.95 * rho_l + 0.05 * rho_v)&#10;        mask2 = arr[idx, -1:1] &gt; (0.95 * rho_v + 0.05 * rho_l)&#10;&#10;    # Wetting mask logic&#10;    mask_final = mask1 * mask2&#10;&#10;    mask1_int = jnp.array(mask1, dtype=int)&#10;    diff_mask1 = jnp.diff(mask1_int)&#10;&#10;    # Determining the transition index, the [0] is used to extract only the first value&#10;    transition_index_left_mask1 = jnp.where(diff_mask1 == -1, size=1, fill_value=0)[0] + 2 * width&#10;    transition_index_right_mask1 = (jnp.where(diff_mask1 == 1, size=1, fill_value=0)[0]) - (2 * width + 1)&#10;&#10;    # Here the mask_final is split into a left and a right mask to enable the CA of the left and right side to be&#10;    # determined separately, the reason left uses the right mask is that it works as a cover.&#10;    indices = jnp.arange(mask_final.shape[0])&#10;    mask_cover_left = jnp.where(indices &gt;= transition_index_right_mask1[0], False, mask_final)&#10;    mask_cover_right = jnp.where(indices &lt;= transition_index_left_mask1[0], False, mask_final)&#10;&#10;    new_values_left = jnp.minimum(&#10;        jnp.maximum(&#10;            ((phi_left * edge_slice) - d_rho_left),&#10;            (0.95 * rho_v + 0.05 * rho_l)&#10;        ),&#10;        (0.95 * rho_l + 0.05 * rho_v)&#10;    )&#10;&#10;    new_values_right = jnp.minimum(&#10;        jnp.maximum(&#10;            ((phi_right * edge_slice) - d_rho_right),&#10;            (0.95 * rho_v + 0.05 * rho_l)&#10;        ),&#10;        (0.95 * rho_l + 0.05 * rho_v)&#10;    )&#10;    updated_slice = jnp.where(mask_cover_left, new_values_left, edge_slice)&#10;    updated_slice = jnp.where(mask_cover_right, new_values_right, updated_slice)&#10;&#10;    if axis == 1:&#10;        arr = arr.at[1:-1, idx].set(updated_slice)&#10;    else:&#10;        arr = arr.at[idx, 1:-1].set(updated_slice)&#10;    return arr&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/run/run.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/run/run.py" />
              <option name="originalContent" value="import numpy as np&#10;import jax.numpy as jnp&#10;import inspect  # Added for simulation name detection&#10;&#10;&#10;class SimulationFactory:&#10;    @staticmethod&#10;    def create_simulation(simulation_type, **kwargs):&#10;        if simulation_type == &quot;singlephase&quot;:&#10;            from wblbm.simulations.singlephase import SinglePhaseSimulation&#10;            return SinglePhaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;multiphase&quot;:&#10;            from wblbm.simulations.multiphase import MultiphaseSimulation&#10;            return MultiphaseSimulation(**kwargs)&#10;        else:&#10;            raise ValueError(f&quot;Unknown simulation type: {simulation_type}&quot;)&#10;&#10;&#10;class Run:&#10;    &quot;&quot;&quot;&#10;    Main class to configure and run lattice Boltzmann simulations using the simulation factory.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        simulation_type=&quot;singlephase&quot;,&#10;        *,&#10;        save_interval=100,&#10;        results_dir=&quot;results&quot;,&#10;        init_type=&quot;standard&quot;,&#10;        init_dir=None,&#10;        skip_interval=0,&#10;        collision=None,  # Accept collision as a kwarg&#10;        simulation_name=None,  # Added simulation_name parameter&#10;        **kwargs,&#10;    ):&#10;        # Accept either a string or a dict for collision&#10;        collision_cfg = None&#10;        if collision is not None:&#10;            if isinstance(collision, str):&#10;                collision_cfg = {&quot;collision_scheme&quot;: collision}&#10;            elif isinstance(collision, dict):&#10;                collision_cfg = collision.copy()&#10;            else:&#10;                raise ValueError(&#10;                    &quot;collision must be either a string (for BGK) or dict (for MRT config).&quot;&#10;                )&#10;            kwargs.update(collision_cfg)&#10;        self.simulation = SimulationFactory.create_simulation(simulation_type, **kwargs)&#10;        self.save_interval = save_interval&#10;        self.skip_interval = skip_interval&#10;        self.results_dir = results_dir&#10;        self.init_type = init_type&#10;        self.init_dir = init_dir&#10;        # Auto-detect simulation name from calling function if not provided&#10;        if simulation_name is None:&#10;            frame = inspect.currentframe()&#10;            try:&#10;                caller_frame = frame.f_back&#10;                while caller_frame:&#10;                    func_name = caller_frame.f_code.co_name&#10;                    if func_name != &quot;&lt;module&gt;&quot; and not func_name.startswith(&quot;_&quot;):&#10;                        simulation_name = func_name&#10;                        break&#10;                    caller_frame = caller_frame.f_back&#10;            finally:&#10;                del frame&#10;        self.config = self._build_config(&#10;            simulation_type=simulation_type,&#10;            save_interval=save_interval,&#10;            results_dir=results_dir,&#10;            skip_interval=skip_interval,&#10;            init_type=init_type,&#10;            init_dir=init_dir,&#10;            **kwargs,&#10;        )&#10;        from wblbm.utils.io import SimulationIO&#10;&#10;        self.io_handler = SimulationIO(&#10;            base_dir=results_dir, config=self.config, simulation_name=simulation_name&#10;        )&#10;&#10;    def _build_config(self, **kwargs):&#10;        # Simple config builder for demonstration; extend as needed&#10;        return dict(**kwargs)&#10;&#10;    # TODO: need to double check that data is saved properly&#10;    def _save_data(self, it, fprev):&#10;        # Save data using the simulation's macroscopic operator&#10;        force_ext = None&#10;        if hasattr(self.simulation, &quot;macroscopic&quot;):&#10;            macroscopic = self.simulation.macroscopic&#10;            try:&#10;                if self.config.get(&quot;force_enabled&quot;) and self.config.get(&quot;force_obj&quot;):&#10;                    rho = jnp.sum(fprev, axis=2, keepdims=True)&#10;                    force = self.config.get(&quot;force_obj&quot;)&#10;                    if self.config.get(&quot;simulation_type&quot;) == &quot;multiphase&quot;:&#10;                        force_ext = force.compute_force(&#10;                            rho, self.config.get(&quot;rho_l&quot;), self.config.get(&quot;rho_v&quot;)&#10;                        )&#10;                    else:&#10;                        force_ext = force.compute_force(rho)&#10;                    result = macroscopic(fprev, force_ext)&#10;                else:&#10;                    result = macroscopic(fprev)&#10;                if isinstance(result, tuple) and len(result) == 3:&#10;                    rho, u, force = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;force&quot;: np.array(force),&#10;                        &quot;force_ext&quot;: np.array(force_ext),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;                else:&#10;                    rho, u = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;            except Exception:&#10;                data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        else:&#10;            data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        self.io_handler.save_data_step(it, data_to_save)&#10;&#10;    def run(self, *, verbose=True):&#10;        fprev = self.simulation.initialize_fields(&#10;            self.init_type, init_dir=self.init_dir&#10;        )&#10;        nt = getattr(self.simulation, &quot;nt&quot;, 1000)&#10;        if verbose:&#10;            print(f&quot;Starting LBM simulation with {nt} time steps...&quot;)&#10;            print(&#10;                f&quot;Config -&gt; Grid: {self.simulation.grid_shape}, Multiphase: {self.simulation.multiphase}, Wetting: {self.simulation.wetting_enabled}, Force: {self.simulation.force_enabled}&quot;&#10;            )&#10;        for it in range(nt):&#10;            fprev = self.simulation.run_timestep(fprev, it)&#10;            if jnp.isnan(fprev).any():&#10;                print(f&quot;NaN encountered at timestep {it}. Stopping simulation.&quot;)&#10;                break&#10;            # skip initial transients then save every `save_interval`&#10;            if (it &gt; self.skip_interval) and (&#10;                it % self.save_interval == 0 or it == nt - 1&#10;            ):&#10;                self._save_data(it, fprev)&#10;                if verbose and hasattr(self.simulation, &quot;macroscopic&quot;):&#10;                    result = self.simulation.macroscopic(fprev)&#10;                    if isinstance(result, tuple) and len(result) &gt;= 2:&#10;                        rho, u = result[:2]&#10;                        avg_rho = np.mean(rho)&#10;                        max_u = np.max(np.sqrt(u[..., 0] ** 2 + u[..., 1] ** 2))&#10;                        print(&#10;                            f&quot;Step {it}/{nt}: avg_rho={avg_rho:.4f}, max_u={max_u:.6f}&quot;&#10;                        )&#10;        if verbose:&#10;            print(&quot;Simulation completed!&quot;)&#10;            print(f&quot;Results saved in: {self.io_handler.run_dir}&quot;)&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;import jax.numpy as jnp&#10;import inspect  # Added for simulation name detection&#10;&#10;&#10;class SimulationFactory:&#10;    @staticmethod&#10;    def create_simulation(simulation_type, **kwargs):&#10;        if simulation_type == &quot;singlephase&quot;:&#10;            from wblbm.simulations.singlephase import SinglePhaseSimulation&#10;            return SinglePhaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;multiphase&quot;:&#10;            from wblbm.simulations.multiphase import MultiphaseSimulation&#10;            return MultiphaseSimulation(**kwargs)&#10;        else:&#10;            raise ValueError(f&quot;Unknown simulation type: {simulation_type}&quot;)&#10;&#10;&#10;class Run:&#10;    &quot;&quot;&quot;&#10;    Main class to configure and run lattice Boltzmann simulations using the simulation factory.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        simulation_type=&quot;singlephase&quot;,&#10;        *,&#10;        save_interval=100,&#10;        results_dir=&quot;results&quot;,&#10;        init_type=&quot;standard&quot;,&#10;        init_dir=None,&#10;        skip_interval=0,&#10;        collision=None,  # Accept collision as a kwarg&#10;        simulation_name=None,  # Added simulation_name parameter&#10;        **kwargs,&#10;    ):&#10;        # Accept either a string or a dict for collision&#10;        collision_cfg = None&#10;        if collision is not None:&#10;            if isinstance(collision, str):&#10;                collision_cfg = {&quot;collision_scheme&quot;: collision}&#10;            elif isinstance(collision, dict):&#10;                collision_cfg = collision.copy()&#10;            else:&#10;                raise ValueError(&#10;                    &quot;collision must be either a string (for BGK) or dict (for MRT config).&quot;&#10;                )&#10;            kwargs.update(collision_cfg)&#10;        self.simulation = SimulationFactory.create_simulation(simulation_type, **kwargs)&#10;        self.save_interval = save_interval&#10;        self.skip_interval = skip_interval&#10;        self.results_dir = results_dir&#10;        self.init_type = init_type&#10;        self.init_dir = init_dir&#10;        # Auto-detect simulation name from calling function if not provided&#10;        if simulation_name is None:&#10;            frame = inspect.currentframe()&#10;            try:&#10;                caller_frame = frame.f_back&#10;                while caller_frame:&#10;                    func_name = caller_frame.f_code.co_name&#10;                    if func_name != &quot;&lt;module&gt;&quot; and not func_name.startswith(&quot;_&quot;):&#10;                        simulation_name = func_name&#10;                        break&#10;                    caller_frame = caller_frame.f_back&#10;            finally:&#10;                del frame&#10;        self.config = self._build_config(&#10;            simulation_type=simulation_type,&#10;            save_interval=save_interval,&#10;            results_dir=results_dir,&#10;            skip_interval=skip_interval,&#10;            init_type=init_type,&#10;            init_dir=init_dir,&#10;            **kwargs,&#10;        )&#10;        from wblbm.utils.io import SimulationIO&#10;&#10;        self.io_handler = SimulationIO(&#10;            base_dir=results_dir, config=self.config, simulation_name=simulation_name&#10;        )&#10;&#10;    def _build_config(self, **kwargs):&#10;        # Simple config builder for demonstration; extend as needed&#10;        return dict(**kwargs)&#10;&#10;    # TODO: need to double check that data is saved properly&#10;    def _save_data(self, it, fprev):&#10;        # Save data using the simulation's macroscopic operator&#10;        force_ext = None&#10;        if hasattr(self.simulation, &quot;macroscopic&quot;):&#10;            macroscopic = self.simulation.macroscopic&#10;            try:&#10;                if self.config.get(&quot;force_enabled&quot;) and self.config.get(&quot;force_obj&quot;):&#10;                    rho = jnp.sum(fprev, axis=2, keepdims=True)&#10;                    force = self.config.get(&quot;force_obj&quot;)&#10;                    if self.config.get(&quot;simulation_type&quot;) == &quot;multiphase&quot;:&#10;                        force_ext = force.compute_force(&#10;                            rho, self.config.get(&quot;rho_l&quot;), self.config.get(&quot;rho_v&quot;)&#10;                        )&#10;                    else:&#10;                        force_ext = force.compute_force(rho)&#10;                    result = macroscopic(fprev, force_ext)&#10;                else:&#10;                    result = macroscopic(fprev)&#10;                if isinstance(result, tuple) and len(result) == 3:&#10;                    rho, u, force = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;force&quot;: np.array(force),&#10;                        &quot;force_ext&quot;: np.array(force_ext),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;                else:&#10;                    rho, u = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;            except Exception:&#10;                data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        else:&#10;            data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        self.io_handler.save_data_step(it, data_to_save)&#10;&#10;    def run(self, *, verbose=True):&#10;        fprev = self.simulation.initialize_fields(&#10;            self.init_type, init_dir=self.init_dir&#10;        )&#10;        nt = getattr(self.simulation, &quot;nt&quot;, 1000)&#10;        if verbose:&#10;            print(f&quot;Starting LBM simulation with {nt} time steps...&quot;)&#10;            print(&#10;                f&quot;Config -&gt; Grid: {self.simulation.grid_shape}, Multiphase: {self.simulation.multiphase}, Wetting: {self.simulation.wetting_enabled}, Force: {self.simulation.force_enabled}&quot;&#10;            )&#10;        for it in range(nt):&#10;            fprev = self.simulation.run_timestep(fprev, it)&#10;            if jnp.isnan(fprev).any():&#10;                print(f&quot;NaN encountered at timestep {it}. Stopping simulation.&quot;)&#10;                break&#10;            # skip initial transients then save every `save_interval`&#10;            if (it &gt; self.skip_interval) and (&#10;                it % self.save_interval == 0 or it == nt - 1&#10;            ):&#10;                self._save_data(it, fprev)&#10;                if verbose and hasattr(self.simulation, &quot;macroscopic&quot;):&#10;                    result = self.simulation.macroscopic(fprev)&#10;                    if isinstance(result, tuple) and len(result) &gt;= 2:&#10;                        rho, u = result[:2]&#10;                        avg_rho = np.mean(rho)&#10;                        max_u = np.max(np.sqrt(u[..., 0] ** 2 + u[..., 1] ** 2))&#10;                        print(&#10;                            f&quot;Step {it}/{nt}: avg_rho={avg_rho:.4f}, max_u={max_u:.6f}&quot;&#10;                        )&#10;        if verbose:&#10;            print(&quot;Simulation completed!&quot;)&#10;            print(f&quot;Results saved in: {self.io_handler.run_dir}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/utils/io.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/utils/io.py" />
              <option name="originalContent" value="import json&#10;import jax.numpy as jnp&#10;from typing import Any, Dict&#10;from pathlib import Path&#10;import numpy as np&#10;from datetime import datetime&#10;import os&#10;import logging&#10;import sys&#10;&#10;&#10;class CustomJSONEncoder(json.JSONEncoder):&#10;    def default(self, obj):&#10;        # Handle JAX arrays&#10;        if isinstance(obj, jnp.ndarray):&#10;            return obj.tolist()&#10;        # Handle custom force objects&#10;        if hasattr(obj, &quot;__class__&quot;) and hasattr(obj, &quot;__dict__&quot;):&#10;            result = {&#10;                &quot;__class__&quot;: obj.__class__.__name__,&#10;                &quot;__module__&quot;: obj.__class__.__module__,&#10;            }&#10;            return result&#10;        # Handle other numpy arrays if present&#10;        if hasattr(obj, &quot;tolist&quot;):&#10;            return obj.tolist()&#10;        return super().default(obj)&#10;&#10;&#10;class SimulationIO:&#10;    &quot;&quot;&quot;&#10;    Handles all I/O operations for the simulation, including logging and saving results.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, base_dir: str = &quot;results&quot;, config: Dict = None, simulation_name: str = None):&#10;        &quot;&quot;&quot;&#10;        Initializes the IO handler.&#10;&#10;        Args:&#10;            base_dir (str): The base directory to store simulation results.&#10;            config (Dict, optional): A dictionary containing the simulation configuration to save.&#10;            simulation_name (str, optional): Name of the simulation to include in the results directory.&#10;        &quot;&quot;&quot;&#10;        self.base_dir = base_dir&#10;        self.simulation_name = simulation_name&#10;        self.run_dir = self._create_timestamped_directory()&#10;        self.data_dir = os.path.join(self.run_dir, &quot;data&quot;)&#10;        os.makedirs(self.data_dir, exist_ok=True)&#10;&#10;        self._setup_logging()&#10;&#10;        if config:&#10;            self.save_config(config)&#10;&#10;    def _setup_logging(self) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Configure root logger so everything printed to the console is&#10;        also written to &lt;run_dir&gt;/simulation.log. Existing handlers are&#10;        cleared to avoid duplicate lines when multiple simulations run&#10;        in the same Python interpreter (e.g. test suites).&#10;        &quot;&quot;&quot;&#10;        log_file = os.path.join(self.run_dir, &quot;simulation.log&quot;)&#10;&#10;        # 1. Build handlers&#10;        fmt = logging.Formatter(&#10;            &quot;%(asctime)s | %(levelname)s | %(message)s&quot;, datefmt=&quot;%Y-%m-%d %H:%M:%S&quot;&#10;        )&#10;        file_handler = logging.FileHandler(log_file, mode=&quot;a&quot;)&#10;        file_handler.setLevel(logging.INFO)&#10;        file_handler.setFormatter(fmt)&#10;&#10;        console_handler = logging.StreamHandler(sys.stdout)&#10;        console_handler.setLevel(logging.INFO)&#10;        console_handler.setFormatter(fmt)&#10;&#10;        # 2. Reset &amp; attach&#10;        root = logging.getLogger()&#10;        for h in root.handlers[:]:&#10;            root.removeHandler(h)  # stale handlers from previous runs&#10;        root.setLevel(logging.INFO)&#10;        root.addHandler(file_handler)&#10;        root.addHandler(console_handler)&#10;&#10;        # 3. Mirror *all* prints to the same log file&#10;        class _Tee(object):&#10;            def __init__(self, *streams):&#10;                self._streams = streams&#10;&#10;            def write(self, msg):&#10;                [s.write(msg) for s in self._streams]&#10;&#10;            def flush(self):&#10;                [s.flush() for s in self._streams]&#10;&#10;        logfile_stream = open(log_file, &quot;a&quot;, buffering=1)  # line-buffered&#10;        sys.stdout = _Tee(sys.__stdout__, logfile_stream)&#10;        sys.stderr = _Tee(sys.__stderr__, logfile_stream)  # capture tracebacks too&#10;&#10;    def _create_timestamped_directory(self) -&gt; str:&#10;        &quot;&quot;&quot;Creates a unique, timestamped directory for a single simulation run.&quot;&quot;&quot;&#10;        timestamp = datetime.now().strftime(&quot;%Y-%m-%d/%H-%M-%S&quot;)&#10;        run_dir = os.path.join(self.base_dir, timestamp)&#10;        os.makedirs(run_dir, exist_ok=True)&#10;        print(f&quot;Created results directory: {run_dir}&quot;)&#10;        return run_dir&#10;&#10;    def save_config(self, config: Dict):&#10;        &quot;&quot;&quot;Saves the simulation configuration to a JSON file using CustomJSONEncoder.&quot;&quot;&quot;&#10;        config_path = os.path.join(self.run_dir, &quot;config.json&quot;)&#10;&#10;        # Rename boundary condition details if present (avoids duplication)&#10;        if &quot;bc_config&quot; in config:&#10;            config[&quot;boundary_conditions&quot;] = config.pop(&quot;bc_config&quot;)&#10;&#10;        with open(config_path, &quot;w&quot;) as f:&#10;            json.dump(config, f, indent=4, cls=CustomJSONEncoder)&#10;        print(f&quot;Configuration saved to {config_path}&quot;)&#10;&#10;    def save_data_step(self, iteration: int, data: Dict[str, np.ndarray]):&#10;        &quot;&quot;&quot;Saves the data for a single timestep to a compressed .npz file.&quot;&quot;&quot;&#10;        filename = os.path.join(self.data_dir, f&quot;timestep_{iteration}.npz&quot;)&#10;        np.savez(filename, **data)&#10;" />
              <option name="updatedContent" value="import json&#10;import jax.numpy as jnp&#10;from typing import Any, Dict&#10;from pathlib import Path&#10;import numpy as np&#10;from datetime import datetime&#10;import os&#10;import logging&#10;import sys&#10;&#10;&#10;class CustomJSONEncoder(json.JSONEncoder):&#10;    def default(self, obj):&#10;        # Handle JAX arrays&#10;        if isinstance(obj, jnp.ndarray):&#10;            return obj.tolist()&#10;        # Handle custom force objects&#10;        if hasattr(obj, &quot;__class__&quot;) and hasattr(obj, &quot;__dict__&quot;):&#10;            result = {&#10;                &quot;__class__&quot;: obj.__class__.__name__,&#10;                &quot;__module__&quot;: obj.__class__.__module__,&#10;            }&#10;            return result&#10;        # Handle other numpy arrays if present&#10;        if hasattr(obj, &quot;tolist&quot;):&#10;            return obj.tolist()&#10;        return super().default(obj)&#10;&#10;&#10;class SimulationIO:&#10;    &quot;&quot;&quot;&#10;    Handles all I/O operations for the simulation, including logging and saving results.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, base_dir: str = &quot;results&quot;, config: Dict = None, simulation_name: str = None):&#10;        &quot;&quot;&quot;&#10;        Initializes the IO handler.&#10;&#10;        Args:&#10;            base_dir (str): The base directory to store simulation results.&#10;            config (Dict, optional): A dictionary containing the simulation configuration to save.&#10;            simulation_name (str, optional): Name of the simulation to include in the results directory.&#10;        &quot;&quot;&quot;&#10;        self.base_dir = base_dir&#10;        self.simulation_name = simulation_name&#10;        self.run_dir = self._create_timestamped_directory()&#10;        self.data_dir = os.path.join(self.run_dir, &quot;data&quot;)&#10;        os.makedirs(self.data_dir, exist_ok=True)&#10;&#10;        self._setup_logging()&#10;&#10;        if config:&#10;            self.save_config(config)&#10;&#10;    def _setup_logging(self) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Configure root logger so everything printed to the console is&#10;        also written to &lt;run_dir&gt;/simulation.log. Existing handlers are&#10;        cleared to avoid duplicate lines when multiple simulations run&#10;        in the same Python interpreter (e.g. test suites).&#10;        &quot;&quot;&quot;&#10;        log_file = os.path.join(self.run_dir, &quot;simulation.log&quot;)&#10;&#10;        # 1. Build handlers&#10;        fmt = logging.Formatter(&#10;            &quot;%(asctime)s | %(levelname)s | %(message)s&quot;, datefmt=&quot;%Y-%m-%d %H:%M:%S&quot;&#10;        )&#10;        file_handler = logging.FileHandler(log_file, mode=&quot;a&quot;)&#10;        file_handler.setLevel(logging.INFO)&#10;        file_handler.setFormatter(fmt)&#10;&#10;        console_handler = logging.StreamHandler(sys.stdout)&#10;        console_handler.setLevel(logging.INFO)&#10;        console_handler.setFormatter(fmt)&#10;&#10;        # 2. Reset &amp; attach&#10;        root = logging.getLogger()&#10;        for h in root.handlers[:]:&#10;            root.removeHandler(h)  # stale handlers from previous runs&#10;        root.setLevel(logging.INFO)&#10;        root.addHandler(file_handler)&#10;        root.addHandler(console_handler)&#10;&#10;        # 3. Mirror *all* prints to the same log file&#10;        class _Tee(object):&#10;            def __init__(self, *streams):&#10;                self._streams = streams&#10;&#10;            def write(self, msg):&#10;                [s.write(msg) for s in self._streams]&#10;&#10;            def flush(self):&#10;                [s.flush() for s in self._streams]&#10;&#10;        logfile_stream = open(log_file, &quot;a&quot;, buffering=1)  # line-buffered&#10;        sys.stdout = _Tee(sys.__stdout__, logfile_stream)&#10;        sys.stderr = _Tee(sys.__stderr__, logfile_stream)  # capture tracebacks too&#10;&#10;    def _create_timestamped_directory(self) -&gt; str:&#10;        &quot;&quot;&quot;Creates a unique, timestamped directory for a single simulation run.&quot;&quot;&quot;&#10;        timestamp = datetime.now().strftime(&quot;%Y-%m-%d_%H-%M-%S&quot;)&#10;        if self.simulation_name:&#10;            rundir = os.path.join(self.base_dir, f&quot;{self.simulation_name}_{timestamp}&quot;)&#10;        else:&#10;            rundir = os.path.join(self.base_dir, timestamp)&#10;        os.makedirs(rundir, exist_ok=True)&#10;        print(f&quot;Created results directory: {rundir}&quot;)&#10;        return rundir&#10;&#10;    def save_config(self, config: Dict):&#10;        &quot;&quot;&quot;Saves the simulation configuration to a JSON file using CustomJSONEncoder.&quot;&quot;&quot;&#10;        config_path = os.path.join(self.run_dir, &quot;config.json&quot;)&#10;&#10;        # Rename boundary condition details if present (avoids duplication)&#10;        if &quot;bc_config&quot; in config:&#10;            config[&quot;boundary_conditions&quot;] = config.pop(&quot;bc_config&quot;)&#10;&#10;        with open(config_path, &quot;w&quot;) as f:&#10;            json.dump(config, f, indent=4, cls=CustomJSONEncoder)&#10;        print(f&quot;Configuration saved to {config_path}&quot;)&#10;&#10;    def save_data_step(self, iteration: int, data: Dict[str, np.ndarray]):&#10;        &quot;&quot;&quot;Saves the data for a single timestep to a compressed .npz file.&quot;&quot;&quot;&#10;        filename = os.path.join(self.data_dir, f&quot;timestep_{iteration}.npz&quot;)&#10;        np.savez(filename, **data)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>