<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            -(2*self.a_eos)*rho_2d + self.R_eos*self.T_eos*(1 + jnp.log(rho_2d))&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        # Julia formula:&#10;        # -(2*a_eos)*ﾏ『[i,j] + R_eos*T_eos*(1 + log(ﾏ『[i,j])) + ((16*R_eos*T_eos*(b_eos*ﾏ『[i,j] -12))/((-4 + b_eos*ﾏ『[i,j])^3))&#10;        eos_2d = (&#10;            -(2 * self.a_eos) * rho_2d&#10;            + self.R_eos * self.T_eos * (1 + jnp.log(rho_2d))&#10;            + (16 * self.R_eos * self.T_eos * (self.b_eos * rho_2d - 12))&#10;              / jnp.power((-4 + self.b_eos * rho_2d), 3)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_dw.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_dw.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseDW(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the double well implementation.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            2&#10;            * self.beta&#10;            * (rho_2d - self.rho_l)&#10;            * (rho_2d - self.rho_v)&#10;            * (2 * rho_2d - self.rho_l - self.rho_v)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseDW(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the double well implementation.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def eos(self, rho):&#10;        &quot;&quot;&quot;&#10;        Default: Double Well EOS.&#10;        &quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]&#10;        eos_2d = (&#10;            2 * self.beta&#10;            * (rho_2d - self.rho_l)&#10;            * (rho_2d - self.rho_v)&#10;            * (2 * rho_2d - self.rho_l - self.rho_v)&#10;        )&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/run/run.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/run/run.py" />
              <option name="originalContent" value="import numpy as np&#10;import jax.numpy as jnp&#10;&#10;&#10;class SimulationFactory:&#10;    @staticmethod&#10;    def create_simulation(simulation_type, **kwargs):&#10;        if simulation_type == &quot;singlephase&quot;:&#10;            from wblbm.simulations.singlephase import SinglePhaseSimulation&#10;&#10;            return SinglePhaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;multiphase&quot;:&#10;            from wblbm.simulations.multiphase import MultiphaseSimulation&#10;&#10;            return MultiphaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;wetting&quot;:&#10;            from wblbm.simulations.wetting import WettingSimulation&#10;&#10;            return WettingSimulation(**kwargs)&#10;        else:&#10;            raise ValueError(f&quot;Unknown simulation type: {simulation_type}&quot;)&#10;&#10;&#10;class Run:&#10;    &quot;&quot;&quot;&#10;    Main class to configure and run lattice Boltzmann simulations using the simulation factory.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        simulation_type=&quot;singlephase&quot;,&#10;        *,&#10;        save_interval=100,&#10;        results_dir=&quot;results&quot;,&#10;        init_type=&quot;standard&quot;,&#10;        init_dir=None,&#10;        skip_interval=0,&#10;        **kwargs,&#10;    ):&#10;        # Allow collision config as a dict or CLI/JSON entry and pass it untouched&#10;        collision_cfg = kwargs.pop(&quot;collision&quot;, None)&#10;        if collision_cfg is not None:&#10;            kwargs.update(collision_cfg)&#10;        self.simulation = SimulationFactory.create_simulation(simulation_type, **kwargs)&#10;        self.save_interval = save_interval&#10;        self.skip_interval = skip_interval&#10;        self.results_dir = results_dir&#10;        self.init_type = init_type&#10;        self.init_dir = init_dir&#10;        self.config = self._build_config(&#10;            simulation_type=simulation_type,&#10;            save_interval=save_interval,&#10;            results_dir=results_dir,&#10;            skip_interval=skip_interval,&#10;            init_type=init_type,&#10;            init_dir=init_dir,&#10;            **kwargs,&#10;        )&#10;        from wblbm.utils.io import SimulationIO&#10;&#10;        self.io_handler = SimulationIO(base_dir=results_dir, config=self.config)&#10;&#10;    def _build_config(self, **kwargs):&#10;        # Simple config builder for demonstration; extend as needed&#10;        return dict(**kwargs)&#10;&#10;    def _save_data(self, it, fprev):&#10;        # Save data using the simulation's macroscopic operator&#10;        force_ext = None&#10;        if hasattr(self.simulation, &quot;macroscopic&quot;):&#10;            macroscopic = self.simulation.macroscopic&#10;            try:&#10;                if self.config.get(&quot;force_enabled&quot;) and self.config.get(&quot;force_obj&quot;):&#10;                    rho = jnp.sum(fprev, axis=2, keepdims=True)&#10;                    force = self.config.get(&quot;force_obj&quot;)&#10;                    if self.config.get(&quot;simulation_type&quot;) == &quot;multiphase&quot;:&#10;                        force_ext = force.compute_force(&#10;                            rho, self.config.get(&quot;rho_l&quot;), self.config.get(&quot;rho_v&quot;)&#10;                        )&#10;                    else:&#10;                        force_ext = force.compute_force(rho)&#10;                    result = macroscopic(fprev, force_ext)&#10;                else:&#10;                    result = macroscopic(fprev)&#10;                if isinstance(result, tuple) and len(result) == 3:&#10;                    rho, u, force = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;force&quot;: np.array(force),&#10;                        &quot;force_ext&quot;: np.array(force_ext),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;                else:&#10;                    rho, u = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;            except Exception:&#10;                data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        else:&#10;            data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        self.io_handler.save_data_step(it, data_to_save)&#10;&#10;    def run(self, *, verbose=True):&#10;        fprev = self.simulation.initialize_fields(&#10;            self.init_type, init_dir=self.init_dir&#10;        )&#10;        nt = getattr(self.simulation, &quot;nt&quot;, 1000)&#10;        if verbose:&#10;            print(f&quot;Starting LBM simulation with {nt} time steps...&quot;)&#10;            print(&#10;                f&quot;Config -&gt; Grid: {self.simulation.grid_shape}, Multiphase: {self.simulation.multiphase}, Wetting: {self.simulation.wetting_enabled}, Force: {self.simulation.force_enabled}&quot;&#10;            )&#10;        for it in range(nt):&#10;            fprev = self.simulation.run_timestep(fprev, it)&#10;            if jnp.isnan(fprev).any():&#10;                print(f&quot;NaN encountered at timestep {it}. Stopping simulation.&quot;)&#10;                break&#10;            # skip initial transients then save every `save_interval`&#10;            if (it &gt; self.skip_interval) and (&#10;                it % self.save_interval == 0 or it == nt - 1&#10;            ):&#10;                self._save_data(it, fprev)&#10;                if verbose and hasattr(self.simulation, &quot;macroscopic&quot;):&#10;                    result = self.simulation.macroscopic(fprev)&#10;                    if isinstance(result, tuple) and len(result) &gt;= 2:&#10;                        rho, u = result[:2]&#10;                        avg_rho = np.mean(rho)&#10;                        max_u = np.max(np.sqrt(u[..., 0] ** 2 + u[..., 1] ** 2))&#10;                        print(&#10;                            f&quot;Step {it}/{nt}: avg_rho={avg_rho:.4f}, max_u={max_u:.6f}&quot;&#10;                        )&#10;        if verbose:&#10;            print(&quot;Simulation completed!&quot;)&#10;            print(f&quot;Results saved in: {self.io_handler.run_dir}&quot;)&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;import jax.numpy as jnp&#10;&#10;&#10;class SimulationFactory:&#10;    @staticmethod&#10;    def create_simulation(simulation_type, **kwargs):&#10;        if simulation_type == &quot;singlephase&quot;:&#10;            from wblbm.simulations.singlephase import SinglePhaseSimulation&#10;&#10;            return SinglePhaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;multiphase&quot;:&#10;            from wblbm.simulations.multiphase import MultiphaseSimulation&#10;&#10;            return MultiphaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;wetting&quot;:&#10;            from wblbm.simulations.wetting import WettingSimulation&#10;&#10;            return WettingSimulation(**kwargs)&#10;        else:&#10;            raise ValueError(f&quot;Unknown simulation type: {simulation_type}&quot;)&#10;&#10;&#10;class Run:&#10;    &quot;&quot;&quot;&#10;    Main class to configure and run lattice Boltzmann simulations using the simulation factory.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        simulation_type=&quot;singlephase&quot;,&#10;        *,&#10;        save_interval=100,&#10;        results_dir=&quot;results&quot;,&#10;        init_type=&quot;standard&quot;,&#10;        init_dir=None,&#10;        skip_interval=0,&#10;        collision=None,  # Accept collision as a kwarg&#10;        **kwargs,&#10;    ):&#10;        # Accept either a string or a dict for collision&#10;        collision_cfg = None&#10;        if collision is not None:&#10;            if isinstance(collision, str):&#10;                collision_cfg = {&quot;collision_scheme&quot;: collision}&#10;            elif isinstance(collision, dict):&#10;                collision_cfg = collision.copy()&#10;            else:&#10;                raise ValueError(&#10;                    &quot;collision must be either a string (for BGK) or dict (for MRT config).&quot;&#10;                )&#10;            kwargs.update(collision_cfg)&#10;        self.simulation = SimulationFactory.create_simulation(simulation_type, **kwargs)&#10;        self.save_interval = save_interval&#10;        self.skip_interval = skip_interval&#10;        self.results_dir = results_dir&#10;        self.init_type = init_type&#10;        self.init_dir = init_dir&#10;        self.config = self._build_config(&#10;            simulation_type=simulation_type,&#10;            save_interval=save_interval,&#10;            results_dir=results_dir,&#10;            skip_interval=skip_interval,&#10;            init_type=init_type,&#10;            init_dir=init_dir,&#10;            **kwargs,&#10;        )&#10;        from wblbm.utils.io import SimulationIO&#10;&#10;        self.io_handler = SimulationIO(base_dir=results_dir, config=self.config)&#10;&#10;    def _build_config(self, **kwargs):&#10;        # Simple config builder for demonstration; extend as needed&#10;        return dict(**kwargs)&#10;&#10;    def _save_data(self, it, fprev):&#10;        # Save data using the simulation's macroscopic operator&#10;        force_ext = None&#10;        if hasattr(self.simulation, &quot;macroscopic&quot;):&#10;            macroscopic = self.simulation.macroscopic&#10;            try:&#10;                if self.config.get(&quot;force_enabled&quot;) and self.config.get(&quot;force_obj&quot;):&#10;                    rho = jnp.sum(fprev, axis=2, keepdims=True)&#10;                    force = self.config.get(&quot;force_obj&quot;)&#10;                    if self.config.get(&quot;simulation_type&quot;) == &quot;multiphase&quot;:&#10;                        force_ext = force.compute_force(&#10;                            rho, self.config.get(&quot;rho_l&quot;), self.config.get(&quot;rho_v&quot;)&#10;                        )&#10;                    else:&#10;                        force_ext = force.compute_force(rho)&#10;                    result = macroscopic(fprev, force_ext)&#10;                else:&#10;                    result = macroscopic(fprev)&#10;                if isinstance(result, tuple) and len(result) == 3:&#10;                    rho, u, force = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;force&quot;: np.array(force),&#10;                        &quot;force_ext&quot;: np.array(force_ext),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;                else:&#10;                    rho, u = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;            except Exception:&#10;                data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        else:&#10;            data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        self.io_handler.save_data_step(it, data_to_save)&#10;&#10;    def run(self, *, verbose=True):&#10;        fprev = self.simulation.initialize_fields(&#10;            self.init_type, init_dir=self.init_dir&#10;        )&#10;        nt = getattr(self.simulation, &quot;nt&quot;, 1000)&#10;        if verbose:&#10;            print(f&quot;Starting LBM simulation with {nt} time steps...&quot;)&#10;            print(&#10;                f&quot;Config -&gt; Grid: {self.simulation.grid_shape}, Multiphase: {self.simulation.multiphase}, Wetting: {self.simulation.wetting_enabled}, Force: {self.simulation.force_enabled}&quot;&#10;            )&#10;        for it in range(nt):&#10;            fprev = self.simulation.run_timestep(fprev, it)&#10;            if jnp.isnan(fprev).any():&#10;                print(f&quot;NaN encountered at timestep {it}. Stopping simulation.&quot;)&#10;                break&#10;            # skip initial transients then save every `save_interval`&#10;            if (it &gt; self.skip_interval) and (&#10;                it % self.save_interval == 0 or it == nt - 1&#10;            ):&#10;                self._save_data(it, fprev)&#10;                if verbose and hasattr(self.simulation, &quot;macroscopic&quot;):&#10;                    result = self.simulation.macroscopic(fprev)&#10;                    if isinstance(result, tuple) and len(result) &gt;= 2:&#10;                        rho, u = result[:2]&#10;                        avg_rho = np.mean(rho)&#10;                        max_u = np.max(np.sqrt(u[..., 0] ** 2 + u[..., 1] ** 2))&#10;                        print(&#10;                            f&quot;Step {it}/{nt}: avg_rho={avg_rho:.4f}, max_u={max_u:.6f}&quot;&#10;                        )&#10;        if verbose:&#10;            print(&quot;Simulation completed!&quot;)&#10;            print(f&quot;Results saved in: {self.io_handler.run_dir}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>