<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            -(2*self.a_eos)*rho_2d + self.R_eos*self.T_eos*(1 + jnp.log(rho_2d))&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        # Julia formula:&#10;        # -(2*a_eos)*ﾏ『[i,j] + R_eos*T_eos*(1 + log(ﾏ『[i,j])) + ((16*R_eos*T_eos*(b_eos*ﾏ『[i,j] -12))/((-4 + b_eos*ﾏ『[i,j])^3))&#10;        eos_2d = (&#10;            -(2 * self.a_eos) * rho_2d&#10;            + self.R_eos * self.T_eos * (1 + jnp.log(rho_2d))&#10;            + (16 * self.R_eos * self.T_eos * (self.b_eos * rho_2d - 12))&#10;              / jnp.power((-4 + self.b_eos * rho_2d), 3)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_dw.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_dw.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseDW(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the double well implementation.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            2&#10;            * self.beta&#10;            * (rho_2d - self.rho_l)&#10;            * (rho_2d - self.rho_v)&#10;            * (2 * rho_2d - self.rho_l - self.rho_v)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseDW(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the double well implementation.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def eos(self, rho):&#10;        &quot;&quot;&quot;&#10;        Default: Double Well EOS.&#10;        &quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]&#10;        eos_2d = (&#10;            2 * self.beta&#10;            * (rho_2d - self.rho_l)&#10;            * (rho_2d - self.rho_v)&#10;            * (2 * rho_2d - self.rho_l - self.rho_v)&#10;        )&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/run/run.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/run/run.py" />
              <option name="originalContent" value="import numpy as np&#10;import jax.numpy as jnp&#10;&#10;&#10;class SimulationFactory:&#10;    @staticmethod&#10;    def create_simulation(simulation_type, **kwargs):&#10;        if simulation_type == &quot;singlephase&quot;:&#10;            from wblbm.simulations.singlephase import SinglePhaseSimulation&#10;&#10;            return SinglePhaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;multiphase&quot;:&#10;            from wblbm.simulations.multiphase import MultiphaseSimulation&#10;&#10;            return MultiphaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;wetting&quot;:&#10;            from wblbm.simulations.wetting import WettingSimulation&#10;&#10;            return WettingSimulation(**kwargs)&#10;        else:&#10;            raise ValueError(f&quot;Unknown simulation type: {simulation_type}&quot;)&#10;&#10;&#10;class Run:&#10;    &quot;&quot;&quot;&#10;    Main class to configure and run lattice Boltzmann simulations using the simulation factory.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        simulation_type=&quot;singlephase&quot;,&#10;        *,&#10;        save_interval=100,&#10;        results_dir=&quot;results&quot;,&#10;        init_type=&quot;standard&quot;,&#10;        init_dir=None,&#10;        skip_interval=0,&#10;        **kwargs,&#10;    ):&#10;        # Allow collision config as a dict or CLI/JSON entry and pass it untouched&#10;        collision_cfg = kwargs.pop(&quot;collision&quot;, None)&#10;        if collision_cfg is not None:&#10;            kwargs.update(collision_cfg)&#10;        self.simulation = SimulationFactory.create_simulation(simulation_type, **kwargs)&#10;        self.save_interval = save_interval&#10;        self.skip_interval = skip_interval&#10;        self.results_dir = results_dir&#10;        self.init_type = init_type&#10;        self.init_dir = init_dir&#10;        self.config = self._build_config(&#10;            simulation_type=simulation_type,&#10;            save_interval=save_interval,&#10;            results_dir=results_dir,&#10;            skip_interval=skip_interval,&#10;            init_type=init_type,&#10;            init_dir=init_dir,&#10;            **kwargs,&#10;        )&#10;        from wblbm.utils.io import SimulationIO&#10;&#10;        self.io_handler = SimulationIO(base_dir=results_dir, config=self.config)&#10;&#10;    def _build_config(self, **kwargs):&#10;        # Simple config builder for demonstration; extend as needed&#10;        return dict(**kwargs)&#10;&#10;    def _save_data(self, it, fprev):&#10;        # Save data using the simulation's macroscopic operator&#10;        force_ext = None&#10;        if hasattr(self.simulation, &quot;macroscopic&quot;):&#10;            macroscopic = self.simulation.macroscopic&#10;            try:&#10;                if self.config.get(&quot;force_enabled&quot;) and self.config.get(&quot;force_obj&quot;):&#10;                    rho = jnp.sum(fprev, axis=2, keepdims=True)&#10;                    force = self.config.get(&quot;force_obj&quot;)&#10;                    if self.config.get(&quot;simulation_type&quot;) == &quot;multiphase&quot;:&#10;                        force_ext = force.compute_force(&#10;                            rho, self.config.get(&quot;rho_l&quot;), self.config.get(&quot;rho_v&quot;)&#10;                        )&#10;                    else:&#10;                        force_ext = force.compute_force(rho)&#10;                    result = macroscopic(fprev, force_ext)&#10;                else:&#10;                    result = macroscopic(fprev)&#10;                if isinstance(result, tuple) and len(result) == 3:&#10;                    rho, u, force = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;force&quot;: np.array(force),&#10;                        &quot;force_ext&quot;: np.array(force_ext),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;                else:&#10;                    rho, u = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;            except Exception:&#10;                data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        else:&#10;            data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        self.io_handler.save_data_step(it, data_to_save)&#10;&#10;    def run(self, *, verbose=True):&#10;        fprev = self.simulation.initialize_fields(&#10;            self.init_type, init_dir=self.init_dir&#10;        )&#10;        nt = getattr(self.simulation, &quot;nt&quot;, 1000)&#10;        if verbose:&#10;            print(f&quot;Starting LBM simulation with {nt} time steps...&quot;)&#10;            print(&#10;                f&quot;Config -&gt; Grid: {self.simulation.grid_shape}, Multiphase: {self.simulation.multiphase}, Wetting: {self.simulation.wetting_enabled}, Force: {self.simulation.force_enabled}&quot;&#10;            )&#10;        for it in range(nt):&#10;            fprev = self.simulation.run_timestep(fprev, it)&#10;            if jnp.isnan(fprev).any():&#10;                print(f&quot;NaN encountered at timestep {it}. Stopping simulation.&quot;)&#10;                break&#10;            # skip initial transients then save every `save_interval`&#10;            if (it &gt; self.skip_interval) and (&#10;                it % self.save_interval == 0 or it == nt - 1&#10;            ):&#10;                self._save_data(it, fprev)&#10;                if verbose and hasattr(self.simulation, &quot;macroscopic&quot;):&#10;                    result = self.simulation.macroscopic(fprev)&#10;                    if isinstance(result, tuple) and len(result) &gt;= 2:&#10;                        rho, u = result[:2]&#10;                        avg_rho = np.mean(rho)&#10;                        max_u = np.max(np.sqrt(u[..., 0] ** 2 + u[..., 1] ** 2))&#10;                        print(&#10;                            f&quot;Step {it}/{nt}: avg_rho={avg_rho:.4f}, max_u={max_u:.6f}&quot;&#10;                        )&#10;        if verbose:&#10;            print(&quot;Simulation completed!&quot;)&#10;            print(f&quot;Results saved in: {self.io_handler.run_dir}&quot;)&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;import jax.numpy as jnp&#10;&#10;&#10;class SimulationFactory:&#10;    @staticmethod&#10;    def create_simulation(simulation_type, **kwargs):&#10;        if simulation_type == &quot;singlephase&quot;:&#10;            from wblbm.simulations.singlephase import SinglePhaseSimulation&#10;&#10;            return SinglePhaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;multiphase&quot;:&#10;            from wblbm.simulations.multiphase import MultiphaseSimulation&#10;&#10;            return MultiphaseSimulation(**kwargs)&#10;        elif simulation_type == &quot;wetting&quot;:&#10;            from wblbm.simulations.wetting import WettingSimulation&#10;&#10;            return WettingSimulation(**kwargs)&#10;        else:&#10;            raise ValueError(f&quot;Unknown simulation type: {simulation_type}&quot;)&#10;&#10;&#10;class Run:&#10;    &quot;&quot;&quot;&#10;    Main class to configure and run lattice Boltzmann simulations using the simulation factory.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        simulation_type=&quot;singlephase&quot;,&#10;        *,&#10;        save_interval=100,&#10;        results_dir=&quot;results&quot;,&#10;        init_type=&quot;standard&quot;,&#10;        init_dir=None,&#10;        skip_interval=0,&#10;        collision=None,  # Accept collision as a kwarg&#10;        **kwargs,&#10;    ):&#10;        # Accept either a string or a dict for collision&#10;        collision_cfg = None&#10;        if collision is not None:&#10;            if isinstance(collision, str):&#10;                collision_cfg = {&quot;collision_scheme&quot;: collision}&#10;            elif isinstance(collision, dict):&#10;                collision_cfg = collision.copy()&#10;            else:&#10;                raise ValueError(&#10;                    &quot;collision must be either a string (for BGK) or dict (for MRT config).&quot;&#10;                )&#10;            kwargs.update(collision_cfg)&#10;        self.simulation = SimulationFactory.create_simulation(simulation_type, **kwargs)&#10;        self.save_interval = save_interval&#10;        self.skip_interval = skip_interval&#10;        self.results_dir = results_dir&#10;        self.init_type = init_type&#10;        self.init_dir = init_dir&#10;        self.config = self._build_config(&#10;            simulation_type=simulation_type,&#10;            save_interval=save_interval,&#10;            results_dir=results_dir,&#10;            skip_interval=skip_interval,&#10;            init_type=init_type,&#10;            init_dir=init_dir,&#10;            **kwargs,&#10;        )&#10;        from wblbm.utils.io import SimulationIO&#10;&#10;        self.io_handler = SimulationIO(base_dir=results_dir, config=self.config)&#10;&#10;    def _build_config(self, **kwargs):&#10;        # Simple config builder for demonstration; extend as needed&#10;        return dict(**kwargs)&#10;&#10;    def _save_data(self, it, fprev):&#10;        # Save data using the simulation's macroscopic operator&#10;        force_ext = None&#10;        if hasattr(self.simulation, &quot;macroscopic&quot;):&#10;            macroscopic = self.simulation.macroscopic&#10;            try:&#10;                if self.config.get(&quot;force_enabled&quot;) and self.config.get(&quot;force_obj&quot;):&#10;                    rho = jnp.sum(fprev, axis=2, keepdims=True)&#10;                    force = self.config.get(&quot;force_obj&quot;)&#10;                    if self.config.get(&quot;simulation_type&quot;) == &quot;multiphase&quot;:&#10;                        force_ext = force.compute_force(&#10;                            rho, self.config.get(&quot;rho_l&quot;), self.config.get(&quot;rho_v&quot;)&#10;                        )&#10;                    else:&#10;                        force_ext = force.compute_force(rho)&#10;                    result = macroscopic(fprev, force_ext)&#10;                else:&#10;                    result = macroscopic(fprev)&#10;                if isinstance(result, tuple) and len(result) == 3:&#10;                    rho, u, force = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;force&quot;: np.array(force),&#10;                        &quot;force_ext&quot;: np.array(force_ext),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;                else:&#10;                    rho, u = result&#10;                    data_to_save = {&#10;                        &quot;rho&quot;: np.array(rho),&#10;                        &quot;u&quot;: np.array(u),&#10;                        &quot;f&quot;: np.array(fprev),&#10;                    }&#10;            except Exception:&#10;                data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        else:&#10;            data_to_save = {&quot;f&quot;: np.array(fprev)}&#10;        self.io_handler.save_data_step(it, data_to_save)&#10;&#10;    def run(self, *, verbose=True):&#10;        fprev = self.simulation.initialize_fields(&#10;            self.init_type, init_dir=self.init_dir&#10;        )&#10;        nt = getattr(self.simulation, &quot;nt&quot;, 1000)&#10;        if verbose:&#10;            print(f&quot;Starting LBM simulation with {nt} time steps...&quot;)&#10;            print(&#10;                f&quot;Config -&gt; Grid: {self.simulation.grid_shape}, Multiphase: {self.simulation.multiphase}, Wetting: {self.simulation.wetting_enabled}, Force: {self.simulation.force_enabled}&quot;&#10;            )&#10;        for it in range(nt):&#10;            fprev = self.simulation.run_timestep(fprev, it)&#10;            if jnp.isnan(fprev).any():&#10;                print(f&quot;NaN encountered at timestep {it}. Stopping simulation.&quot;)&#10;                break&#10;            # skip initial transients then save every `save_interval`&#10;            if (it &gt; self.skip_interval) and (&#10;                it % self.save_interval == 0 or it == nt - 1&#10;            ):&#10;                self._save_data(it, fprev)&#10;                if verbose and hasattr(self.simulation, &quot;macroscopic&quot;):&#10;                    result = self.simulation.macroscopic(fprev)&#10;                    if isinstance(result, tuple) and len(result) &gt;= 2:&#10;                        rho, u = result[:2]&#10;                        avg_rho = np.mean(rho)&#10;                        max_u = np.max(np.sqrt(u[..., 0] ** 2 + u[..., 1] ** 2))&#10;                        print(&#10;                            f&quot;Step {it}/{nt}: avg_rho={avg_rho:.4f}, max_u={max_u:.6f}&quot;&#10;                        )&#10;        if verbose:&#10;            print(&quot;Simulation completed!&quot;)&#10;            print(f&quot;Results saved in: {self.io_handler.run_dir}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/utils/maxwellreconstruction/maxwell_reconstruction.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/utils/maxwellreconstruction/maxwell_reconstruction.py" />
              <option name="originalContent" value="import os&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;from scipy.optimize import brentq&#10;import pandas as pd&#10;&#10;# Maxwell construction for Carnahan-Starling EOS&#10;rho_c = 3.5&#10;p_c = 0.001&#10;Tr = 0.5&#10;&#10;# Calculate EOS parameters&#10;b_eos = 0.5218 / rho_c&#10;a_eos = ((b_eos ** 2) * p_c) / ((0.3773 ** 2) * 0.4963)&#10;R_eos = 1.0&#10;Tc = (0.3773 * a_eos) / (b_eos * R_eos)&#10;T_eos = Tr * Tc&#10;&#10;&#10;def pressure_function(x):&#10;    &quot;&quot;&quot;Calculate pressure using Carnahan-Starling EOS&quot;&quot;&quot;&#10;    return (R_eos * T_eos * (1 / x) *&#10;            ((1 + (b_eos / (x * 4)) + ((b_eos / (x * 4)) ** 2) - ((b_eos / (x * 4)) ** 3)) /&#10;             ((1 - (b_eos / (x * 4))) ** 3)) - a_eos * (1 / (x ** 2)))&#10;&#10;&#10;def pressure_derivative(x):&#10;    &quot;&quot;&quot;Calculate derivative of pressure with respect to volume&quot;&quot;&quot;&#10;    return (R_eos * T_eos * ((b_eos * (1 / x)) ** 4 - 16 * ((b_eos * (1 / x)) ** 3) +&#10;                             64 * ((b_eos * (1 / x)) ** 2) + 256 * b_eos * (1 / x) + 256) /&#10;            ((4 - b_eos * (1 / x)) ** 4) - 2 * a_eos * (1 / x))&#10;&#10;&#10;def find_extrema(a_int, b_int):&#10;    &quot;&quot;&quot;Find the maximum and minimum points of the pressure function.&#10;&#10;    This part of the code detects sign changes in the derivative of the pressure function&#10;    over a range of test points. When a sign change is found between two consecutive points,&#10;    it uses Brent's method (brentq) to accurately find the root (where the derivative crosses zero),&#10;    which corresponds to an extremum (maximum or minimum) of the pressure function.&#10;    All found extrema are collected and returned in the extrema list. This is useful for&#10;    identifying phase transition points in the Maxwell construction.&#10;    &quot;&quot;&quot;&#10;&#10;    def derivative_zero(x):&#10;        return pressure_derivative(x)&#10;&#10;    extrema = []&#10;&#10;    # Sample points to find sign changes&#10;    test_points = np.linspace(a_int, b_int, 1000)&#10;    derivative_values = [pressure_derivative(x) for x in test_points]&#10;&#10;    for i in range(len(test_points) - 1):&#10;        if derivative_values[i] * derivative_values[i + 1] &lt; 0:&#10;            try:&#10;                root = brentq(derivative_zero, test_points[i], test_points[i + 1])&#10;                extrema.append(root)&#10;            except:&#10;                continue&#10;&#10;    return extrema&#10;&#10;&#10;def riemann_integration(a, b, n, f):&#10;    &quot;&quot;&quot;Riemann integration approximation&quot;&quot;&quot;&#10;    delta = (b - a) / n&#10;    xs = np.linspace(a, b - delta, n)&#10;    fx = np.array([f(x) for x in xs])&#10;    integral = np.sum(fx) * delta&#10;    return integral&#10;&#10;&#10;def maxwell_construction(max_min, a_int, b_int, max_iterations=40, tolerance=1e-7):&#10;    &quot;&quot;&quot;&#10;    Perform Maxwell construction to find coexistence densities&#10;    &quot;&quot;&quot;&#10;    if len(max_min) &lt; 2:&#10;        print(&quot;Insufficient extrema for Maxwell construction&quot;)&#10;        return None, None, None, None, None&#10;&#10;    guess = 0.1&#10;&#10;    # Initial guesses for the coexistence points&#10;    a_ = max_min[0] + guess * (max_min[1] - max_min[0])&#10;    b = max_min[1] + guess * (max_min[0] - max_min[1])&#10;&#10;    g = (a_ + b) / 2&#10;&#10;    # Check if Maxwell construction is feasible&#10;    p_at_extrema = [pressure_function(x) for x in max_min]&#10;    print(f&quot;Pressures at extrema: {p_at_extrema}&quot;)&#10;&#10;    # If pressure doesn't change sign significantly, Maxwell construction may not be meaningful&#10;    if all(p &gt;= 0 for p in p_at_extrema) and (max(p_at_extrema) - min(p_at_extrema)) &lt; 1e-6:&#10;        print(&quot;Pressure variation too small for meaningful Maxwell construction&quot;)&#10;        # Return approximate coexistence points&#10;        return (max_min[0] * 0.9, max_min[1] * 1.1), 0, 0, max_min[0], max_min[1]&#10;&#10;    # Handle negative pressure case&#10;    if pressure_function(max_min[0]) &lt; 0:&#10;        try:&#10;            zero_pressure = brentq(pressure_function, max_min[0], max_min[1])&#10;            a_ = zero_pressure * (1 + guess)&#10;        except:&#10;            pass&#10;&#10;    print(f&quot;Initial guesses: a = {a_}, b = {b}&quot;)&#10;    print(f&quot;Pressure at a = {pressure_function(a_)}&quot;)&#10;&#10;    # Variables to track integration results&#10;    integd_, integc_ = 0, 0&#10;&#10;    for iteration in range(max_iterations):&#10;        print(f&quot;Iteration {iteration + 1}&quot;)&#10;&#10;        c, d = pressure_function(a_), pressure_function(b)&#10;&#10;        # Handle negative pressure&#10;        while c &lt; 0:&#10;            g = (a_ + b) / 2&#10;            a_ = g&#10;            c = pressure_function(a_)&#10;&#10;        # Define pressure difference functions&#10;        def pc_function(x):&#10;            return pressure_function(x) - c&#10;&#10;        def pd_function(x):&#10;            return pressure_function(x) - d&#10;&#10;        # Find intersection points with better error handling&#10;        try:&#10;            i1 = brentq(pc_function, a_int, max_min[0])&#10;            i3 = brentq(pc_function, max_min[1], b_int)&#10;            integc_ = riemann_integration(i1, i3, 100000, pc_function)&#10;            print(f&quot;Integral c: {integc_}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Could not find intersection for pressure c: {e}&quot;)&#10;            # Try to continue with a fallback approach&#10;            integc_ = 0&#10;&#10;        try:&#10;            j1 = brentq(pd_function, a_int, max_min[0])&#10;            j3 = brentq(pd_function, max_min[1], b_int)&#10;            integd_ = riemann_integration(j1, j3, 100000, pd_function)&#10;            print(f&quot;Integral d: {integd_}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Could not find intersection for pressure d: {e}&quot;)&#10;            # Try to continue with a fallback approach&#10;            integd_ = 0&#10;&#10;        # Bisection step&#10;        g = (a_ + b) / 2&#10;        e = pressure_function(g)&#10;&#10;        def pe_function(x):&#10;            return pressure_function(x) - e&#10;&#10;        try:&#10;            m1 = brentq(pe_function, a_int, max_min[0])&#10;            m3 = brentq(pe_function, max_min[1], b_int)&#10;            intege = riemann_integration(m1, m3, 100000, pe_function)&#10;&#10;            # Update based on integral sign&#10;            if intege &gt; 0:&#10;                a_ = g&#10;            else:&#10;                b = g&#10;&#10;        except Exception as e:&#10;            print(f&quot;Could not find intersection for pressure e: {e}&quot;)&#10;            # If we can't proceed, break with current values&#10;            break&#10;&#10;        # Check convergence&#10;        if abs(intege) &lt; tolerance:&#10;            print(f&quot;Converged after {iteration + 1} iterations&quot;)&#10;            break&#10;&#10;    # Final calculation - g should be defined by now&#10;    try:&#10;        e = pressure_function(g)&#10;&#10;        def pf_function(x):&#10;            return pressure_function(x) - e&#10;&#10;        k1 = brentq(pf_function, a_int, max_min[0])&#10;        k3 = brentq(pf_function, max_min[1], b_int)&#10;        k = (k1, k3)&#10;        print(f&quot;Final coexistence points: {k}&quot;)&#10;&#10;        return k, integd_, integc_, a_, b&#10;    except Exception as e:&#10;        print(f&quot;Could not find final intersection points: {e}&quot;)&#10;        # Return approximate values based on extrema&#10;        return (max_min[0], max_min[1]), integd_, integc_, a_, b&#10;&#10;&#10;# Main execution&#10;if __name__ == &quot;__main__&quot;:&#10;    # Define integration bounds&#10;    a_int, b_int = 0.09, 50&#10;&#10;    # Generate volume array and calculate pressure and derivative&#10;    rho_w = np.arange(a_int, b_int, 0.01)&#10;    p_bulk = np.array([pressure_function(rho) for rho in rho_w])&#10;    p_dash_bulk = np.array([pressure_derivative(rho) for rho in rho_w])&#10;&#10;    # Find extrema and perform Maxwell construction&#10;    max_min = find_extrema(a_int, b_int)&#10;    print(f&quot;Extrema found at: {max_min}&quot;)&#10;&#10;    k = None&#10;    if len(max_min) &gt;= 2:&#10;        k, integd, integc, a, b = maxwell_construction(max_min, a_int, b_int)&#10;&#10;        if k is not None:&#10;            maxwell_pressure = pressure_function((k[0] + k[1]) / 2)&#10;            print(f&quot;Maxwell construction coexistence pressure: {maxwell_pressure}&quot;)&#10;            print(f&quot;Coexistence volumes: {k[0]:.6f}, {k[1]:.6f}&quot;)&#10;            print(f&quot;Coexistence denisties: {1 / k[0]:.6f}, {1 / k[1]:.6f}&quot;)&#10;    else:&#10;        print(&quot;Could not find sufficient extrema for Maxwell construction&quot;)&#10;&#10;    # Create and save results&#10;    results_df = pd.DataFrame({&#10;        'Volume': rho_w,&#10;        'Pressure': p_bulk,&#10;        'Pressure_Derivative': p_dash_bulk&#10;    })&#10;&#10;    results_df.to_csv('carnahan_starling_results.csv', index=False)&#10;    print(&quot;Results saved to carnahan_starling_results.csv&quot;)&#10;&#10;    # Plot results&#10;    plt.figure(figsize=(10, 6))&#10;    plt.plot(rho_w, p_bulk, label='Carnahan-Starling EOS', linewidth=2)&#10;&#10;    if k is not None:&#10;        maxwell_pressure = pressure_function((k[0] + k[1]) / 2)&#10;        plt.axhline(y=maxwell_pressure, color='red', linestyle='--',&#10;                    label=f'Maxwell Construction (P = {maxwell_pressure:.6f})')&#10;        plt.axvline(x=k[0], color='green', linestyle=':', alpha=0.7,&#10;                    label=f'Liquid volume = {k[0]:.3f}')&#10;        plt.axvline(x=k[1], color='blue', linestyle=':', alpha=0.7,&#10;                    label=f'Vapor volume = {k[1]:.3f}')&#10;&#10;    plt.xlabel('Volume, V')&#10;    plt.ylabel('Pressure, P')&#10;    plt.title('Carnahan-Starling EOS with Maxwell Construction')&#10;    plt.legend()&#10;    plt.grid(True, alpha=0.3)&#10;    plt.xlim(0, 10)  # Focus on relevant range&#10;&#10;    # Save the plot to the specified directory with a timestamp to avoid overwriting&#10;    import datetime&#10;    save_dir = &quot;/Users/sbszkudlarek/PycharmProjects/WBLBM/example/tests/maxwell_reconstruction&quot;&#10;    os.makedirs(save_dir, exist_ok=True)&#10;    timestamp = datetime.datetime.now().strftime(&quot;%Y-%m-%d_%H-%M&quot;)&#10;    save_path = os.path.join(save_dir, f&quot;carnahan_starling_maxwell_{timestamp}.png&quot;)&#10;    plt.savefig(save_path, dpi=200)&#10;    print(f&quot;Figure saved to {save_path}&quot;)&#10;&#10;    print(&quot;\nCalculation completed successfully!&quot;)&#10;" />
              <option name="updatedContent" value="import os&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;from scipy.optimize import brentq&#10;import pandas as pd&#10;&#10;# Maxwell construction for Carnahan-Starling EOS&#10;rho_c = 3.5&#10;p_c = 0.001&#10;Tr = 0.5&#10;&#10;# Calculate EOS parameters&#10;b_eos = 0.5218 / rho_c&#10;a_eos = ((b_eos ** 2) * p_c) / ((0.3773 ** 2) * 0.4963)&#10;R_eos = 1.0&#10;Tc = (0.3773 * a_eos) / (b_eos * R_eos)&#10;T_eos = Tr * Tc&#10;&#10;&#10;def pressure_function(x):&#10;    &quot;&quot;&quot;Calculate pressure using Carnahan-Starling EOS&quot;&quot;&quot;&#10;    return (R_eos * T_eos * (1 / x) *&#10;            ((1 + (b_eos / (x * 4)) + ((b_eos / (x * 4)) ** 2) - ((b_eos / (x * 4)) ** 3)) /&#10;             ((1 - (b_eos / (x * 4))) ** 3)) - a_eos * (1 / (x ** 2)))&#10;&#10;&#10;def pressure_derivative(x):&#10;    &quot;&quot;&quot;Calculate derivative of pressure with respect to volume&quot;&quot;&quot;&#10;    return (R_eos * T_eos * ((b_eos * (1 / x)) ** 4 - 16 * ((b_eos * (1 / x)) ** 3) +&#10;                             64 * ((b_eos * (1 / x)) ** 2) + 256 * b_eos * (1 / x) + 256) /&#10;            ((4 - b_eos * (1 / x)) ** 4) - 2 * a_eos * (1 / x))&#10;&#10;&#10;def find_extrema(a_int, b_int):&#10;    &quot;&quot;&quot;Find the maximum and minimum points of the pressure function.&#10;&#10;    This part of the code detects sign changes in the derivative of the pressure function&#10;    over a range of test points. When a sign change is found between two consecutive points,&#10;    it uses Brent's method (brentq) to accurately find the root (where the derivative crosses zero),&#10;    which corresponds to an extremum (maximum or minimum) of the pressure function.&#10;    All found extrema are collected and returned in the extrema list. This is useful for&#10;    identifying phase transition points in the Maxwell construction.&#10;    &quot;&quot;&quot;&#10;&#10;    def derivative_zero(x):&#10;        return pressure_derivative(x)&#10;&#10;    extrema = []&#10;&#10;    # Sample points to find sign changes&#10;    test_points = np.linspace(a_int, b_int, 1000)&#10;    derivative_values = [pressure_derivative(x) for x in test_points]&#10;&#10;    for i in range(len(test_points) - 1):&#10;        if derivative_values[i] * derivative_values[i + 1] &lt; 0:&#10;            try:&#10;                root = brentq(derivative_zero, test_points[i], test_points[i + 1])&#10;                extrema.append(root)&#10;            except:&#10;                continue&#10;&#10;    return extrema&#10;&#10;&#10;def riemann_integration(a, b, n, f):&#10;    &quot;&quot;&quot;Riemann integration approximation&quot;&quot;&quot;&#10;    delta = (b - a) / n&#10;    xs = np.linspace(a, b - delta, n)&#10;    fx = np.array([f(x) for x in xs])&#10;    integral = np.sum(fx) * delta&#10;    return integral&#10;&#10;&#10;def maxwell_construction(max_min, a_int, b_int, max_iterations=40, tolerance=1e-7):&#10;    &quot;&quot;&quot;&#10;    Perform Maxwell construction to find coexistence densities&#10;    &quot;&quot;&quot;&#10;    if len(max_min) &lt; 2:&#10;        print(&quot;Insufficient extrema for Maxwell construction&quot;)&#10;        return None, None, None, None, None&#10;&#10;    guess = 0.1&#10;&#10;    # Initial guesses for the coexistence points&#10;    a_ = max_min[0] + guess * (max_min[1] - max_min[0])&#10;    b = max_min[1] + guess * (max_min[0] - max_min[1])&#10;&#10;    g = (a_ + b) / 2&#10;&#10;    # Check if Maxwell construction is feasible&#10;    p_at_extrema = [pressure_function(x) for x in max_min]&#10;    print(f&quot;Pressures at extrema: {p_at_extrema}&quot;)&#10;&#10;    # If pressure doesn't change sign significantly, Maxwell construction may not be meaningful&#10;    if all(p &gt;= 0 for p in p_at_extrema) and (max(p_at_extrema) - min(p_at_extrema)) &lt; 1e-6:&#10;        print(&quot;Pressure variation too small for meaningful Maxwell construction&quot;)&#10;        # Return approximate coexistence points&#10;        return (max_min[0] * 0.9, max_min[1] * 1.1), 0, 0, max_min[0], max_min[1]&#10;&#10;    # Handle negative pressure case&#10;    if pressure_function(max_min[0]) &lt; 0:&#10;        try:&#10;            zero_pressure = brentq(pressure_function, max_min[0], max_min[1])&#10;            a_ = zero_pressure * (1 + guess)&#10;        except:&#10;            pass&#10;&#10;    print(f&quot;Initial guesses: a = {a_}, b = {b}&quot;)&#10;    print(f&quot;Pressure at a = {pressure_function(a_)}&quot;)&#10;&#10;    # Variables to track integration results&#10;    integd_, integc_ = 0, 0&#10;&#10;    for iteration in range(max_iterations):&#10;        print(f&quot;Iteration {iteration + 1}&quot;)&#10;&#10;        c, d = pressure_function(a_), pressure_function(b)&#10;&#10;        # Handle negative pressure&#10;        while c &lt; 0:&#10;            g = (a_ + b) / 2&#10;            a_ = g&#10;            c = pressure_function(a_)&#10;&#10;        # Define pressure difference functions&#10;        def pc_function(x):&#10;            return pressure_function(x) - c&#10;&#10;        def pd_function(x):&#10;            return pressure_function(x) - d&#10;&#10;        # Find intersection points with better error handling and interval check&#10;        try:&#10;            x1, x2 = a_int, max_min[0]&#10;            if pc_function(x1) * pc_function(x2) &lt; 0:&#10;                i1 = brentq(pc_function, x1, x2)&#10;            else:&#10;                print(f&quot;Skipping brentq for pc_function in interval [{x1}, {x2}] due to no sign change.&quot;)&#10;                i1 = x1  # fallback or skip&#10;&#10;            x1, x2 = max_min[1], b_int&#10;            if pc_function(x1) * pc_function(x2) &lt; 0:&#10;                i3 = brentq(pc_function, x1, x2)&#10;            else:&#10;                print(f&quot;Skipping brentq for pc_function in interval [{x1}, {x2}] due to no sign change.&quot;)&#10;                i3 = x2  # fallback or skip&#10;&#10;            integc_ = riemann_integration(i1, i3, 100000, pc_function)&#10;            print(f&quot;Integral c: {integc_}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Could not find intersection for pressure c: {e}&quot;)&#10;            integc_ = 0&#10;&#10;        try:&#10;            x1, x2 = a_int, max_min[0]&#10;            if pd_function(x1) * pd_function(x2) &lt; 0:&#10;                j1 = brentq(pd_function, x1, x2)&#10;            else:&#10;                print(f&quot;Skipping brentq for pd_function in interval [{x1}, {x2}] due to no sign change.&quot;)&#10;                j1 = x1&#10;&#10;            x1, x2 = max_min[1], b_int&#10;            if pd_function(x1) * pd_function(x2) &lt; 0:&#10;                j3 = brentq(pd_function, x1, x2)&#10;            else:&#10;                print(f&quot;Skipping brentq for pd_function in interval [{x1}, {x2}] due to no sign change.&quot;)&#10;                j3 = x2&#10;&#10;            integd_ = riemann_integration(j1, j3, 100000, pd_function)&#10;            print(f&quot;Integral d: {integd_}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Could not find intersection for pressure d: {e}&quot;)&#10;            integd_ = 0&#10;&#10;        # Bisection step&#10;        g = (a_ + b) / 2&#10;        e = pressure_function(g)&#10;&#10;        def pe_function(x):&#10;            return pressure_function(x) - e&#10;&#10;        try:&#10;            x1, x2 = a_int, max_min[0]&#10;            if pe_function(x1) * pe_function(x2) &lt; 0:&#10;                m1 = brentq(pe_function, x1, x2)&#10;            else:&#10;                print(f&quot;Skipping brentq for pe_function in interval [{x1}, {x2}] due to no sign change.&quot;)&#10;                m1 = x1&#10;&#10;            x1, x2 = max_min[1], b_int&#10;            if pe_function(x1) * pe_function(x2) &lt; 0:&#10;                m3 = brentq(pe_function, x1, x2)&#10;            else:&#10;                print(f&quot;Skipping brentq for pe_function in interval [{x1}, {x2}] due to no sign change.&quot;)&#10;                m3 = x2&#10;&#10;            intege = riemann_integration(m1, m3, 100000, pe_function)&#10;&#10;            # Update based on integral sign&#10;            if intege &gt; 0:&#10;                a_ = g&#10;            else:&#10;                b = g&#10;&#10;        except Exception as e:&#10;            print(f&quot;Could not find intersection for pressure e: {e}&quot;)&#10;            break&#10;&#10;        # Check convergence&#10;        if abs(intege) &lt; tolerance:&#10;            print(f&quot;Converged after {iteration + 1} iterations&quot;)&#10;            break&#10;&#10;    # Final calculation - g should be defined by now&#10;    try:&#10;        e = pressure_function(g)&#10;&#10;        def pf_function(x):&#10;            return pressure_function(x) - e&#10;&#10;        x1, x2 = a_int, max_min[0]&#10;        if pf_function(x1) * pf_function(x2) &lt; 0:&#10;            k1 = brentq(pf_function, x1, x2)&#10;        else:&#10;            print(f&quot;Skipping brentq for pf_function in interval [{x1}, {x2}] due to no sign change.&quot;)&#10;            k1 = x1&#10;&#10;        x1, x2 = max_min[1], b_int&#10;        if pf_function(x1) * pf_function(x2) &lt; 0:&#10;            k3 = brentq(pf_function, x1, x2)&#10;        else:&#10;            print(f&quot;Skipping brentq for pf_function in interval [{x1}, {x2}] due to no sign change.&quot;)&#10;            k3 = x2&#10;&#10;        k = (k1, k3)&#10;        print(f&quot;Final coexistence points: {k}&quot;)&#10;&#10;        return k, integd_, integc_, a_, b&#10;    except Exception as e:&#10;        print(f&quot;Could not find final intersection points: {e}&quot;)&#10;        return (max_min[0], max_min[1]), integd_, integc_, a_, b&#10;&#10;&#10;# Main execution&#10;if __name__ == &quot;__main__&quot;:&#10;    # Define integration bounds&#10;    a_int, b_int = 0.09, 50&#10;&#10;    # Generate volume array and calculate pressure and derivative&#10;    rho_w = np.arange(a_int, b_int, 0.01)&#10;    p_bulk = np.array([pressure_function(rho) for rho in rho_w])&#10;    p_dash_bulk = np.array([pressure_derivative(rho) for rho in rho_w])&#10;&#10;    # Find extrema and perform Maxwell construction&#10;    max_min = find_extrema(a_int, b_int)&#10;    print(f&quot;Extrema found at: {max_min}&quot;)&#10;&#10;    k = None&#10;    if len(max_min) &gt;= 2:&#10;        k, integd, integc, a, b = maxwell_construction(max_min, a_int, b_int)&#10;&#10;        if k is not None:&#10;            maxwell_pressure = pressure_function((k[0] + k[1]) / 2)&#10;            print(f&quot;Maxwell construction coexistence pressure: {maxwell_pressure}&quot;)&#10;            print(f&quot;Coexistence volumes: {k[0]:.6f}, {k[1]:.6f}&quot;)&#10;            print(f&quot;Coexistence denisties: {1 / k[0]:.6f}, {1 / k[1]:.6f}&quot;)&#10;    else:&#10;        print(&quot;Could not find sufficient extrema for Maxwell construction&quot;)&#10;&#10;    # Create and save results&#10;    results_df = pd.DataFrame({&#10;        'Volume': rho_w,&#10;        'Pressure': p_bulk,&#10;        'Pressure_Derivative': p_dash_bulk&#10;    })&#10;&#10;    results_df.to_csv('carnahan_starling_results.csv', index=False)&#10;    print(&quot;Results saved to carnahan_starling_results.csv&quot;)&#10;&#10;    # Plot results&#10;    plt.figure(figsize=(10, 6))&#10;    plt.plot(rho_w, p_bulk, label='Carnahan-Starling EOS', linewidth=2)&#10;&#10;    if k is not None:&#10;        maxwell_pressure = pressure_function((k[0] + k[1]) / 2)&#10;        plt.axhline(y=maxwell_pressure, color='red', linestyle='--',&#10;                    label=f'Maxwell Construction (P = {maxwell_pressure:.6f})')&#10;        plt.axvline(x=k[0], color='green', linestyle=':', alpha=0.7,&#10;                    label=f'Liquid volume = {k[0]:.3f}')&#10;        plt.axvline(x=k[1], color='blue', linestyle=':', alpha=0.7,&#10;                    label=f'Vapor volume = {k[1]:.3f}')&#10;&#10;    plt.xlabel('Volume, V')&#10;    plt.ylabel('Pressure, P')&#10;    plt.title('Carnahan-Starling EOS with Maxwell Construction')&#10;    plt.legend()&#10;    plt.grid(True, alpha=0.3)&#10;    plt.xlim(0, 10)  # Focus on relevant range&#10;&#10;    # Save the plot to the specified directory with a timestamp to avoid overwriting&#10;    import datetime&#10;    save_dir = &quot;/Users/sbszkudlarek/PycharmProjects/WBLBM/example/tests/maxwell_reconstruction&quot;&#10;    os.makedirs(save_dir, exist_ok=True)&#10;    timestamp = datetime.datetime.now().strftime(&quot;%Y-%m-%d_%H-%M&quot;)&#10;    save_path = os.path.join(save_dir, f&quot;carnahan_starling_maxwell_{timestamp}.png&quot;)&#10;    plt.savefig(save_path, dpi=200)&#10;    print(f&quot;Figure saved to {save_path}&quot;)&#10;&#10;    print(&quot;\nCalculation completed successfully!&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>