<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/wblbm/operators/differential/gradient.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/differential/gradient.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.wetting.wetting_util import (&#10;    determine_padding_modes,&#10;    has_wetting_bc,&#10;    apply_wetting_to_all_edges,&#10;)&#10;&#10;&#10;class Gradient:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the gradient of a field using the LBM stencil,&#10;    supporting asymmetric per-side padding.&#10;&#10;    The implementation of the gradient operator is based on https://doi.org/10.1063/5.0072221&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, lattice: Lattice, bc_config: dict = None):&#10;        self.w = lattice.w&#10;        self.c = lattice.c&#10;        self.bc_config = bc_config&#10;        self.pad_mode = determine_padding_modes(bc_config)&#10;        # Only extract wetting parameters if wetting BC is present&#10;        self.wetting_params = None&#10;        if has_wetting_bc(bc_config):&#10;            self.wetting_params = bc_config.get('wetting_params')&#10;            if self.wetting_params is None:&#10;                raise ValueError(&quot;Wetting boundary condition specified but 'wetting_params' not found in bc_config&quot;)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(self, grid, pad_mode: list = None):&#10;        &quot;&quot;&quot;&#10;        Calculate the gradient using the provided stencil and per-side boundary modes.&#10;&#10;        Args:&#10;            grid (jnp.ndarray): Input field, shape (nx, ny, 1, 1)&#10;            pad_mode (list, optional): List of padding modes for each pad step&#10;&#10;        Returns:&#10;            jnp.ndarray: Gradient field, shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        if self.wetting_params is not None:  # Only use wetting if params are available&#10;            return self._gradient_wetting(grid, pad_mode)&#10;        else:&#10;            return self._gradient_standard(grid, pad_mode)&#10;&#10;    def _gradient_standard(self, grid, pad_mode):&#10;        &quot;&quot;&quot;Standard gradient calculation.&quot;&quot;&quot;&#10;        # Use provided pad_mode or fall back to self.pad_mode&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.pad_mode&#10;&#10;        # Extract 2D data from 4D input&#10;        if grid.ndim == 4:&#10;            grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        else:&#10;            grid_2d = grid&#10;&#10;        w = self.w&#10;        c = self.c&#10;&#10;        grad_ = jnp.zeros((2, grid_2d.shape[0], grid_2d.shape[1]))&#10;&#10;        # Apply asymmetric per-side padding (same convention/order as Laplacian)&#10;        grid_padded___ = jnp.pad(grid_2d, pad_width=((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded__ = jnp.pad(grid_padded___, pad_width=((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded_ = jnp.pad(grid_padded__, pad_width=((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded_, pad_width=((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Side nodes&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;&#10;        # Corner nodes&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        grad_ = grad_.at[0, :, :].set(&#10;            3&#10;            * (&#10;                    w[1] * c[0, 1] * grid_ipos1_j0&#10;                    + w[3] * c[0, 3] * grid_ineg1_j0&#10;                    + w[5] * c[0, 5] * grid_ipos1_jpos1&#10;                    + w[6] * c[0, 6] * grid_ineg1_jpos1&#10;                    + w[7] * c[0, 7] * grid_ineg1_jneg1&#10;                    + w[8] * c[0, 8] * grid_ipos1_jneg1&#10;            )&#10;        )&#10;&#10;        grad_ = grad_.at[1, :, :].set(&#10;            3&#10;            * (&#10;                    w[2] * c[1, 2] * grid_i0_jpos1&#10;                    + w[4] * c[1, 4] * grid_i0_jneg1&#10;                    + w[5] * c[1, 5] * grid_ipos1_jpos1&#10;                    + w[6] * c[1, 6] * grid_ineg1_jpos1&#10;                    + w[7] * c[1, 7] * grid_ineg1_jneg1&#10;                    + w[8] * c[1, 8] * grid_ipos1_jneg1&#10;            )&#10;        )&#10;&#10;        # Convert to 4D format: (nx, ny, 1, 2)&#10;        grad_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 2))&#10;        grad_4d = grad_4d.at[:, :, 0, 0].set(grad_[0, :, :])&#10;        grad_4d = grad_4d.at[:, :, 0, 1].set(grad_[1, :, :])&#10;&#10;        return grad_4d&#10;&#10;    def _gradient_wetting(self, grid, pad_mode):&#10;        rho_l = self.wetting_params['rho_l']&#10;        rho_v = self.wetting_params['rho_v']&#10;        phi_left = self.wetting_params['phi_left']&#10;        phi_right = self.wetting_params['phi_right']&#10;        d_rho_left = self.wetting_params['d_rho_left']&#10;        d_rho_right = self.wetting_params['d_rho_right']&#10;        width = self.wetting_params['width']&#10;        weight = self.w&#10;        c = self.c&#10;&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.pad_mode&#10;        if grid.ndim == 4:&#10;            grid2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid2d = grid&#10;&#10;        grid_padded = jnp.pad(grid2d, ((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded, ((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Apply wetting to any relevant edge&#10;        grid_padded = apply_wetting_to_all_edges(&#10;            self, grid_padded, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width&#10;        )&#10;&#10;        # STANDARD GRADIENT STENCIL&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        grad0 = (3 * (&#10;                weight[1] * c[0, 1] * grid_ipos1_j0 +&#10;                weight[3] * c[0, 3] * grid_ineg1_j0 +&#10;                weight[5] * c[0, 5] * grid_ipos1_jpos1 +&#10;                weight[6] * c[0, 6] * grid_ineg1_jpos1 +&#10;                weight[7] * c[0, 7] * grid_ineg1_jneg1 +&#10;                weight[8] * c[0, 8] * grid_ipos1_jneg1&#10;        ))&#10;&#10;        grad1 = (3 * (&#10;                weight[2] * c[1, 2] * grid_i0_jpos1 +&#10;                weight[4] * c[1, 4] * grid_i0_jneg1 +&#10;                weight[5] * c[1, 5] * grid_ipos1_jpos1 +&#10;                weight[6] * c[1, 6] * grid_ineg1_jpos1 +&#10;                weight[7] * c[1, 7] * grid_ineg1_jneg1 +&#10;                weight[8] * c[1, 8] * grid_ipos1_jneg1&#10;        ))&#10;&#10;        grad4d = jnp.zeros(grad0.shape + (1, 2))&#10;        grad4d = grad4d.at[..., 0, 0].set(grad0)&#10;        grad4d = grad4d.at[..., 0, 1].set(grad1)&#10;        return grad4d&#10;&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.wetting.wetting_util import (&#10;    determine_padding_modes,&#10;    has_wetting_bc,&#10;    apply_wetting_to_all_edges,&#10;)&#10;&#10;&#10;class Gradient:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the gradient of a field using the LBM stencil,&#10;    supporting asymmetric per-side padding.&#10;&#10;    The implementation of the gradient operator is based on https://doi.org/10.1063/5.0072221&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, lattice: Lattice, bc_config: dict = None):&#10;        self.w = lattice.w&#10;        self.c = lattice.c&#10;        self.bc_config = bc_config&#10;        self.pad_mode = determine_padding_modes(bc_config)&#10;        # Only extract wetting parameters if wetting BC is present&#10;        self.wetting_params = None&#10;        if has_wetting_bc(bc_config):&#10;            self.wetting_params = bc_config.get('wetting_params')&#10;            if self.wetting_params is None:&#10;                raise ValueError(&quot;Wetting boundary condition specified but 'wetting_params' not found in bc_config&quot;)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(self, grid, pad_mode: list = None):&#10;        &quot;&quot;&quot;&#10;        Calculate the gradient using the provided stencil and per-side boundary modes.&#10;&#10;        Args:&#10;            grid (jnp.ndarray): Input field, shape (nx, ny, 1, 1)&#10;            pad_mode (list, optional): List of padding modes for each pad step&#10;&#10;        Returns:&#10;            jnp.ndarray: Gradient field, shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        if self.wetting_params is not None:  # Only use wetting if params are available&#10;            return self._gradient_wetting(grid, pad_mode)&#10;        else:&#10;            return self._gradient_standard(grid, pad_mode)&#10;&#10;    def _gradient_standard(self, grid, pad_mode):&#10;        &quot;&quot;&quot;Standard gradient calculation.&quot;&quot;&quot;&#10;        # Use provided pad_mode or fall back to self.pad_mode&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.pad_mode&#10;&#10;        # Extract 2D data from 4D input&#10;        if grid.ndim == 4:&#10;            grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        else:&#10;            grid_2d = grid&#10;&#10;        w = self.w&#10;        c = self.c&#10;&#10;        grad_ = jnp.zeros((2, grid_2d.shape[0], grid_2d.shape[1]))&#10;&#10;        # Apply asymmetric per-side padding (same convention/order as Laplacian)&#10;        grid_padded___ = jnp.pad(grid_2d, pad_width=((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded__ = jnp.pad(grid_padded___, pad_width=((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded_ = jnp.pad(grid_padded__, pad_width=((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded_, pad_width=((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Side nodes&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;&#10;        # Corner nodes&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        grad_ = grad_.at[0, :, :].set(&#10;            3&#10;            * (&#10;                    w[1] * c[0, 1] * grid_ipos1_j0&#10;                    + w[3] * c[0, 3] * grid_ineg1_j0&#10;                    + w[5] * c[0, 5] * grid_ipos1_jpos1&#10;                    + w[6] * c[0, 6] * grid_ineg1_jpos1&#10;                    + w[7] * c[0, 7] * grid_ineg1_jneg1&#10;                    + w[8] * c[0, 8] * grid_ipos1_jneg1&#10;            )&#10;        )&#10;&#10;        grad_ = grad_.at[1, :, :].set(&#10;            3&#10;            * (&#10;                    w[2] * c[1, 2] * grid_i0_jpos1&#10;                    + w[4] * c[1, 4] * grid_i0_jneg1&#10;                    + w[5] * c[1, 5] * grid_ipos1_jpos1&#10;                    + w[6] * c[1, 6] * grid_ineg1_jpos1&#10;                    + w[7] * c[1, 7] * grid_ineg1_jneg1&#10;                    + w[8] * c[1, 8] * grid_ipos1_jneg1&#10;            )&#10;        )&#10;&#10;        # Convert to 4D format: (nx, ny, 1, 2)&#10;        grad_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 2))&#10;        grad_4d = grad_4d.at[:, :, 0, 0].set(grad_[0, :, :])&#10;        grad_4d = grad_4d.at[:, :, 0, 1].set(grad_[1, :, :])&#10;&#10;        return grad_4d&#10;&#10;    def _gradient_wetting(self, grid, pad_mode):&#10;        rho_l = self.wetting_params['rho_l']&#10;        rho_v = self.wetting_params['rho_v']&#10;        phi_left = self.wetting_params['phi_left']&#10;        phi_right = self.wetting_params['phi_right']&#10;        d_rho_left = self.wetting_params['d_rho_left']&#10;        d_rho_right = self.wetting_params['d_rho_right']&#10;        width = self.wetting_params['width']&#10;        weight = self.w&#10;        c = self.c&#10;&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.pad_mode&#10;        if grid.ndim == 4:&#10;            grid2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid2d = grid&#10;&#10;        grid_padded = jnp.pad(grid2d, ((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded, ((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Apply wetting to any relevant edge&#10;        grid_padded = apply_wetting_to_all_edges(&#10;            self, grid_padded, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width&#10;        )&#10;&#10;        # STANDARD GRADIENT STENCIL&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        grad0 = (3 * (&#10;                weight[1] * c[0, 1] * grid_ipos1_j0 +&#10;                weight[3] * c[0, 3] * grid_ineg1_j0 +&#10;                weight[5] * c[0, 5] * grid_ipos1_jpos1 +&#10;                weight[6] * c[0, 6] * grid_ineg1_jpos1 +&#10;                weight[7] * c[0, 7] * grid_ineg1_jneg1 +&#10;                weight[8] * c[0, 8] * grid_ipos1_jneg1&#10;        ))&#10;&#10;        grad1 = (3 * (&#10;                weight[2] * c[1, 2] * grid_i0_jpos1 +&#10;                weight[4] * c[1, 4] * grid_i0_jneg1 +&#10;                weight[5] * c[1, 5] * grid_ipos1_jpos1 +&#10;                weight[6] * c[1, 6] * grid_ineg1_jpos1 +&#10;                weight[7] * c[1, 7] * grid_ineg1_jneg1 +&#10;                weight[8] * c[1, 8] * grid_ipos1_jneg1&#10;        ))&#10;&#10;        grad4d = jnp.zeros(grad0.shape + (1, 2))&#10;        grad4d = grad4d.at[..., 0, 0].set(grad0)&#10;        grad4d = grad4d.at[..., 0, 1].set(grad1)&#10;        return grad4d&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/differential/laplacian.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/differential/laplacian.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.wetting.wetting_util import (&#10;    determine_padding_modes,&#10;    has_wetting_bc,&#10;    apply_wetting_to_all_edges,&#10;)&#10;&#10;&#10;class Laplacian:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the Laplacian of a 2D grid using the LBM stencil.&#10;&#10;    The implementation of the laplacian is based on https://doi.org/10.1063/5.0072221&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, lattice: Lattice, bc_config: dict = None):&#10;        self.w = lattice.w&#10;        self.bc_config = bc_config&#10;        self.padmode = determine_padding_modes(bc_config)&#10;        # Only extract wetting parameters if wetting BC is present&#10;        self.wetting_params = None&#10;        if has_wetting_bc(bc_config):&#10;            self.wetting_params = bc_config.get('wetting_params')&#10;            if self.wetting_params is None:&#10;                raise ValueError(&quot;Wetting boundary condition specified but 'wetting_params' not found in bcconfig&quot;)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(self, grid, padmode: list = None):&#10;        &quot;&quot;&quot;&#10;        Calculate the Laplacian of a 2D grid.&#10;&#10;        Args:&#10;            grid (jnp.ndarray): Input grid, shape (nx, ny, 1, 1)&#10;            padmode (list, optional): List of padding modes for each pad step&#10;&#10;        Returns:&#10;            jnp.ndarray: Laplacian of the input grid, shape (nx, ny, 1, 1)&#10;        &quot;&quot;&quot;&#10;        if self.wetting_params is not None:  # Only use wetting if params are available&#10;            return self._laplacian_wetting(grid, padmode)&#10;        else:&#10;            return self._laplacian_standard(grid, padmode)&#10;&#10;    def _laplacian_standard(self, grid, pad_mode):&#10;        &quot;&quot;&quot;Standard laplacian calculation.&quot;&quot;&quot;&#10;        # Use provided pad_mode or fall back to self.pad_mode&#10;        effective_pad_mode = pad_mode if pad_mode is not None else self.padmode&#10;&#10;        # Extract 2D data from 4D input&#10;        if grid.ndim == 4:&#10;            grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        else:&#10;            grid_2d = grid&#10;&#10;        w = self.w&#10;&#10;        laplacian_2d = jnp.zeros_like(grid_2d)&#10;        grid_padded___ = jnp.pad(grid_2d, pad_width=((0, 0), (0, 1)), mode=effective_pad_mode[0])&#10;        grid_padded__ = jnp.pad(grid_padded___, pad_width=((0, 0), (1, 0)), mode=effective_pad_mode[1])&#10;        grid_padded_ = jnp.pad(grid_padded__, pad_width=((0, 1), (0, 0)), mode=effective_pad_mode[2])&#10;        grid_padded = jnp.pad(grid_padded_, pad_width=((1, 0), (0, 0)), mode=effective_pad_mode[3])&#10;&#10;        # Side nodes&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;&#10;        # Corner nodes&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;&#10;        # Central node&#10;        grid_i0_j0 = grid_padded[1:-1, 1:-1]&#10;&#10;        laplacian_2d = laplacian_2d.at[:, :].set(&#10;            6&#10;            * (&#10;                    w[1] * (grid_ipos1_j0 - grid_i0_j0)&#10;                    + w[2] * (grid_i0_jpos1 - grid_i0_j0)&#10;                    + w[3] * (grid_ineg1_j0 - grid_i0_j0)&#10;                    + w[4] * (grid_i0_jneg1 - grid_i0_j0)&#10;                    + w[5] * (grid_ipos1_jpos1 - grid_i0_j0)&#10;                    + w[6] * (grid_ineg1_jpos1 - grid_i0_j0)&#10;                    + w[7] * (grid_ineg1_jneg1 - grid_i0_j0)&#10;                    + w[8] * (grid_ipos1_jneg1 - grid_i0_j0)&#10;            )&#10;        )&#10;&#10;        # Convert to 4D format: (nx, ny, 1, 1)&#10;        laplacian_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 1))&#10;        laplacian_4d = laplacian_4d.at[:, :, 0, 0].set(laplacian_2d)&#10;&#10;        return laplacian_4d&#10;&#10;    def _laplacian_wetting(self, grid, padmode):&#10;        &quot;&quot;&quot;Custom wetting laplacian implementation.&quot;&quot;&quot;&#10;        RHO_L = self.wetting_params['rho_l']&#10;        RHO_V = self.wetting_params['rho_v']&#10;        phi_left = self.wetting_params['phi_left']&#10;        phi_right = self.wetting_params['phi_right']&#10;        d_rho_left = self.wetting_params['d_rho_left']&#10;        d_rho_right = self.wetting_params['d_rho_right']&#10;        W = self.wetting_params['W']&#10;        w = self.w&#10;&#10;        effective_padmode = padmode if padmode is not None else self.padmode&#10;        if grid.ndim == 4:&#10;            grid2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid2d = grid&#10;&#10;        # Pad as usual&#10;        grid_padded = jnp.pad(grid2d, ((0, 0), (0, 1)), mode=effective_padmode[0])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 0), (1, 0)), mode=effective_padmode[1])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 1), (0, 0)), mode=effective_padmode[2])&#10;        grid_padded = jnp.pad(grid_padded, ((1, 0), (0, 0)), mode=effective_padmode[3])&#10;&#10;        # Apply wetting to any relevant edge&#10;        grid_padded = apply_wetting_to_all_edges(self, grid_padded,&#10;                                                 RHO_L, RHO_V, phi_left, phi_right, d_rho_left, d_rho_right, W)&#10;&#10;        # STANDARD LAPLACIAN STENCIL&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;        grid_i0_j0 = grid_padded[1:-1, 1:-1]&#10;&#10;        laplacian2d = 6 * (&#10;                w[1] * (grid_ipos1_j0 - grid_i0_j0) +&#10;                w[2] * (grid_i0_jpos1 - grid_i0_j0) +&#10;                w[3] * (grid_ineg1_j0 - grid_i0_j0) +&#10;                w[4] * (grid_i0_jneg1 - grid_i0_j0) +&#10;                w[5] * (grid_ipos1_jpos1 - grid_i0_j0) +&#10;                w[6] * (grid_ineg1_jpos1 - grid_i0_j0) +&#10;                w[7] * (grid_ineg1_jneg1 - grid_i0_j0) +&#10;                w[8] * (grid_ipos1_jneg1 - grid_i0_j0)&#10;        )&#10;&#10;        laplacian4d = jnp.zeros(laplacian2d.shape + (1, 1))&#10;        laplacian4d = laplacian4d.at[..., 0, 0].set(laplacian2d)&#10;        return laplacian4d" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.wetting.wetting_util import (&#10;    determine_padding_modes,&#10;    has_wetting_bc,&#10;    apply_wetting_to_all_edges,&#10;)&#10;&#10;&#10;class Laplacian:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the Laplacian of a 2D grid using the LBM stencil.&#10;&#10;    The implementation of the laplacian is based on https://doi.org/10.1063/5.0072221&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, lattice: Lattice, bc_config: dict = None):&#10;        self.w = lattice.w&#10;        self.bc_config = bc_config&#10;        self.padmode = determine_padding_modes(bc_config)&#10;        # Only extract wetting parameters if wetting BC is present&#10;        self.wetting_params = None&#10;        if has_wetting_bc(bc_config):&#10;            self.wetting_params = bc_config.get('wetting_params')&#10;            if self.wetting_params is None:&#10;                raise ValueError(&quot;Wetting boundary condition specified but 'wetting_params' not found in bcconfig&quot;)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(self, grid, padmode: list = None):&#10;        &quot;&quot;&quot;&#10;        Calculate the Laplacian of a 2D grid.&#10;&#10;        Args:&#10;            grid (jnp.ndarray): Input grid, shape (nx, ny, 1, 1)&#10;            padmode (list, optional): List of padding modes for each pad step&#10;&#10;        Returns:&#10;            jnp.ndarray: Laplacian of the input grid, shape (nx, ny, 1, 1)&#10;        &quot;&quot;&quot;&#10;        if self.wetting_params is not None:  # Only use wetting if params are available&#10;            return self._laplacian_wetting(grid, padmode)&#10;        else:&#10;            return self._laplacian_standard(grid, padmode)&#10;&#10;    def _laplacian_standard(self, grid, padmode):&#10;        &quot;&quot;&quot;Standard laplacian calculation.&quot;&quot;&quot;&#10;        effective_padmode = padmode if padmode is not None else self.padmode&#10;&#10;        if grid.ndim == 4:&#10;            grid_2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid_2d = grid&#10;&#10;        w = self.w&#10;&#10;        laplacian_2d = jnp.zeros_like(grid_2d)&#10;        grid_padded___ = jnp.pad(grid_2d, pad_width=((0, 0), (0, 1)), mode=effective_padmode[0])&#10;        grid_padded__ = jnp.pad(grid_padded___, pad_width=((0, 0), (1, 0)), mode=effective_padmode[1])&#10;        grid_padded_ = jnp.pad(grid_padded__, pad_width=((0, 1), (0, 0)), mode=effective_padmode[2])&#10;        grid_padded = jnp.pad(grid_padded_, pad_width=((1, 0), (0, 0)), mode=effective_padmode[3])&#10;&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;        grid_i0_j0 = grid_padded[1:-1, 1:-1]&#10;&#10;        laplacian_2d = laplacian_2d.at[:, :].set(&#10;            6&#10;            * (&#10;                w[1] * (grid_ipos1_j0 - grid_i0_j0)&#10;                + w[2] * (grid_i0_jpos1 - grid_i0_j0)&#10;                + w[3] * (grid_ineg1_j0 - grid_i0_j0)&#10;                + w[4] * (grid_i0_jneg1 - grid_i0_j0)&#10;                + w[5] * (grid_ipos1_jpos1 - grid_i0_j0)&#10;                + w[6] * (grid_ineg1_jpos1 - grid_i0_j0)&#10;                + w[7] * (grid_ineg1_jneg1 - grid_i0_j0)&#10;                + w[8] * (grid_ipos1_jneg1 - grid_i0_j0)&#10;            )&#10;        )&#10;&#10;        laplacian_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 1))&#10;        laplacian_4d = laplacian_4d.at[:, :, 0, 0].set(laplacian_2d)&#10;&#10;        return laplacian_4d&#10;&#10;    def _laplacian_wetting(self, grid, padmode):&#10;        &quot;&quot;&quot;Custom wetting laplacian implementation.&quot;&quot;&quot;&#10;        RHO_L = self.wetting_params['rho_l']&#10;        RHO_V = self.wetting_params['rho_v']&#10;        phi_left = self.wetting_params['phi_left']&#10;        phi_right = self.wetting_params['phi_right']&#10;        d_rho_left = self.wetting_params['d_rho_left']&#10;        d_rho_right = self.wetting_params['d_rho_right']&#10;        W = self.wetting_params['W']&#10;        w = self.w&#10;&#10;        effective_padmode = padmode if padmode is not None else self.padmode&#10;        if grid.ndim == 4:&#10;            grid2d = grid[:, :, 0, 0]&#10;        else:&#10;            grid2d = grid&#10;&#10;        grid_padded = jnp.pad(grid2d, ((0, 0), (0, 1)), mode=effective_padmode[0])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 0), (1, 0)), mode=effective_padmode[1])&#10;        grid_padded = jnp.pad(grid_padded, ((0, 1), (0, 0)), mode=effective_padmode[2])&#10;        grid_padded = jnp.pad(grid_padded, ((1, 0), (0, 0)), mode=effective_padmode[3])&#10;&#10;        grid_padded = apply_wetting_to_all_edges(self, grid_padded,&#10;            RHO_L, RHO_V, phi_left, phi_right, d_rho_left, d_rho_right, W)&#10;&#10;        grid_ineg1_j0 = grid_padded[:-2, 1:-1]&#10;        grid_ipos1_j0 = grid_padded[2:, 1:-1]&#10;        grid_i0_jneg1 = grid_padded[1:-1, :-2]&#10;        grid_i0_jpos1 = grid_padded[1:-1, 2:]&#10;        grid_ipos1_jpos1 = grid_padded[2:, 2:]&#10;        grid_ineg1_jpos1 = grid_padded[:-2, 2:]&#10;        grid_ineg1_jneg1 = grid_padded[:-2, :-2]&#10;        grid_ipos1_jneg1 = grid_padded[2:, :-2]&#10;        grid_i0_j0 = grid_padded[1:-1, 1:-1]&#10;&#10;        laplacian2d = 6 * (&#10;            w[1] * (grid_ipos1_j0 - grid_i0_j0) +&#10;            w[2] * (grid_i0_jpos1 - grid_i0_j0) +&#10;            w[3] * (grid_ineg1_j0 - grid_i0_j0) +&#10;            w[4] * (grid_i0_jneg1 - grid_i0_j0) +&#10;            w[5] * (grid_ipos1_jpos1 - grid_i0_j0) +&#10;            w[6] * (grid_ineg1_jpos1 - grid_i0_j0) +&#10;            w[7] * (grid_ineg1_jneg1 - grid_i0_j0) +&#10;            w[8] * (grid_ipos1_jneg1 - grid_i0_j0)&#10;        )&#10;&#10;        laplacian4d = jnp.zeros(laplacian2d.shape + (1, 1))&#10;        laplacian4d = laplacian4d.at[..., 0, 0].set(laplacian2d)&#10;        return laplacian4d" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            -(2*self.a_eos)*rho_2d + self.R_eos*self.T_eos*(1 + jnp.log(rho_2d))&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        # Julia formula:&#10;        # -(2*a_eos)*ρw[i,j] + R_eos*T_eos*(1 + log(ρw[i,j])) + ((16*R_eos*T_eos*(b_eos*ρw[i,j] -12))/((-4 + b_eos*ρw[i,j])^3))&#10;        eos_2d = (&#10;            -(2 * self.a_eos) * rho_2d&#10;            + self.R_eos * self.T_eos * (1 + jnp.log(rho_2d))&#10;            + (16 * self.R_eos * self.T_eos * (self.b_eos * rho_2d - 12))&#10;              / jnp.power((-4 + self.b_eos * rho_2d), 3)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/wetting/wetting_util.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/wetting/wetting_util.py" />
              <option name="originalContent" value="import jax.numpy as jnp&#10;&#10;def determine_padding_modes(bc_config):&#10;    if not bc_config:&#10;        return [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;    padmode = [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;    for edge, bc_type in bc_config.items():&#10;        if bc_type in [&quot;symmetry&quot;, &quot;bounce-back&quot;, &quot;wetting&quot;]:&#10;            if edge == &quot;bottom&quot;:&#10;                padmode[0] = &quot;edge&quot;&#10;            elif edge == &quot;right&quot;:&#10;                padmode[1] = &quot;edge&quot;&#10;            elif edge == &quot;top&quot;:&#10;                padmode[2] = &quot;edge&quot;&#10;            elif edge == &quot;left&quot;:&#10;                padmode[3] = &quot;edge&quot;&#10;    return padmode&#10;&#10;def has_wetting_bc(bc_config):&#10;    if not bc_config:&#10;        return False&#10;    return any(bc == &quot;wetting&quot; for key, bc in bc_config.items()&#10;               if key != 'wetting_params' and isinstance(bc, str))&#10;&#10;def apply_wetting_to_all_edges(obj, grid_padded, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width):&#10;    for edge in ['bottom', 'top', 'left', 'right']:&#10;        if obj.bc_config.get(edge) == 'wetting':&#10;            if edge == 'bottom':  # y=0 border&#10;                grid_padded = wetting_1d(grid_padded, axis=1, idx=0,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'top':  # y=-1 border&#10;                grid_padded = wetting_1d(grid_padded, axis=1, idx=-1,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'left':  # x=0 border&#10;                grid_padded = wetting_1d(grid_padded, axis=0, idx=0,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'right':  # x=-1 border&#10;                grid_padded = wetting_1d(grid_padded, axis=0, idx=-1,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;    return grid_padded&#10;&#10;def wetting_1d(arr, axis, idx, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width):&#10;    # axis == 1 for the y-edges&#10;    if axis == 1:&#10;        arr = arr.at[1:-1, idx].set(&#10;            (1 / 3 * arr[1:-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[0:-2, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[2:, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12))&#10;        # Corners&#10;        arr = arr.at[0, idx].set(&#10;            (1 / 3 * arr[0, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[1, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        arr = arr.at[-1, idx].set(&#10;            (1 / 3 * arr[-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[0, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[-2, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        edge_slice = arr[1:-1, idx]&#10;&#10;        mask1 = arr[1:-1, idx] &lt; (0.95 * rho_l + 0.05 * rho_v)&#10;        mask2 = arr[1:-1, idx] &gt; (0.95 * rho_v + 0.05 * rho_l)&#10;    # axis == 0 for the x-edges&#10;    else:&#10;        arr = arr.at[idx, -1:1].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, 1:-1] +&#10;             1 / 12 * arr[idx + 1 if idx == 0 else idx - 1, 0:-2] +&#10;             1 / 12 * arr[idx + 1 if idx == 0 else idx - 1, 2:])&#10;            / (1 / 3 + 1 / 12 + 1 / 12))&#10;        #Corners&#10;        arr = arr.at[idx, 0].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, 0] +&#10;             1 / 12 * arr[idx, -1] +&#10;             1 / 12 * arr[idx, 1]) / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        arr = arr.at[idx, -1].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, -1] +&#10;             1 / 12 * arr[idx, 0] +&#10;             1 / 12 * arr[idx, -2]) / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        edge_slice = arr[idx, 1:-1]&#10;&#10;        mask1 = arr[idx, -1:1] &lt; (0.95 * rho_l + 0.05 * rho_v)&#10;        mask2 = arr[idx, -1:1] &gt; (0.95 * rho_v + 0.05 * rho_l)&#10;&#10;    # Wetting mask logic&#10;    mask_final = mask1 * mask2&#10;&#10;    mask1_int = jnp.array(mask1, dtype=int)&#10;    diff_mask1 = jnp.diff(mask1_int)&#10;&#10;    # Determining the transition index, the [0] is used to extract only the first value&#10;    transition_index_left_mask1 = jnp.where(diff_mask1 == -1, size=1, fill_value=0)[0] + 2 * width&#10;    transition_index_right_mask1 = (jnp.where(diff_mask1 == 1, size=1, fill_value=0)[0]) - (2 * width + 1)&#10;&#10;    # Here the mask_final is split into a left and a right mask to enable the CA of the left and right side to be&#10;    # determined separately, the reason left uses the right mask is that it works as a cover.&#10;    indices = jnp.arange(mask_final.shape[0])&#10;    mask_cover_left = jnp.where(indices &gt;= transition_index_right_mask1[0], False, mask_final)&#10;    mask_cover_right = jnp.where(indices &lt;= transition_index_left_mask1[0], False, mask_final)&#10;&#10;    new_values_left = jnp.minimum(&#10;        jnp.maximum(&#10;            ((phi_left * edge_slice) - d_rho_left),&#10;            (0.95 * rho_v + 0.05 * rho_l)&#10;        ),&#10;        (0.95 * rho_l + 0.05 * rho_v)&#10;    )&#10;&#10;    new_values_right = jnp.minimum(&#10;        jnp.maximum(&#10;            ((phi_right * edge_slice) - d_rho_right),&#10;            (0.95 * rho_v + 0.05 * rho_l)&#10;        ),&#10;        (0.95 * rho_l + 0.05 * rho_v)&#10;    )&#10;    updated_slice = jnp.where(mask_cover_left, new_values_left, edge_slice)&#10;    updated_slice = jnp.where(mask_cover_right, new_values_right, updated_slice)&#10;&#10;    if axis == 1:&#10;        arr = arr.at[1:-1, idx].set(updated_slice)&#10;    else:&#10;        arr = arr.at[idx, 1:-1].set(updated_slice)&#10;    return arr&#10;" />
              <option name="updatedContent" value="import jax.numpy as jnp&#10;&#10;def determine_padding_modes(bc_config):&#10;    if not bc_config:&#10;        return [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;    padmode = [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;    for edge, bc_type in bc_config.items():&#10;        if bc_type in [&quot;symmetry&quot;, &quot;bounce-back&quot;, &quot;wetting&quot;]:&#10;            if edge == &quot;bottom&quot;:&#10;                padmode[0] = &quot;edge&quot;&#10;            elif edge == &quot;right&quot;:&#10;                padmode[1] = &quot;edge&quot;&#10;            elif edge == &quot;top&quot;:&#10;                padmode[2] = &quot;edge&quot;&#10;            elif edge == &quot;left&quot;:&#10;                padmode[3] = &quot;edge&quot;&#10;    return padmode&#10;&#10;def has_wetting_bc(bc_config):&#10;    if not bc_config:&#10;        return False&#10;    return any(bc == &quot;wetting&quot; for key, bc in bc_config.items()&#10;               if key != 'wetting_params' and isinstance(bc, str))&#10;&#10;def apply_wetting_to_all_edges(obj, grid_padded, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width):&#10;    for edge in ['bottom', 'top', 'left', 'right']:&#10;        if obj.bc_config.get(edge) == 'wetting':&#10;            if edge == 'bottom':  # y=0 border&#10;                grid_padded = wetting_1d(grid_padded, axis=1, idx=0,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'top':  # y=-1 border&#10;                grid_padded = wetting_1d(grid_padded, axis=1, idx=-1,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'left':  # x=0 border&#10;                grid_padded = wetting_1d(grid_padded, axis=0, idx=0,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;            elif edge == 'right':  # x=-1 border&#10;                grid_padded = wetting_1d(grid_padded, axis=0, idx=-1,&#10;                                         rho_l=rho_l, rho_v=rho_v, phi_left=phi_left, phi_right=phi_right,&#10;                                         d_rho_left=d_rho_left, d_rho_right=d_rho_right, width=width)&#10;    return grid_padded&#10;&#10;def wetting_1d(arr, axis, idx, rho_l, rho_v, phi_left, phi_right, d_rho_left, d_rho_right, width):&#10;    # axis == 1 for the y-edges&#10;    if axis == 1:&#10;        arr = arr.at[1:-1, idx].set(&#10;            (1 / 3 * arr[1:-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[0:-2, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[2:, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12))&#10;        # Corners&#10;        arr = arr.at[0, idx].set(&#10;            (1 / 3 * arr[0, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[1, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        arr = arr.at[-1, idx].set(&#10;            (1 / 3 * arr[-1, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[0, idx + 1 if idx == 0 else idx - 1] +&#10;             1 / 12 * arr[-2, idx + 1 if idx == 0 else idx - 1])&#10;            / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        edge_slice = arr[1:-1, idx]&#10;&#10;        mask1 = arr[1:-1, idx] &lt; (0.95 * rho_l + 0.05 * rho_v)&#10;        mask2 = arr[1:-1, idx] &gt; (0.95 * rho_v + 0.05 * rho_l)&#10;    # axis == 0 for the x-edges&#10;    else:&#10;        arr = arr.at[idx, -1:1].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, 1:-1] +&#10;             1 / 12 * arr[idx + 1 if idx == 0 else idx - 1, 0:-2] +&#10;             1 / 12 * arr[idx + 1 if idx == 0 else idx - 1, 2:])&#10;            / (1 / 3 + 1 / 12 + 1 / 12))&#10;        #Corners&#10;        arr = arr.at[idx, 0].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, 0] +&#10;             1 / 12 * arr[idx, -1] +&#10;             1 / 12 * arr[idx, 1]) / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        arr = arr.at[idx, -1].set(&#10;            (1 / 3 * arr[idx + 1 if idx == 0 else idx - 1, -1] +&#10;             1 / 12 * arr[idx, 0] +&#10;             1 / 12 * arr[idx, -2]) / (1 / 3 + 1 / 12 + 1 / 12)&#10;        )&#10;        edge_slice = arr[idx, 1:-1]&#10;&#10;        mask1 = arr[idx, -1:1] &lt; (0.95 * rho_l + 0.05 * rho_v)&#10;        mask2 = arr[idx, -1:1] &gt; (0.95 * rho_v + 0.05 * rho_l)&#10;&#10;    # Wetting mask logic&#10;    mask_final = mask1 * mask2&#10;&#10;    mask1_int = jnp.array(mask1, dtype=int)&#10;    diff_mask1 = jnp.diff(mask1_int)&#10;&#10;    # Determining the transition index, the [0] is used to extract only the first value&#10;    transition_index_left_mask1 = jnp.where(diff_mask1 == -1, size=1, fill_value=0)[0] + 2 * width&#10;    transition_index_right_mask1 = (jnp.where(diff_mask1 == 1, size=1, fill_value=0)[0]) - (2 * width + 1)&#10;&#10;    # Here the mask_final is split into a left and a right mask to enable the CA of the left and right side to be&#10;    # determined separately, the reason left uses the right mask is that it works as a cover.&#10;    indices = jnp.arange(mask_final.shape[0])&#10;    mask_cover_left = jnp.where(indices &gt;= transition_index_right_mask1[0], False, mask_final)&#10;    mask_cover_right = jnp.where(indices &lt;= transition_index_left_mask1[0], False, mask_final)&#10;&#10;    new_values_left = jnp.minimum(&#10;        jnp.maximum(&#10;            ((phi_left * edge_slice) - d_rho_left),&#10;            (0.95 * rho_v + 0.05 * rho_l)&#10;        ),&#10;        (0.95 * rho_l + 0.05 * rho_v)&#10;    )&#10;&#10;    new_values_right = jnp.minimum(&#10;        jnp.maximum(&#10;            ((phi_right * edge_slice) - d_rho_right),&#10;            (0.95 * rho_v + 0.05 * rho_l)&#10;        ),&#10;        (0.95 * rho_l + 0.05 * rho_v)&#10;    )&#10;    updated_slice = jnp.where(mask_cover_left, new_values_left, edge_slice)&#10;    updated_slice = jnp.where(mask_cover_right, new_values_right, updated_slice)&#10;&#10;    if axis == 1:&#10;        arr = arr.at[1:-1, idx].set(updated_slice)&#10;    else:&#10;        arr = arr.at[idx, 1:-1].set(updated_slice)&#10;    return arr&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>