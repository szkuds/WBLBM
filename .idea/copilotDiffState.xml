<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/wblbm/operators/collision/source.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/collision/source.py" />
              <option name="originalContent" value="import jax.numpy as jnp&#10;from wblbm.grid.grid import Grid&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.differential.gradient import Gradient&#10;&#10;&#10;class SourceTerm:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the source term for the LBM equation.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, grid: Grid, lattice: Lattice, bc_config: dict = None):&#10;        &quot;&quot;&quot;&#10;        Initialize the source term calculator.&#10;&#10;        Args:&#10;            grid (Grid): Grid object containing simulation domain information&#10;            lattice (Lattice): Lattice object containing lattice properties&#10;            bc_config (dict, optional): Boundary condition configuration&#10;        &quot;&quot;&quot;&#10;        self.nx: int = grid.nx&#10;        self.ny: int = grid.ny&#10;        self.q: int = lattice.q&#10;        self.d: int = lattice.d&#10;        self.w = lattice.w&#10;        self.cx = lattice.c[0]&#10;        self.cy = lattice.c[1]&#10;        self.bc_config = bc_config&#10;        self.pad_mode = self._determine_padding_modes()&#10;        self.gradient = Gradient(lattice, padmode=self.pad_mode)&#10;&#10;    def _determine_padding_modes(self):&#10;        &quot;&quot;&quot;Determine padding modes based on boundary conditions.&quot;&quot;&quot;&#10;        if not self.bc_config:&#10;            return [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;&#10;        pad_mode = [&quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;, &quot;wrap&quot;]&#10;        for edge, bc_type in self.bc_config.items():&#10;            if bc_type in [&quot;symmetry&quot;, &quot;bounce-back&quot;]:&#10;                if edge == &quot;bottom&quot;:&#10;                    pad_mode[0] = &quot;edge&quot;&#10;                elif edge == &quot;right&quot;:&#10;                    pad_mode[1] = &quot;edge&quot;&#10;                elif edge == &quot;top&quot;:&#10;                    pad_mode[2] = &quot;edge&quot;&#10;                elif edge == &quot;left&quot;:&#10;                    pad_mode[3] = &quot;edge&quot;&#10;        return pad_mode&#10;&#10;    def __call__(&#10;        self, rho: jnp.ndarray, u: jnp.ndarray, force: jnp.ndarray&#10;    ) -&gt; jnp.ndarray:&#10;        &quot;&quot;&quot;&#10;        Calculate the source term for the LBM equation.&#10;&#10;        Args:&#10;            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;            u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)&#10;            force (jnp.ndarray): Force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            jnp.ndarray: Source term, shape (nx, ny, q, 1)&#10;        &quot;&quot;&quot;&#10;        nx, ny, q = self.nx, self.ny, self.q&#10;        w = self.w&#10;        c = (self.cx, self.cy)&#10;        d = self.d&#10;        gradient = self.gradient&#10;&#10;        # Extract 2D data from 4D arrays&#10;        u_2d = u[:, :, 0, :]  # Shape: (nx, ny, 2)&#10;        force_2d = force[:, :, 0, :]  # Shape: (nx, ny, 2)&#10;        rho_2d = rho[:, :, 0, 0]  # Shape: (nx, ny)&#10;&#10;        # Calculate gradient of rho&#10;        grad_rho = self.gradient(rho)&#10;        grad_rho_2d = grad_rho[:, :, 0, :]  # Shape: (nx, ny, 2)&#10;&#10;        def source_term(u_2d_, force_2d_, grad_rho_2d_):&#10;            &quot;&quot;&quot;&#10;            Compute the source term for each lattice direction.&#10;&#10;            Args:&#10;                u_2d_ (jnp.ndarray): Velocity field, shape (nx, ny, 2)&#10;                force_2d_ (jnp.ndarray): Force field, shape (nx, ny, 2)&#10;                grad_rho_2d_ (jnp.ndarray): Gradient of density, shape (nx, ny, 2)&#10;&#10;            Returns:&#10;                jnp.ndarray: Source term, shape (nx, ny, q)&#10;            &quot;&quot;&quot;&#10;            cx, cy = c[0], c[1]&#10;            fx, fy = force_2d_[:, :, 0], force_2d_[:, :, 1]&#10;            ux, uy = u_2d_[:, :, 0], u_2d_[:, :, 1]&#10;            grad_rho_x, grad_rho_y = grad_rho_2d_[:, :, 0], grad_rho_2d_[:, :, 1]&#10;&#10;            fx_cor = fx + (grad_rho_x / 3)&#10;            fy_cor = fy + (grad_rho_y / 3)&#10;            source_ = jnp.zeros((nx, ny, q))&#10;&#10;            for i in range(q):&#10;                # Compute the source term for each direction&#10;                source_ = source_.at[:, :, i].set(&#10;                    w[i]&#10;                    * (&#10;                        3 * (cx[i] * fx + cy[i] * fy)&#10;                        + 9&#10;                        * (cx[i] * fx_cor + cy[i] * fy_cor)&#10;                        * (cx[i] * ux + cy[i] * uy)&#10;                        - 3 * (ux * fx_cor + uy * fy_cor)&#10;                        + 0.5&#10;                        * (3 * (cx[i] * cx[i] + cy[i] * cy[i]) - d)&#10;                        * (ux * grad_rho_x + uy * grad_rho_y)&#10;                    )&#10;                )&#10;&#10;            return source_&#10;&#10;        source_2d = source_term(u_2d, force_2d, grad_rho_2d)&#10;&#10;        # Convert to 4D format: (nx, ny, q, 1)&#10;        source_4d = jnp.expand_dims(source_2d, axis=-1)&#10;&#10;        return source_4d&#10;" />
              <option name="updatedContent" value="import jax.numpy as jnp&#10;from wblbm.grid.grid import Grid&#10;from wblbm.lattice.lattice import Lattice&#10;from wblbm.operators.differential.gradient import Gradient&#10;&#10;&#10;class SourceTerm:&#10;    &quot;&quot;&quot;&#10;    Callable class to calculate the source term for the LBM equation.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, grid: Grid, lattice: Lattice, bc_config: dict = None):&#10;        &quot;&quot;&quot;&#10;        Initialize the source term calculator.&#10;&#10;        Args:&#10;            grid (Grid): Grid object containing simulation domain information&#10;            lattice (Lattice): Lattice object containing lattice properties&#10;            bc_config (dict, optional): Boundary condition configuration&#10;        &quot;&quot;&quot;&#10;        self.nx: int = grid.nx&#10;        self.ny: int = grid.ny&#10;        self.q: int = lattice.q&#10;        self.d: int = lattice.d&#10;        self.w = lattice.w&#10;        self.cx = lattice.c[0]&#10;        self.cy = lattice.c[1]&#10;        self.bc_config = bc_config&#10;        self.gradient = Gradient(lattice, bc_config=bc_config)&#10;&#10;    def __call__(&#10;        self, rho: jnp.ndarray, u: jnp.ndarray, force: jnp.ndarray&#10;    ) -&gt; jnp.ndarray:&#10;        &quot;&quot;&quot;&#10;        Calculate the source term for the LBM equation.&#10;&#10;        Args:&#10;            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;            u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)&#10;            force (jnp.ndarray): Force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            jnp.ndarray: Source term, shape (nx, ny, q, 1)&#10;        &quot;&quot;&quot;&#10;        nx, ny, q = self.nx, self.ny, self.q&#10;        w = self.w&#10;        c = (self.cx, self.cy)&#10;        d = self.d&#10;        gradient = self.gradient&#10;&#10;        # Extract 2D data from 4D arrays&#10;        u_2d = u[:, :, 0, :]  # Shape: (nx, ny, 2)&#10;        force_2d = force[:, :, 0, :]  # Shape: (nx, ny, 2)&#10;        rho_2d = rho[:, :, 0, 0]  # Shape: (nx, ny)&#10;&#10;        # Calculate gradient of rho&#10;        grad_rho = self.gradient(rho)&#10;        grad_rho_2d = grad_rho[:, :, 0, :]  # Shape: (nx, ny, 2)&#10;&#10;        def source_term(u_2d_, force_2d_, grad_rho_2d_):&#10;            &quot;&quot;&quot;&#10;            Compute the source term for each lattice direction.&#10;&#10;            Args:&#10;                u_2d_ (jnp.ndarray): Velocity field, shape (nx, ny, 2)&#10;                force_2d_ (jnp.ndarray): Force field, shape (nx, ny, 2)&#10;                grad_rho_2d_ (jnp.ndarray): Gradient of density, shape (nx, ny, 2)&#10;&#10;            Returns:&#10;                jnp.ndarray: Source term, shape (nx, ny, q)&#10;            &quot;&quot;&quot;&#10;            cx, cy = c[0], c[1]&#10;            fx, fy = force_2d_[:, :, 0], force_2d_[:, :, 1]&#10;            ux, uy = u_2d_[:, :, 0], u_2d_[:, :, 1]&#10;            grad_rho_x, grad_rho_y = grad_rho_2d_[:, :, 0], grad_rho_2d_[:, :, 1]&#10;&#10;            fx_cor = fx + (grad_rho_x / 3)&#10;            fy_cor = fy + (grad_rho_y / 3)&#10;            source_ = jnp.zeros((nx, ny, q))&#10;&#10;            for i in range(q):&#10;                # Compute the source term for each direction&#10;                source_ = source_.at[:, :, i].set(&#10;                    w[i]&#10;                    * (&#10;                        3 * (cx[i] * fx + cy[i] * fy)&#10;                        + 9&#10;                        * (cx[i] * fx_cor + cy[i] * fy_cor)&#10;                        * (cx[i] * ux + cy[i] * uy)&#10;                        - 3 * (ux * fx_cor + uy * fy_cor)&#10;                        + 0.5&#10;                        * (3 * (cx[i] * cx[i] + cy[i] * cy[i]) - d)&#10;                        * (ux * grad_rho_x + uy * grad_rho_y)&#10;                    )&#10;                )&#10;&#10;            return source_&#10;&#10;        source_2d = source_term(u_2d, force_2d, grad_rho_2d)&#10;&#10;        # Convert to 4D format: (nx, ny, q, 1)&#10;        source_4d = jnp.expand_dims(source_2d, axis=-1)&#10;&#10;        return source_4d" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            -(2*self.a_eos)*rho_2d + self.R_eos*self.T_eos*(1 + jnp.log(rho_2d))&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        # Julia formula:&#10;        # -(2*a_eos)*ﾏ『[i,j] + R_eos*T_eos*(1 + log(ﾏ『[i,j])) + ((16*R_eos*T_eos*(b_eos*ﾏ『[i,j] -12))/((-4 + b_eos*ﾏ『[i,j])^3))&#10;        eos_2d = (&#10;            -(2 * self.a_eos) * rho_2d&#10;            + self.R_eos * self.T_eos * (1 + jnp.log(rho_2d))&#10;            + (16 * self.R_eos * self.T_eos * (self.b_eos * rho_2d - 12))&#10;              / jnp.power((-4 + self.b_eos * rho_2d), 3)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_dw.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_dw.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseDW(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the double well implementation.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        force_enabled: bool = False,&#10;        bc_config: dict = None,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.bc_config = bc_config&#10;        self.pad_mode = self._determine_padding_modes()&#10;        self.gradient = Gradient(lattice, padmode=self.pad_mode)&#10;        self.laplacian = Laplacian(lattice, padmode=self.pad_mode)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            2&#10;            * self.beta&#10;            * (rho_2d - self.rho_l)&#10;            * (rho_2d - self.rho_v)&#10;            * (2 * rho_2d - self.rho_l - self.rho_v)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseDW(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the double well implementation.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        force_enabled: bool = False,&#10;        bc_config: dict = None,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.bc_config = bc_config&#10;        self.gradient = Gradient(lattice, bc_config=bc_config)&#10;        self.laplacian = Laplacian(lattice, bc_config=bc_config)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            2&#10;            * self.beta&#10;            * (rho_2d - self.rho_l)&#10;            * (rho_2d - self.rho_v)&#10;            * (2 * rho_2d - self.rho_l - self.rho_v)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>