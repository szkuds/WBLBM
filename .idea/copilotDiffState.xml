<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            -(2*self.a_eos)*rho_2d + self.R_eos*self.T_eos*(1 + jnp.log(rho_2d))&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        # Julia formula:&#10;        # -(2*a_eos)*ﾏ『[i,j] + R_eos*T_eos*(1 + log(ﾏ『[i,j])) + ((16*R_eos*T_eos*(b_eos*ﾏ『[i,j] -12))/((-4 + b_eos*ﾏ『[i,j])^3))&#10;        eos_2d = (&#10;            -(2 * self.a_eos) * rho_2d&#10;            + self.R_eos * self.T_eos * (1 + jnp.log(rho_2d))&#10;            + (16 * self.R_eos * self.T_eos * (self.b_eos * rho_2d - 12))&#10;              / jnp.power((-4 + self.b_eos * rho_2d), 3)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/wetting/hysteresis.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/wetting/hysteresis.py" />
              <option name="originalContent" value="import jax.numpy as jnp&#10;from jax import lax&#10;import logging&#10;&#10;&#10;class Hysteresis:&#10;    &quot;&quot;&quot;&#10;    Class to model contact angle hysteresis in wetting simulations.&#10;    JAX-compatible version with conditional operations using jax.lax functions.&#10;    &quot;&quot;&quot;&#10;&#10;    # Numeric constants for return codes&#10;    NONE = 0&#10;    RECEDING_PINNED = 1&#10;    RECEDING_MOVING = 2&#10;    ADVANCING_PINNED = 3&#10;    ADVANCING_MOVING = 4&#10;&#10;    def __init__(self, advancing_ca_hydrophobic, receding_ca_hydrophobic,&#10;                 advancing_ca_hydrophilic, receding_ca_hydrophilic,&#10;                 cll_threshold, ca_threshold, change_d_rho, change_phi,&#10;                 while_limiter, nx, phi_val, d_rho_val, w):&#10;        self.advancing_ca_hydrophobic = advancing_ca_hydrophobic&#10;        self.receding_ca_hydrophobic = receding_ca_hydrophobic&#10;        self.advancing_ca_hydrophilic = advancing_ca_hydrophilic&#10;        self.receding_ca_hydrophilic = receding_ca_hydrophilic&#10;        self.cll_threshold = cll_threshold&#10;        self.ca_threshold = ca_threshold&#10;        self.change_d_rho = change_d_rho&#10;        self.change_phi = change_phi&#10;        self.while_limiter = while_limiter&#10;        self.nx = nx&#10;        self.phi_val = phi_val&#10;        self.d_rho_val = d_rho_val&#10;        self.w = w&#10;&#10;    def apply(self, f_prev, it, left_step_passed, right_step_passed,&#10;              cah_window_left_philic, ca_hwindow_right_philic,&#10;              ca_hwindow_left_phobic, ca_hwindow_right_phobic,&#10;              pinned_count_left, pinned_count_right,&#10;              update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;&#10;        Apply hysteresis logic using JAX-compatible operations.&#10;        &quot;&quot;&quot;&#10;&#10;        # Initialize parameters&#10;        phi_left = jnp.ones(self.nx)&#10;        d_rho_left = jnp.zeros(self.nx)&#10;        phi_left = phi_left.at[self.nx // 2].set(self.phi_val)&#10;        d_rho_left = d_rho_left.at[self.nx // 2].set(self.d_rho_val)&#10;&#10;        phi_right = jnp.ones(self.nx)&#10;        d_rho_right = jnp.zeros(self.nx)&#10;        phi_right = phi_right.at[self.nx // 2].set(self.phi_val)&#10;        d_rho_right = d_rho_right.at[self.nx // 2].set(self.d_rho_val)&#10;&#10;        ft = f_prev&#10;        ft_plus1, rho_t = update_func(ft, phi_left, phi_right, d_rho_left, d_rho_right)&#10;        rho_t_plus1 = get_rho_func(ft_plus1)&#10;&#10;        ca_left_t, ca_right_t = contact_angle_func(rho_t)&#10;        cll_left_t, cll_right_t = cll_func(rho_t, ca_left_t, ca_right_t)&#10;&#10;        ca_left_t_plus1, ca_right_t_plus1 = contact_angle_func(rho_t_plus1)&#10;        cll_left_t_plus1, cll_right_t_plus1 = cll_func(rho_t_plus1, ca_left_t_plus1, ca_right_t_plus1)&#10;&#10;        # Left side logic - using JAX conditionals&#10;        ca_left_t_plus1_scalar = jnp.squeeze(ca_left_t_plus1)&#10;        cah_window_left_philic = lax.cond(&#10;            ca_left_t_plus1_scalar &gt;= self.advancing_ca_hydrophilic,  # Now scalar&#10;            lambda x: True,&#10;            lambda x: cah_window_left_philic,&#10;            None&#10;        )&#10;&#10;        cll_left_t_plus1_scalar = jnp.squeeze(cll_left_t_plus1)&#10;        left_step_passed = lax.cond(&#10;            cll_left_t_plus1_scalar &lt;= (self.nx // 2 - self.w // 2),&#10;            lambda x: True,&#10;            lambda x: left_step_passed,&#10;            None&#10;        )&#10;&#10;        # Set receding and advancing contact angles based on conditions&#10;        receding_ca_left, advancing_ca_left, cll_threshold_left = lax.cond(&#10;            (cll_left_t_plus1_scalar &lt;= (self.nx // 2 - self.w // 2)) &amp; (~left_step_passed),&#10;            lambda x: (self.receding_ca_hydrophobic, self.advancing_ca_hydrophobic, self.cll_threshold),&#10;            lambda x: lax.cond(&#10;                (ca_left_t_plus1_scalar &gt;= self.advancing_ca_hydrophilic) &amp; left_step_passed &amp; (~cah_window_left_philic),&#10;                lambda y: (ca_left_t_plus1_scalar - 1 + 1e-7, ca_left_t_plus1_scalar, self.cll_threshold),&#10;                lambda y: (self.receding_ca_hydrophilic, self.advancing_ca_hydrophilic, self.cll_threshold),&#10;                None&#10;            ),&#10;            None&#10;        )&#10;&#10;        # Right side logic&#10;        ca_right_t_plus1_scalar = jnp.squeeze(ca_right_t_plus1)&#10;        ca_hwindow_right_philic = lax.cond(&#10;            ca_right_t_plus1_scalar &gt;= self.advancing_ca_hydrophilic,&#10;            lambda x: True,&#10;            lambda x: ca_hwindow_right_philic,&#10;            None&#10;        )&#10;&#10;        cll_right_t_plus1_scalar = jnp.squeeze(cll_right_t_plus1)&#10;        right_step_passed = lax.cond(&#10;            cll_right_t_plus1_scalar &gt;= (self.nx // 2 + self.w // 2),&#10;            lambda x: True,&#10;            lambda x: right_step_passed,&#10;            None&#10;        )&#10;&#10;        receding_ca_right, advancing_ca_right, cll_threshold_right = lax.cond(&#10;            (cll_right_t_plus1_scalar &gt;= (self.nx // 2 + self.w // 2)) &amp; (~right_step_passed),&#10;            lambda x: (self.receding_ca_hydrophobic, self.advancing_ca_hydrophobic, self.cll_threshold),&#10;            lambda x: lax.cond(&#10;                (ca_right_t_plus1_scalar &gt;= self.advancing_ca_hydrophilic) &amp; right_step_passed &amp; (~ca_hwindow_right_philic),&#10;                lambda y: (ca_right_t_plus1_scalar, ca_right_t_plus1_scalar + 1 - 1e-7, self.cll_threshold),&#10;                lambda y: (self.receding_ca_hydrophilic, self.advancing_ca_hydrophilic, self.cll_threshold),&#10;                None&#10;            ),&#10;            None&#10;        )&#10;&#10;        # Left logic - Main processing&#10;        cll_left_t_scalar = jnp.squeeze(cll_left_t)&#10;        dummy_scan_result_left = (0, phi_left, d_rho_left, True)&#10;        pm_left = lax.cond(&#10;            cll_left_t_plus1_scalar &lt; cll_left_t_scalar,&#10;            lambda x: self._process_left_receding(&#10;                ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                ca_left_t_plus1, receding_ca_left, advancing_ca_left,&#10;                cll_left_t, cll_left_t_plus1, cll_threshold_left,&#10;                pinned_count_left, update_func, contact_angle_func, cll_func, get_rho_func&#10;            ),&#10;            lambda x: lax.cond(&#10;                jnp.squeeze(cll_left_t_plus1 &gt; cll_left_t),&#10;                lambda y: self._process_left_advancing(&#10;                    ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                    ca_left_t_plus1, receding_ca_left, advancing_ca_left,&#10;                    cll_left_t, cll_left_t_plus1, cll_threshold_left,&#10;                    pinned_count_left, update_func, contact_angle_func, cll_func, get_rho_func&#10;                ),&#10;                lambda y: (self.NONE, dummy_scan_result_left),&#10;                None&#10;            ),&#10;            None&#10;        )&#10;&#10;        # Right logic - Main processing&#10;        dummy_scan_result_right = (0, phi_right, d_rho_right, True)&#10;        pm_right = lax.cond(&#10;            jnp.squeeze(cll_right_t_plus1 &gt; cll_right_t),&#10;            lambda x: self._process_right_advancing(&#10;                ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                ca_right_t_plus1, receding_ca_right, advancing_ca_right,&#10;                cll_right_t, cll_right_t_plus1, cll_threshold_right,&#10;                pinned_count_right, update_func, contact_angle_func, cll_func, get_rho_func&#10;            ),&#10;            lambda x: lax.cond(&#10;                jnp.squeeze(cll_right_t_plus1 &lt; cll_right_t),&#10;                lambda y: self._process_right_receding(&#10;                    ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                    ca_right_t_plus1, receding_ca_right, advancing_ca_right,&#10;                    cll_right_t, cll_right_t_plus1, cll_threshold_right,&#10;                    pinned_count_right, update_func, contact_angle_func, cll_func, get_rho_func&#10;                ),&#10;                lambda y: (self.NONE, dummy_scan_result_right),&#10;                None&#10;            ),&#10;            None&#10;        )&#10;&#10;        # Extract only the numeric code for pm_left and pm_right for return&#10;        pm_left_code = pm_left[0]&#10;        pm_right_code = pm_right[0]&#10;&#10;        return (phi_left, phi_right, d_rho_left, d_rho_right,&#10;                left_step_passed, right_step_passed,&#10;                cah_window_left_philic, ca_hwindow_right_philic,&#10;                ca_hwindow_left_phobic, ca_hwindow_right_phobic,&#10;                pinned_count_left, pinned_count_right, pm_left_code, pm_right_code)&#10;&#10;    def _process_left_receding(self, ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                               ca_left_t_plus1, receding_ca_left, advancing_ca_left,&#10;                               cll_left_t, cll_left_t_plus1, cll_threshold_left,&#10;                               pinned_count_left, update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;Process left receding logic using JAX scan for while loop replacement.&quot;&quot;&quot;&#10;&#10;        def body_fun(carry, _):&#10;            count, phi_left_curr, d_rho_left_curr, should_continue = carry&#10;&#10;            # Check if we should break&#10;            ca_condition = jnp.abs(1 - self.ca_threshold - receding_ca_left - ca_left_t_plus1) &lt;= (&#10;                        1 - self.ca_threshold) * receding_ca_left&#10;            count_condition = count &gt;= self.while_limiter&#10;&#10;            should_break = jnp.squeeze(ca_condition | count_condition)&#10;&#10;            # Update logic when not breaking&#10;            phi_update_cond = jnp.min(d_rho_left_curr) &gt;= -1&#10;            drho_update_cond = jnp.min(phi_left_curr) &gt;= 1&#10;&#10;            phi_left_new = lax.cond(&#10;                should_break,&#10;                lambda x: phi_left_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_left_t_plus1) &gt;= receding_ca_left,&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: phi_left_curr - self.change_phi,&#10;                        lambda z: phi_left_curr,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: phi_left_curr,&#10;                        lambda z: phi_left_curr - self.change_phi,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            d_rho_left_new = lax.cond(&#10;                should_break,&#10;                lambda x: d_rho_left_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_left_t_plus1) &gt;= receding_ca_left,&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: d_rho_left_curr,&#10;                        lambda z: d_rho_left_curr + self.change_d_rho,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: d_rho_left_curr - self.change_d_rho,&#10;                        lambda z: d_rho_left_curr,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            count_new = lax.cond(should_break, lambda x: count, lambda x: count + 1, None)&#10;            should_continue_new = ~should_break&#10;&#10;            return (count_new, phi_left_new, d_rho_left_new, should_continue_new), None&#10;&#10;        # Check if this is receding pinned or receding moving&#10;        is_pinned = jnp.squeeze(ca_left_t_plus1 &lt;= receding_ca_left)&#10;        scan_result = lax.scan(body_fun, (0, phi_left, d_rho_left, True), jnp.arange(self.while_limiter))[0]&#10;        return lax.cond(&#10;            is_pinned,&#10;            lambda x: (self.RECEDING_PINNED, scan_result),&#10;            lambda x: (self.RECEDING_MOVING, scan_result),&#10;            None&#10;        )&#10;&#10;    def _process_left_advancing(self, ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                                ca_left_t_plus1, receding_ca_left, advancing_ca_left,&#10;                                cll_left_t, cll_left_t_plus1, cll_threshold_left,&#10;                                pinned_count_left, update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;Process left advancing logic using JAX scan for while loop replacement.&quot;&quot;&quot;&#10;&#10;        def body_fun(carry, _):&#10;            count, phi_left_curr, d_rho_left_curr, should_continue = carry&#10;&#10;            # Check if we should break&#10;            ca_condition = jnp.abs(1 - self.ca_threshold - advancing_ca_left - ca_left_t_plus1) &lt;= (&#10;                        1 - self.ca_threshold) * advancing_ca_left&#10;            count_condition = count &gt;= self.while_limiter&#10;&#10;            should_break = jnp.squeeze(ca_condition | count_condition)&#10;&#10;            # Update logic when not breaking&#10;            drho_update_cond = jnp.max(d_rho_left_curr) &lt;= 0&#10;            phi_update_cond = jnp.min(phi_left_curr) &gt;= 1&#10;&#10;            phi_left_new = lax.cond(&#10;                should_break,&#10;                lambda x: phi_left_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_left_t_plus1 &lt;= advancing_ca_left),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: phi_left_curr + self.change_phi,&#10;                        lambda z: phi_left_curr,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: phi_left_curr,&#10;                        lambda z: phi_left_curr + self.change_phi,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            d_rho_left_new = lax.cond(&#10;                should_break,&#10;                lambda x: d_rho_left_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_left_t_plus1 &lt;= advancing_ca_left),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: d_rho_left_curr,&#10;                        lambda z: d_rho_left_curr - self.change_d_rho,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: d_rho_left_curr + self.change_d_rho,&#10;                        lambda z: d_rho_left_curr,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            count_new = lax.cond(should_break, lambda x: count, lambda x: count + 1, None)&#10;            should_continue_new = ~should_break&#10;&#10;            return (count_new, phi_left_new, d_rho_left_new, should_continue_new), None&#10;&#10;        # Check if this is advancing pinned or advancing moving&#10;        is_pinned = jnp.squeeze(ca_left_t_plus1 &gt;= advancing_ca_left)&#10;        scan_result = lax.scan(body_fun, (0, phi_left, d_rho_left, True), jnp.arange(self.while_limiter))[0]&#10;        return lax.cond(&#10;            is_pinned,&#10;            lambda x: (self.ADVANCING_PINNED, scan_result),&#10;            lambda x: (self.ADVANCING_MOVING, scan_result),&#10;            None&#10;        )&#10;&#10;    def _process_right_advancing(self, ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                                 ca_right_t_plus1, receding_ca_right, advancing_ca_right,&#10;                                 cll_right_t, cll_right_t_plus1, cll_threshold_right,&#10;                                 pinned_count_right, update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;Process right advancing logic using JAX scan for while loop replacement.&quot;&quot;&quot;&#10;&#10;        def body_fun(carry, _):&#10;            count, phi_right_curr, d_rho_right_curr, should_continue = carry&#10;&#10;            # Check if we should break&#10;            ca_condition = jnp.abs(1 - self.ca_threshold - advancing_ca_right - ca_right_t_plus1) &lt;= (&#10;                        1 - self.ca_threshold) * advancing_ca_right&#10;            count_condition = count &gt;= self.while_limiter&#10;&#10;            should_break = jnp.squeeze(ca_condition | count_condition)&#10;&#10;            # Update logic when not breaking&#10;            drho_update_cond = jnp.max(d_rho_right_curr) &lt;= 0&#10;            phi_update_cond = jnp.min(phi_right_curr) &gt;= 1&#10;&#10;            phi_right_new = lax.cond(&#10;                should_break,&#10;                lambda x: phi_right_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_right_t_plus1 &lt;= advancing_ca_right),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: phi_right_curr + self.change_phi,&#10;                        lambda z: phi_right_curr,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: phi_right_curr,&#10;                        lambda z: phi_right_curr + self.change_phi,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            d_rho_right_new = lax.cond(&#10;                should_break,&#10;                lambda x: d_rho_right_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_right_t_plus1 &lt;= advancing_ca_right),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: d_rho_right_curr,&#10;                        lambda z: d_rho_right_curr - self.change_d_rho,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: d_rho_right_curr + self.change_d_rho,&#10;                        lambda z: d_rho_right_curr,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            count_new = lax.cond(should_break, lambda x: count, lambda x: count + 1, None)&#10;            should_continue_new = ~should_break&#10;&#10;            return (count_new, phi_right_new, d_rho_right_new, should_continue_new), None&#10;&#10;        # Check if this is advancing pinned or advancing moving&#10;        is_pinned = jnp.squeeze(ca_right_t_plus1 &gt;= advancing_ca_right)&#10;        scan_result = lax.scan(body_fun, (0, phi_right, d_rho_right, True), jnp.arange(self.while_limiter))[0]&#10;        return lax.cond(&#10;            is_pinned,&#10;            lambda x: (self.ADVANCING_PINNED, scan_result),&#10;            lambda x: (self.ADVANCING_MOVING, scan_result),&#10;            None&#10;        )&#10;&#10;    def _process_right_receding(self, ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                                ca_right_t_plus1, receding_ca_right, advancing_ca_right,&#10;                                cll_right_t, cll_right_t_plus1, cll_threshold_right,&#10;                                pinned_count_right, update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;Process right receding logic using JAX scan for while loop replacement.&quot;&quot;&quot;&#10;&#10;        def body_fun(carry, _):&#10;            count, phi_right_curr, d_rho_right_curr, should_continue = carry&#10;&#10;            # Check if we should break&#10;            ca_condition = jnp.abs(1 - self.ca_threshold - receding_ca_right - ca_right_t_plus1) &lt;= (&#10;                        1 - self.ca_threshold) * receding_ca_right&#10;            count_condition = count &gt;= self.while_limiter&#10;&#10;            should_break = jnp.squeeze(ca_condition | count_condition)&#10;&#10;            # Update logic when not breaking&#10;            phi_update_cond = jnp.min(d_rho_right_curr) &gt;= -1&#10;            drho_update_cond = jnp.min(phi_right_curr) &gt;= 1&#10;&#10;            phi_right_new = lax.cond(&#10;                should_break,&#10;                lambda x: phi_right_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_right_t_plus1 &gt;= receding_ca_right),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: phi_right_curr - self.change_phi,&#10;                        lambda z: phi_right_curr,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: phi_right_curr,&#10;                        lambda z: phi_right_curr - self.change_phi,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            d_rho_right_new = lax.cond(&#10;                should_break,&#10;                lambda x: d_rho_right_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_right_t_plus1 &gt;= receding_ca_right),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: d_rho_right_curr,&#10;                        lambda z: d_rho_right_curr + self.change_d_rho,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: d_rho_right_curr - self.change_d_rho,&#10;                        lambda z: d_rho_right_curr,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            count_new = lax.cond(should_break, lambda x: count, lambda x: count + 1, None)&#10;            should_continue_new = ~should_break&#10;&#10;            return (count_new, phi_right_new, d_rho_right_new, should_continue_new), None&#10;&#10;        # Check if this is receding pinned or receding moving&#10;        is_pinned = jnp.squeeze(ca_right_t_plus1 &lt;= receding_ca_right)&#10;        scan_result = lax.scan(body_fun, (0, phi_right, d_rho_right, True), jnp.arange(self.while_limiter))[0]&#10;        return lax.cond(&#10;            is_pinned,&#10;            lambda x: (self.RECEDING_PINNED, scan_result),&#10;            lambda x: (self.RECEDING_MOVING, scan_result),&#10;            None&#10;        )&#10;&#10;" />
              <option name="updatedContent" value="import jax.numpy as jnp&#10;from jax import lax&#10;import logging&#10;&#10;&#10;class Hysteresis:&#10;    &quot;&quot;&quot;&#10;    Class to model contact angle hysteresis in wetting simulations.&#10;    JAX-compatible version with conditional operations using jax.lax functions.&#10;    &quot;&quot;&quot;&#10;&#10;    # Numeric constants for return codes&#10;    NONE = 0&#10;    RECEDING_PINNED = 1&#10;    RECEDING_MOVING = 2&#10;    ADVANCING_PINNED = 3&#10;    ADVANCING_MOVING = 4&#10;&#10;    def __init__(self, advancing_ca_hydrophobic, receding_ca_hydrophobic,&#10;                 advancing_ca_hydrophilic, receding_ca_hydrophilic,&#10;                 cll_threshold, ca_threshold, change_d_rho, change_phi,&#10;                 while_limiter, nx, phi_val, d_rho_val, w):&#10;        self.advancing_ca_hydrophobic = advancing_ca_hydrophobic&#10;        self.receding_ca_hydrophobic = receding_ca_hydrophobic&#10;        self.advancing_ca_hydrophilic = advancing_ca_hydrophilic&#10;        self.receding_ca_hydrophilic = receding_ca_hydrophilic&#10;        self.cll_threshold = cll_threshold&#10;        self.ca_threshold = ca_threshold&#10;        self.change_d_rho = change_d_rho&#10;        self.change_phi = change_phi&#10;        self.while_limiter = while_limiter&#10;        self.nx = nx&#10;        self.phi_val = phi_val&#10;        self.d_rho_val = d_rho_val&#10;        self.w = w&#10;&#10;    def apply(self, f_prev, it, left_step_passed, right_step_passed,&#10;              cah_window_left_philic, ca_hwindow_right_philic,&#10;              ca_hwindow_left_phobic, ca_hwindow_right_phobic,&#10;              pinned_count_left, pinned_count_right,&#10;              update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;&#10;        Apply hysteresis logic using JAX-compatible operations.&#10;        &quot;&quot;&quot;&#10;&#10;        # Initialize parameters&#10;        phi_left = jnp.ones(self.nx)&#10;        d_rho_left = jnp.zeros(self.nx)&#10;        phi_left = phi_left.at[self.nx // 2].set(self.phi_val)&#10;        d_rho_left = d_rho_left.at[self.nx // 2].set(self.d_rho_val)&#10;&#10;        phi_right = jnp.ones(self.nx)&#10;        d_rho_right = jnp.zeros(self.nx)&#10;        phi_right = phi_right.at[self.nx // 2].set(self.phi_val)&#10;        d_rho_right = d_rho_right.at[self.nx // 2].set(self.d_rho_val)&#10;&#10;        ft = f_prev&#10;        ft_plus1, rho_t = update_func(ft, phi_left, phi_right, d_rho_left, d_rho_right)&#10;        rho_t_plus1 = get_rho_func(ft_plus1)&#10;&#10;        ca_left_t, ca_right_t = contact_angle_func(rho_t)&#10;        cll_left_t, cll_right_t = cll_func(rho_t, ca_left_t, ca_right_t)&#10;&#10;        ca_left_t_plus1, ca_right_t_plus1 = contact_angle_func(rho_t_plus1)&#10;        cll_left_t_plus1, cll_right_t_plus1 = cll_func(rho_t_plus1, ca_left_t_plus1, ca_right_t_plus1)&#10;&#10;        # Left side logic - using JAX conditionals&#10;        ca_left_t_plus1_scalar = jnp.squeeze(ca_left_t_plus1)&#10;        cah_window_left_philic = lax.cond(&#10;            ca_left_t_plus1_scalar &gt;= self.advancing_ca_hydrophilic,  # Now scalar&#10;            lambda x: True,&#10;            lambda x: cah_window_left_philic,&#10;            None&#10;        )&#10;&#10;        cll_left_t_plus1_scalar = jnp.squeeze(cll_left_t_plus1)&#10;        left_step_passed = lax.cond(&#10;            cll_left_t_plus1_scalar &lt;= (self.nx // 2 - self.w // 2),&#10;            lambda x: True,&#10;            lambda x: left_step_passed,&#10;            None&#10;        )&#10;&#10;        # Set receding and advancing contact angles based on conditions&#10;        receding_ca_left, advancing_ca_left, cll_threshold_left = lax.cond(&#10;            (cll_left_t_plus1_scalar &lt;= (self.nx // 2 - self.w // 2)) &amp; (~left_step_passed),&#10;            lambda x: (self.receding_ca_hydrophobic, self.advancing_ca_hydrophobic, self.cll_threshold),&#10;            lambda x: lax.cond(&#10;                (ca_left_t_plus1_scalar &gt;= self.advancing_ca_hydrophilic) &amp; left_step_passed &amp; (~cah_window_left_philic),&#10;                lambda y: (ca_left_t_plus1_scalar - 1 + 1e-7, ca_left_t_plus1_scalar, self.cll_threshold),&#10;                lambda y: (self.receding_ca_hydrophilic, self.advancing_ca_hydrophilic, self.cll_threshold),&#10;                None&#10;            ),&#10;            None&#10;        )&#10;&#10;        # Right side logic&#10;        ca_right_t_plus1_scalar = jnp.squeeze(ca_right_t_plus1)&#10;        ca_hwindow_right_philic = lax.cond(&#10;            ca_right_t_plus1_scalar &gt;= self.advancing_ca_hydrophilic,&#10;            lambda x: True,&#10;            lambda x: ca_hwindow_right_philic,&#10;            None&#10;        )&#10;&#10;        cll_right_t_plus1_scalar = jnp.squeeze(cll_right_t_plus1)&#10;        right_step_passed = lax.cond(&#10;            cll_right_t_plus1_scalar &gt;= (self.nx // 2 + self.w // 2),&#10;            lambda x: True,&#10;            lambda x: right_step_passed,&#10;            None&#10;        )&#10;&#10;        receding_ca_right, advancing_ca_right, cll_threshold_right = lax.cond(&#10;            (cll_right_t_plus1_scalar &gt;= (self.nx // 2 + self.w // 2)) &amp; (~right_step_passed),&#10;            lambda x: (self.receding_ca_hydrophobic, self.advancing_ca_hydrophobic, self.cll_threshold),&#10;            lambda x: lax.cond(&#10;                (ca_right_t_plus1_scalar &gt;= self.advancing_ca_hydrophilic) &amp; right_step_passed &amp; (~ca_hwindow_right_philic),&#10;                lambda y: (ca_right_t_plus1_scalar, ca_right_t_plus1_scalar + 1 - 1e-7, self.cll_threshold),&#10;                lambda y: (self.receding_ca_hydrophilic, self.advancing_ca_hydrophilic, self.cll_threshold),&#10;                None&#10;            ),&#10;            None&#10;        )&#10;&#10;        # Left logic - Main processing&#10;        cll_left_t_scalar = jnp.squeeze(cll_left_t)&#10;        dummy_scan_result_left = (0, phi_left, d_rho_left, True)&#10;        pm_left = lax.cond(&#10;            cll_left_t_plus1_scalar &lt; cll_left_t_scalar,&#10;            lambda x: self._process_left_receding(&#10;                ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                ca_left_t_plus1, receding_ca_left, advancing_ca_left,&#10;                cll_left_t, cll_left_t_plus1, cll_threshold_left,&#10;                pinned_count_left, update_func, contact_angle_func, cll_func, get_rho_func&#10;            ),&#10;            lambda x: lax.cond(&#10;                jnp.squeeze(cll_left_t_plus1 &gt; cll_left_t),&#10;                lambda y: self._process_left_advancing(&#10;                    ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                    ca_left_t_plus1, receding_ca_left, advancing_ca_left,&#10;                    cll_left_t, cll_left_t_plus1, cll_threshold_left,&#10;                    pinned_count_left, update_func, contact_angle_func, cll_func, get_rho_func&#10;                ),&#10;                lambda y: (self.NONE, dummy_scan_result_left),&#10;                None&#10;            ),&#10;            None&#10;        )&#10;&#10;        # Right logic - Main processing&#10;        dummy_scan_result_right = (0, phi_right, d_rho_right, True)&#10;        pm_right = lax.cond(&#10;            jnp.squeeze(cll_right_t_plus1 &gt; cll_right_t),&#10;            lambda x: self._process_right_advancing(&#10;                ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                ca_right_t_plus1, receding_ca_right, advancing_ca_right,&#10;                cll_right_t, cll_right_t_plus1, cll_threshold_right,&#10;                pinned_count_right, update_func, contact_angle_func, cll_func, get_rho_func&#10;            ),&#10;            lambda x: lax.cond(&#10;                jnp.squeeze(cll_right_t_plus1 &lt; cll_right_t),&#10;                lambda y: self._process_right_receding(&#10;                    ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                    ca_right_t_plus1, receding_ca_right, advancing_ca_right,&#10;                    cll_right_t, cll_right_t_plus1, cll_threshold_right,&#10;                    pinned_count_right, update_func, contact_angle_func, cll_func, get_rho_func&#10;                ),&#10;                lambda y: (self.NONE, dummy_scan_result_right),&#10;                None&#10;            ),&#10;            None&#10;        )&#10;&#10;        # Extract only the numeric code for pm_left and pm_right for return&#10;        pm_left_code = pm_left[0]&#10;        pm_right_code = pm_right[0]&#10;&#10;        # DEBUG: Print computed contact angles and state variables&#10;        print(f&quot;[DEBUG] it={it} ca_left_t_plus1={float(jnp.squeeze(ca_left_t_plus1)):.2f} ca_right_t_plus1={float(jnp.squeeze(ca_right_t_plus1)):.2f}&quot;)&#10;        print(f&quot;[DEBUG] it={it} left_step_passed={left_step_passed} right_step_passed={right_step_passed}&quot;)&#10;        print(f&quot;[DEBUG] it={it} cah_window_left_philic={cah_window_left_philic} ca_hwindow_right_philic={ca_hwindow_right_philic}&quot;)&#10;&#10;        return (phi_left, phi_right, d_rho_left, d_rho_right,&#10;                left_step_passed, right_step_passed,&#10;                cah_window_left_philic, ca_hwindow_right_philic,&#10;                ca_hwindow_left_phobic, ca_hwindow_right_phobic,&#10;                pinned_count_left, pinned_count_right, pm_left_code, pm_right_code)&#10;&#10;    def _process_left_receding(self, ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                               ca_left_t_plus1, receding_ca_left, advancing_ca_left,&#10;                               cll_left_t, cll_left_t_plus1, cll_threshold_left,&#10;                               pinned_count_left, update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;Process left receding logic using JAX scan for while loop replacement.&quot;&quot;&quot;&#10;&#10;        def body_fun(carry, _):&#10;            count, phi_left_curr, d_rho_left_curr, should_continue = carry&#10;&#10;            # Check if we should break&#10;            ca_condition = jnp.abs(1 - self.ca_threshold - receding_ca_left - ca_left_t_plus1) &lt;= (&#10;                        1 - self.ca_threshold) * receding_ca_left&#10;            count_condition = count &gt;= self.while_limiter&#10;&#10;            should_break = jnp.squeeze(ca_condition | count_condition)&#10;&#10;            # Update logic when not breaking&#10;            phi_update_cond = jnp.min(d_rho_left_curr) &gt;= -1&#10;            drho_update_cond = jnp.min(phi_left_curr) &gt;= 1&#10;&#10;            phi_left_new = lax.cond(&#10;                should_break,&#10;                lambda x: phi_left_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_left_t_plus1) &gt;= receding_ca_left,&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: phi_left_curr - self.change_phi,&#10;                        lambda z: phi_left_curr,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: phi_left_curr,&#10;                        lambda z: phi_left_curr - self.change_phi,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            d_rho_left_new = lax.cond(&#10;                should_break,&#10;                lambda x: d_rho_left_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_left_t_plus1) &gt;= receding_ca_left,&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: d_rho_left_curr,&#10;                        lambda z: d_rho_left_curr + self.change_d_rho,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: d_rho_left_curr - self.change_d_rho,&#10;                        lambda z: d_rho_left_curr,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            count_new = lax.cond(should_break, lambda x: count, lambda x: count + 1, None)&#10;            should_continue_new = ~should_break&#10;&#10;            return (count_new, phi_left_new, d_rho_left_new, should_continue_new), None&#10;&#10;        # Check if this is receding pinned or receding moving&#10;        is_pinned = jnp.squeeze(ca_left_t_plus1 &lt;= receding_ca_left)&#10;        scan_result = lax.scan(body_fun, (0, phi_left, d_rho_left, True), jnp.arange(self.while_limiter))[0]&#10;        return lax.cond(&#10;            is_pinned,&#10;            lambda x: (self.RECEDING_PINNED, scan_result),&#10;            lambda x: (self.RECEDING_MOVING, scan_result),&#10;            None&#10;        )&#10;&#10;    def _process_left_advancing(self, ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                                ca_left_t_plus1, receding_ca_left, advancing_ca_left,&#10;                                cll_left_t, cll_left_t_plus1, cll_threshold_left,&#10;                                pinned_count_left, update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;Process left advancing logic using JAX scan for while loop replacement.&quot;&quot;&quot;&#10;&#10;        def body_fun(carry, _):&#10;            count, phi_left_curr, d_rho_left_curr, should_continue = carry&#10;&#10;            # Check if we should break&#10;            ca_condition = jnp.abs(1 - self.ca_threshold - advancing_ca_left - ca_left_t_plus1) &lt;= (&#10;                        1 - self.ca_threshold) * advancing_ca_left&#10;            count_condition = count &gt;= self.while_limiter&#10;&#10;            should_break = jnp.squeeze(ca_condition | count_condition)&#10;&#10;            # Update logic when not breaking&#10;            drho_update_cond = jnp.max(d_rho_left_curr) &lt;= 0&#10;            phi_update_cond = jnp.min(phi_left_curr) &gt;= 1&#10;&#10;            phi_left_new = lax.cond(&#10;                should_break,&#10;                lambda x: phi_left_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_left_t_plus1 &lt;= advancing_ca_left),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: phi_left_curr + self.change_phi,&#10;                        lambda z: phi_left_curr,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: phi_left_curr,&#10;                        lambda z: phi_left_curr + self.change_phi,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            d_rho_left_new = lax.cond(&#10;                should_break,&#10;                lambda x: d_rho_left_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_left_t_plus1 &lt;= advancing_ca_left),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: d_rho_left_curr,&#10;                        lambda z: d_rho_left_curr - self.change_d_rho,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: d_rho_left_curr + self.change_d_rho,&#10;                        lambda z: d_rho_left_curr,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            count_new = lax.cond(should_break, lambda x: count, lambda x: count + 1, None)&#10;            should_continue_new = ~should_break&#10;&#10;            return (count_new, phi_left_new, d_rho_left_new, should_continue_new), None&#10;&#10;        # Check if this is advancing pinned or advancing moving&#10;        is_pinned = jnp.squeeze(ca_left_t_plus1 &gt;= advancing_ca_left)&#10;        scan_result = lax.scan(body_fun, (0, phi_left, d_rho_left, True), jnp.arange(self.while_limiter))[0]&#10;        return lax.cond(&#10;            is_pinned,&#10;            lambda x: (self.ADVANCING_PINNED, scan_result),&#10;            lambda x: (self.ADVANCING_MOVING, scan_result),&#10;            None&#10;        )&#10;&#10;    def _process_right_advancing(self, ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                                 ca_right_t_plus1, receding_ca_right, advancing_ca_right,&#10;                                 cll_right_t, cll_right_t_plus1, cll_threshold_right,&#10;                                 pinned_count_right, update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;Process right advancing logic using JAX scan for while loop replacement.&quot;&quot;&quot;&#10;&#10;        def body_fun(carry, _):&#10;            count, phi_right_curr, d_rho_right_curr, should_continue = carry&#10;&#10;            # Check if we should break&#10;            ca_condition = jnp.abs(1 - self.ca_threshold - advancing_ca_right - ca_right_t_plus1) &lt;= (&#10;                        1 - self.ca_threshold) * advancing_ca_right&#10;            count_condition = count &gt;= self.while_limiter&#10;&#10;            should_break = jnp.squeeze(ca_condition | count_condition)&#10;&#10;            # Update logic when not breaking&#10;            drho_update_cond = jnp.max(d_rho_right_curr) &lt;= 0&#10;            phi_update_cond = jnp.min(phi_right_curr) &gt;= 1&#10;&#10;            phi_right_new = lax.cond(&#10;                should_break,&#10;                lambda x: phi_right_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_right_t_plus1 &lt;= advancing_ca_right),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: phi_right_curr + self.change_phi,&#10;                        lambda z: phi_right_curr,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: phi_right_curr,&#10;                        lambda z: phi_right_curr + self.change_phi,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            d_rho_right_new = lax.cond(&#10;                should_break,&#10;                lambda x: d_rho_right_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_right_t_plus1 &lt;= advancing_ca_right),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: d_rho_right_curr,&#10;                        lambda z: d_rho_right_curr - self.change_d_rho,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: d_rho_right_curr + self.change_d_rho,&#10;                        lambda z: d_rho_right_curr,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            count_new = lax.cond(should_break, lambda x: count, lambda x: count + 1, None)&#10;            should_continue_new = ~should_break&#10;&#10;            return (count_new, phi_right_new, d_rho_right_new, should_continue_new), None&#10;&#10;        # Check if this is advancing pinned or advancing moving&#10;        is_pinned = jnp.squeeze(ca_right_t_plus1 &gt;= advancing_ca_right)&#10;        scan_result = lax.scan(body_fun, (0, phi_right, d_rho_right, True), jnp.arange(self.while_limiter))[0]&#10;        return lax.cond(&#10;            is_pinned,&#10;            lambda x: (self.ADVANCING_PINNED, scan_result),&#10;            lambda x: (self.ADVANCING_MOVING, scan_result),&#10;            None&#10;        )&#10;&#10;    def _process_right_receding(self, ft, phi_left, phi_right, d_rho_left, d_rho_right,&#10;                                ca_right_t_plus1, receding_ca_right, advancing_ca_right,&#10;                                cll_right_t, cll_right_t_plus1, cll_threshold_right,&#10;                                pinned_count_right, update_func, contact_angle_func, cll_func, get_rho_func):&#10;        &quot;&quot;&quot;Process right receding logic using JAX scan for while loop replacement.&quot;&quot;&quot;&#10;&#10;        def body_fun(carry, _):&#10;            count, phi_right_curr, d_rho_right_curr, should_continue = carry&#10;&#10;            # Check if we should break&#10;            ca_condition = jnp.abs(1 - self.ca_threshold - receding_ca_right - ca_right_t_plus1) &lt;= (&#10;                        1 - self.ca_threshold) * receding_ca_right&#10;            count_condition = count &gt;= self.while_limiter&#10;&#10;            should_break = jnp.squeeze(ca_condition | count_condition)&#10;&#10;            # Update logic when not breaking&#10;            phi_update_cond = jnp.min(d_rho_right_curr) &gt;= -1&#10;            drho_update_cond = jnp.min(phi_right_curr) &gt;= 1&#10;&#10;            phi_right_new = lax.cond(&#10;                should_break,&#10;                lambda x: phi_right_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_right_t_plus1 &gt;= receding_ca_right),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: phi_right_curr - self.change_phi,&#10;                        lambda z: phi_right_curr,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: phi_right_curr,&#10;                        lambda z: phi_right_curr - self.change_phi,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            d_rho_right_new = lax.cond(&#10;                should_break,&#10;                lambda x: d_rho_right_curr,&#10;                lambda x: lax.cond(&#10;                    jnp.squeeze(ca_right_t_plus1 &gt;= receding_ca_right),&#10;                    lambda y: lax.cond(&#10;                        phi_update_cond,&#10;                        lambda z: d_rho_right_curr,&#10;                        lambda z: d_rho_right_curr + self.change_d_rho,&#10;                        None&#10;                    ),&#10;                    lambda y: lax.cond(&#10;                        drho_update_cond,&#10;                        lambda z: d_rho_right_curr - self.change_d_rho,&#10;                        lambda z: d_rho_right_curr,&#10;                        None&#10;                    ),&#10;                    None&#10;                ),&#10;                None&#10;            )&#10;&#10;            count_new = lax.cond(should_break, lambda x: count, lambda x: count + 1, None)&#10;            should_continue_new = ~should_break&#10;&#10;            return (count_new, phi_right_new, d_rho_right_new, should_continue_new), None&#10;&#10;        # Check if this is receding pinned or receding moving&#10;        is_pinned = jnp.squeeze(ca_right_t_plus1 &lt;= receding_ca_right)&#10;        scan_result = lax.scan(body_fun, (0, phi_right, d_rho_right, True), jnp.arange(self.while_limiter))[0]&#10;        return lax.cond(&#10;            is_pinned,&#10;            lambda x: (self.RECEDING_PINNED, scan_result),&#10;            lambda x: (self.RECEDING_MOVING, scan_result),&#10;            None&#10;        )" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>