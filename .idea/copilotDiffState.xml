<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/examples/electrical_force_integration.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/examples/electrical_force_integration.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Integration Guide for ElectricalForce with existing LBM simulation&#10;&#10;This document shows how to integrate the electrical force with your existing &#10;simulation code, including how to use it independently or combined with gravity.&#10;&quot;&quot;&quot;&#10;&#10;# ============================================================================&#10;# EXAMPLE 1: Using ElectricalForce alone&#10;# ============================================================================&#10;&#10;from wblbm.operators.force import ElectricalForce, collision_h_i, equilibrium_h&#10;from wblbm.lattice import Lattice&#10;&#10;# Initialize lattice and get weights&#10;lattice = Lattice()&#10;w_i = lattice.w  # Lattice weights for D2Q9&#10;c_i = lattice.c  # Lattice velocities&#10;&#10;# Initialize electrical force&#10;nx, ny = 201, 201&#10;electrical_force = ElectricalForce(nx, ny, d=2, permittivity=1.0)&#10;&#10;# Initialize h_i distribution and charge density&#10;h_i = equilibrium_h(electrical_force.U, w_i)&#10;charge_density = jnp.zeros((nx, ny))  # Initialize with your charge distribution&#10;&#10;# Parameters&#10;tau_e = 0.8  # Relaxation time for electrical collision&#10;c_s_sq = 1.0 / 3.0  # Sound speed squared&#10;&#10;# Main simulation loop&#10;for step in range(num_steps):&#10;    # ... existing LBM collision and streaming for f_i ...&#10;    &#10;    # Collision step for electrical distribution&#10;    h_i = collision_h_i(h_i, electrical_force.U, tau_e, w_i, c_s_sq)&#10;    &#10;    # Streaming step for h_i (use your existing streaming operator)&#10;    h_i = stream_operator(h_i, lattice.c)&#10;    &#10;    # Update electric potential from h_i&#10;    electrical_force.update_potential(h_i)&#10;    &#10;    # Compute electrical force&#10;    force = electrical_force.compute_force(rho, charge_density)&#10;    &#10;    # Apply force to your f_i evolution&#10;&#10;&#10;# ============================================================================&#10;# EXAMPLE 2: Combining ElectricalForce with GravityForce&#10;# ============================================================================&#10;&#10;from wblbm.operators.force import (&#10;    GravityForceMultiphase, &#10;    ElectricalForce, &#10;    CompositeForce,&#10;    collision_h_i,&#10;    equilibrium_h&#10;)&#10;&#10;# Initialize both forces&#10;gravity = GravityForceMultiphase(&#10;    nx=201, ny=201, d=2, &#10;    force_g=0.0001, &#10;    inclination_angle_deg=0.0&#10;)&#10;&#10;electrical = ElectricalForce(&#10;    nx=201, ny=201, d=2, &#10;    permittivity=1.0&#10;)&#10;&#10;# Combine forces&#10;combined_forces = CompositeForce(gravity, electrical)&#10;&#10;# Main simulation loop&#10;for step in range(num_steps):&#10;    # ... existing LBM collision and streaming for f_i ...&#10;    &#10;    # Electrical distribution evolution&#10;    h_i = collision_h_i(h_i, electrical.U, tau_e, w_i, c_s_sq)&#10;    h_i = stream_operator(h_i, lattice.c)&#10;    electrical.update_potential(h_i)&#10;    &#10;    # Compute combined force (gravity + electrical)&#10;    total_force = combined_forces.compute_force(rho, charge_density)&#10;    &#10;    # Apply combined force to f_i evolution&#10;    # Force term: F_i = w_i * rho * c_i . (a - u) / c_s^4&#10;    # where a is the acceleration from total_force&#10;&#10;&#10;# ============================================================================&#10;# EXAMPLE 3: Using with different force combinations&#10;# ============================================================================&#10;&#10;# You can combine any forces:&#10;# - Only gravity&#10;gravity_only = GravityForceMultiphase(nx, ny, 2, 0.0001, 0.0)&#10;&#10;# - Only electrical&#10;electrical_only = ElectricalForce(nx, ny, 2, 1.0)&#10;&#10;# - Gravity + electrical&#10;gravity_and_electrical = CompositeForce(gravity, electrical)&#10;&#10;# - Add more forces in the future by extending Force class&#10;# combined = CompositeForce(force1, force2, force3, ...)&#10;&#10;&#10;# ============================================================================&#10;# IMPLEMENTATION NOTES&#10;# ============================================================================&#10;&#10;&quot;&quot;&quot;&#10;1. DISTRIBUTION FUNCTION h_i:&#10;   - Separate from f_i (density distribution)&#10;   - Solves for electric potential U via: U = Σ_i h_i&#10;   - Evolves with its own collision and streaming&#10;   - Equilibrium: h_i^eq = w_i * U&#10;&#10;2. COLLISION OPERATOR:&#10;   - h_i^(n+1) = h_i^(n) - (1/tau_e) * (h_i^(n) - h_i^eq)&#10;   - tau_e controls convergence speed&#10;   - Typical values: 0.5 &lt; tau_e &lt; 2.0&#10;&#10;3. ELECTRIC POTENTIAL:&#10;   - Updated each timestep from h_i distribution&#10;   - Used to compute electric field: E = -∇U&#10;   - Force on charges: F = q * E = q * (-∇U)&#10;&#10;4. FORCE APPLICATION:&#10;   - Electrical force acts on charge_density&#10;   - Charge density can be derived from phase field&#10;   - Force is applied in force term of LBM collision&#10;&#10;5. CHARGE DENSITY:&#10;   - Must be initialized based on your system&#10;   - Can vary in space and time&#10;   - For droplet: charge_density related to phase field φ&#10;&#10;6. PERFORMANCE TIPS:&#10;   - Both f_i and h_i should be JIT compiled&#10;   - Use vmap for parallel computations across multiple droplets&#10;   - Consider using scan for timestep loops&#10;&quot;&quot;&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/force/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/force/__init__.py" />
              <option name="originalContent" value="from .force import Force&#10;from .gravitational_force_bubble import GravityForceMultiphaseBubble&#10;from .gravitational_force_standard import GravityForceSinglephase&#10;from .gravitational_force_droplet import GravityForceMultiphaseDroplet&#10;from .gravitational_force import GravityForceMultiphase&#10;" />
              <option name="updatedContent" value="from .force import Force&#10;from .gravitational_force_bubble import GravityForceMultiphaseBubble&#10;from .gravitational_force_standard import GravityForceSinglephase&#10;from .gravitational_force_droplet import GravityForceMultiphaseDroplet&#10;from .gravitational_force import GravityForceMultiphase&#10;from .electric_force import ElectricalForce, collision_h_i, equilibrium_h&#10;from .composite_force import CompositeForce" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/force/composite_force.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/force/composite_force.py" />
              <option name="updatedContent" value="import jax.numpy as jnp&#10;from wblbm.operators.force.force import Force&#10;&#10;&#10;class CompositeForce(Force):&#10;    &quot;&quot;&quot;&#10;    Combines multiple force fields by superposition.&#10;    Allows gravitational, electrical, and other forces to work together.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, *forces: Force):&#10;        &quot;&quot;&quot;&#10;        Initialize composite force with multiple force components.&#10;        &#10;        Args:&#10;            *forces: Variable number of Force objects to combine&#10;        &quot;&quot;&quot;&#10;        if not forces:&#10;            raise ValueError(&quot;At least one force must be provided&quot;)&#10;        &#10;        self.forces = forces&#10;        # Initialize with zeros; actual force is computed dynamically&#10;        super().__init__(jnp.zeros_like(forces[0].force))&#10;&#10;    def compute_force(&#10;        self, *args, **kwargs&#10;    ) -&gt; jnp.ndarray:&#10;        &quot;&quot;&quot;&#10;        Sum contributions from all forces.&#10;        Passes all arguments to each force's compute_force method.&#10;        &#10;        Returns:&#10;            Combined force array of shape (nx, ny, 1, d)&#10;        &quot;&quot;&quot;&#10;        total_force = None&#10;        &#10;        for force in self.forces:&#10;            force_contribution = force.compute_force(*args, **kwargs)&#10;            if total_force is None:&#10;                total_force = force_contribution&#10;            else:&#10;                total_force = total_force + force_contribution&#10;        &#10;        self.force = total_force&#10;        return total_force&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/force/electric_force.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/force/electric_force.py" />
              <option name="originalContent" value="import jax.numpy as jnp&#10;from wblbm.operators.force.force import Force&#10;&#10;&#10;class ElectricalForce(Force):&#10;    &quot;&quot;&quot;&#10;    Subclass for electrical force with electric potential distribution.&#10;    Solves for electric potential using a separate distribution function h_i.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, nx: int, ny: int, d: int, permittivity: float):&#10;        &quot;&quot;&quot;&#10;        Initialize electrical force.&#10;        &#10;        Args:&#10;            nx: Grid size in x direction&#10;            ny: Grid size in y direction&#10;            d: Dimensionality (must be 2)&#10;            permittivity: Electric permittivity of the medium&#10;        &quot;&quot;&quot;&#10;        if d != 2:&#10;            raise ValueError(&quot;Currently supports 2D (d=2) only&quot;)&#10;&#10;        force_array = jnp.zeros((nx, ny, 1, d))&#10;        super().__init__(force_array)&#10;        self.permittivity = permittivity&#10;        self.nx = nx&#10;        self.ny = ny&#10;        self.d = d&#10;        &#10;        # Initialize h_i distribution function for electric potential&#10;        # 9 velocities for D2Q9 lattice&#10;        self.h_i = jnp.zeros((nx, ny, 9))&#10;        self.U = jnp.zeros((nx, ny))  # Electric potential field&#10;&#10;    def compute_force(&#10;        self, rho: jnp.ndarray, charge_density: jnp.ndarray&#10;    ) -&gt; jnp.ndarray:&#10;        &quot;&quot;&quot;&#10;        Compute electrical force from electric field gradient.&#10;        E = -∇U, F = q * E&#10;        &#10;        Args:&#10;            rho: Density field of shape (nx, ny, 1)&#10;            charge_density: Charge density field of shape (nx, ny)&#10;            &#10;        Returns:&#10;            Force array of shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        # Compute electric field from potential gradient&#10;        E_x = -jnp.gradient(self.U, axis=0)&#10;        E_y = -jnp.gradient(self.U, axis=1)&#10;        &#10;        force_x = charge_density * E_x&#10;        force_y = charge_density * E_y&#10;        &#10;        force_array = jnp.zeros((rho.shape[0], rho.shape[1], 1, 2))&#10;        force_array = force_array.at[:, :, 0, 0].set(force_x)&#10;        force_array = force_array.at[:, :, 0, 1].set(force_y)&#10;        &#10;        self.force = force_array&#10;        return -self.force * rho&#10;&#10;    def update_potential(self, h_i: jnp.ndarray) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Update electric potential from h_i distribution.&#10;        U = Σ h_i&#10;        &#10;        Args:&#10;            h_i: Distribution function for electric potential, shape (nx, ny, 9)&#10;        &quot;&quot;&quot;&#10;        self.h_i = h_i&#10;        self.U = jnp.sum(h_i, axis=2)&#10;&#10;&#10;def collision_h_i(h_i: jnp.ndarray, U: jnp.ndarray, tau_e: float, &#10;                   w_i: jnp.ndarray, c_s_sq: float) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Collision step for electrical potential distribution.&#10;    Relaxes h_i towards equilibrium with relaxation time tau_e.&#10;    &#10;    Args:&#10;        h_i: Distribution function for electric potential, shape (nx, ny, 9)&#10;        U: Electric potential field, shape (nx, ny)&#10;        tau_e: Relaxation time for electrical collision&#10;        w_i: Lattice weights, shape (9,)&#10;        c_s_sq: Lattice sound speed squared&#10;        &#10;    Returns:&#10;        Updated distribution function after collision&#10;    &quot;&quot;&quot;&#10;    h_eq = equilibrium_h(U, w_i)&#10;    return h_i - (1.0 / tau_e) * (h_i - h_eq)&#10;&#10;&#10;def equilibrium_h(U: jnp.ndarray, w_i: jnp.ndarray) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Equilibrium distribution for electric potential.&#10;    h_i^eq = w_i * U&#10;    &#10;    Args:&#10;        U: Electric potential field, shape (nx, ny)&#10;        w_i: Lattice weights, shape (9,)&#10;        &#10;    Returns:&#10;        Equilibrium distribution, shape (nx, ny, 9)&#10;    &quot;&quot;&quot;&#10;    return w_i[:, jnp.newaxis, jnp.newaxis] * U[jnp.newaxis, jnp.newaxis, :]" />
              <option name="updatedContent" value="import jax.numpy as jnp&#10;from wblbm.operators.force.force import Force&#10;&#10;&#10;class ElectricalForce(Force):&#10;    &quot;&quot;&quot;&#10;    Subclass for electrical force with electric potential distribution.&#10;    Solves for electric potential using a separate distribution function h_i.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, nx: int, ny: int, d: int, permittivity: float):&#10;        &quot;&quot;&quot;&#10;        Initialize electrical force.&#10;        &#10;        Args:&#10;            nx: Grid size in x direction&#10;            ny: Grid size in y direction&#10;            d: Dimensionality (must be 2)&#10;            permittivity: Electric permittivity of the medium&#10;        &quot;&quot;&quot;&#10;        if d != 2:&#10;            raise ValueError(&quot;Currently supports 2D (d=2) only&quot;)&#10;&#10;        force_array = jnp.zeros((nx, ny, 1, d))&#10;        super().__init__(force_array)&#10;        self.permittivity = permittivity&#10;        self.nx = nx&#10;        self.ny = ny&#10;        self.d = d&#10;        &#10;        # Initialize h_i distribution function for electric potential&#10;        # 9 velocities for D2Q9 lattice&#10;        self.h_i = jnp.zeros((nx, ny, 9))&#10;        self.U = jnp.zeros((nx, ny))  # Electric potential field&#10;&#10;    def compute_force(&#10;        self, rho: jnp.ndarray, charge_density: jnp.ndarray&#10;    ) -&gt; jnp.ndarray:&#10;        &quot;&quot;&quot;&#10;        Compute electrical force from electric field gradient.&#10;        E = -∇U, F = q * E&#10;        &#10;        Args:&#10;            rho: Density field of shape (nx, ny, 1)&#10;            charge_density: Charge density field of shape (nx, ny)&#10;            &#10;        Returns:&#10;            Force array of shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        # Compute electric field from potential gradient&#10;        E_x = -jnp.gradient(self.U, axis=0)&#10;        E_y = -jnp.gradient(self.U, axis=1)&#10;        &#10;        force_x = charge_density * E_x&#10;        force_y = charge_density * E_y&#10;        &#10;        force_array = jnp.zeros((rho.shape[0], rho.shape[1], 1, 2))&#10;        force_array = force_array.at[:, :, 0, 0].set(force_x)&#10;        force_array = force_array.at[:, :, 0, 1].set(force_y)&#10;        &#10;        self.force = force_array&#10;        return -self.force * rho&#10;&#10;    def update_potential(self, h_i: jnp.ndarray) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Update electric potential from h_i distribution.&#10;        U = Σ h_i&#10;        &#10;        Args:&#10;            h_i: Distribution function for electric potential, shape (nx, ny, 9)&#10;        &quot;&quot;&quot;&#10;        self.h_i = h_i&#10;        self.U = jnp.sum(h_i, axis=2)&#10;&#10;&#10;def collision_h_i(h_i: jnp.ndarray, U: jnp.ndarray, tau_e: float, &#10;                   w_i: jnp.ndarray, c_s_sq: float) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Collision step for electrical potential distribution.&#10;    Relaxes h_i towards equilibrium with relaxation time tau_e.&#10;    &#10;    Args:&#10;        h_i: Distribution function for electric potential, shape (nx, ny, 9)&#10;        U: Electric potential field, shape (nx, ny)&#10;        tau_e: Relaxation time for electrical collision&#10;        w_i: Lattice weights, shape (9,)&#10;        c_s_sq: Lattice sound speed squared&#10;        &#10;    Returns:&#10;        Updated distribution function after collision&#10;    &quot;&quot;&quot;&#10;    h_eq = equilibrium_h(U, w_i)&#10;    return h_i - (1.0 / tau_e) * (h_i - h_eq)&#10;&#10;&#10;def equilibrium_h(U: jnp.ndarray, w_i: jnp.ndarray) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Equilibrium distribution for electric potential.&#10;    h_i^eq = w_i * U&#10;    &#10;    Args:&#10;        U: Electric potential field, shape (nx, ny)&#10;        w_i: Lattice weights, shape (9,)&#10;        &#10;    Returns:&#10;        Equilibrium distribution, shape (nx, ny, 9)&#10;    &quot;&quot;&quot;&#10;    return w_i[:, jnp.newaxis, jnp.newaxis] * U[jnp.newaxis, jnp.newaxis, :]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/macroscopic/macroscopic_multiphase_CS.py" />
              <option name="originalContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        eos_2d = (&#10;            -(2*self.a_eos)*rho_2d + self.R_eos*self.T_eos*(1 + jnp.log(rho_2d))&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2&#10;" />
              <option name="updatedContent" value="from functools import partial&#10;&#10;import jax.numpy as jnp&#10;from jax import jit&#10;&#10;from wblbm.grid import Grid&#10;from wblbm.operators.macroscopic.macroscopic import Macroscopic&#10;from wblbm.operators.differential.gradient import Gradient&#10;from wblbm.operators.differential.laplacian import Laplacian&#10;from wblbm.lattice.lattice import Lattice&#10;&#10;&#10;class MacroscopicMultiphaseCS(Macroscopic):&#10;    &quot;&quot;&quot;&#10;    Calculates macroscopic variables for multiphase simulations.&#10;    Inherits from Macroscopic and adds multiphase-specific methods.&#10;    This is the implementation of the Carnahan Starling equation of state.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        grid: Grid,&#10;        lattice: Lattice,&#10;        kappa: float,&#10;        interface_width: int,&#10;        rho_l: float,&#10;        rho_v: float,&#10;        a_eos: float,&#10;        b_eos: float,&#10;        R_eos: float,&#10;        T_eos: float,&#10;        force_enabled: bool = False,&#10;    ):&#10;        super().__init__(&#10;            grid, lattice, force_enabled=force_enabled&#10;        )&#10;        self.kappa = kappa&#10;        self.rho_l = rho_l&#10;        self.rho_v = rho_v&#10;        self.gradient = Gradient(lattice)&#10;        self.laplacian = Laplacian(lattice)&#10;        self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)&#10;        self.a_eos = a_eos&#10;        self.b_eos = b_eos&#10;        self.R_eos = R_eos&#10;        self.T_eos = T_eos&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def __call__(&#10;        self, f: jnp.ndarray, force: jnp.ndarray = None&#10;    ) -&gt; tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:&#10;        &quot;&quot;&quot;&#10;        Calculate the macroscopic density and velocity fields from the population distribution.&#10;&#10;        Args:&#10;            f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)&#10;            force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)&#10;&#10;        Returns:&#10;            tuple: (rho, u_eq, force_total)&#10;                rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)&#10;                u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)&#10;                force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)&#10;        &quot;&quot;&quot;&#10;        rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction&#10;&#10;        # Calculate interaction force&#10;        force_int = self.force_int(rho)&#10;        # Total force calculation&#10;        if force is not None:&#10;            force_total = force + force_int&#10;        else:&#10;            force_total = force_int&#10;&#10;        u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction&#10;&#10;        return rho, u_eq, force_total&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def carnahan_starling_eos(self, rho):&#10;        &quot;&quot;&quot;Equation of state - extract 2D data for computation&quot;&quot;&quot;&#10;        rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)&#10;        # Julia formula:&#10;        # -(2*a_eos)*ρw[i,j] + R_eos*T_eos*(1 + log(ρw[i,j])) + ((16*R_eos*T_eos*(b_eos*ρw[i,j] -12))/((-4 + b_eos*ρw[i,j])^3))&#10;        eos_2d = (&#10;            -(2 * self.a_eos) * rho_2d&#10;            + self.R_eos * self.T_eos * (1 + jnp.log(rho_2d))&#10;            + (16 * self.R_eos * self.T_eos * (self.b_eos * rho_2d - 12))&#10;              / jnp.power((-4 + self.b_eos * rho_2d), 3)&#10;        )&#10;&#10;        # Convert back to 4D format&#10;        eos_4d = jnp.zeros_like(rho)&#10;        eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)&#10;        return eos_4d&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def chem_pot(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the chemical potential.&#10;        &quot;&quot;&quot;&#10;        mu_0 = self.carnahan_starling_eos(rho)&#10;        chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)&#10;        return chem_pot__&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def force_int(self, rho):&#10;        &quot;&quot;&quot;&#10;        Calculate the interaction force.&#10;        &quot;&quot;&quot;&#10;        grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)&#10;        # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)&#10;        return -rho * grad_chem_pot&#10;&#10;    @partial(jit, static_argnums=(0,))&#10;    def u_new(self, u, force):&#10;        &quot;&quot;&quot;&#10;        Update velocity with interaction force.&#10;        &quot;&quot;&quot;&#10;        # Both u and force have shape (nx, ny, 1, 2)&#10;        return u + force / 2" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/stream/stream_electrical.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/stream/stream_electrical.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Streaming operator for electrical distribution function h_i.&#10;This module provides the streaming step for the electric potential distribution.&#10;&quot;&quot;&quot;&#10;&#10;import jax.numpy as jnp&#10;from functools import partial&#10;from jax import jit&#10;&#10;&#10;@partial(jit)&#10;def stream_h_i(h_i: jnp.ndarray, c_i: jnp.ndarray) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Perform streaming step for electrical potential distribution h_i.&#10;    Uses periodic boundary conditions.&#10;    &#10;    Args:&#10;        h_i: Distribution function, shape (nx, ny, 9)&#10;        c_i: Lattice velocities, shape (9, 2)&#10;        &#10;    Returns:&#10;        Streamed distribution function, shape (nx, ny, 9)&#10;    &quot;&quot;&quot;&#10;    nx, ny, _ = h_i.shape&#10;    h_i_new = jnp.zeros_like(h_i)&#10;    &#10;    for i in range(9):&#10;        # Get velocity component for this direction&#10;        vx = c_i[i, 0]&#10;        vy = c_i[i, 1]&#10;        &#10;        # Periodic boundary conditions&#10;        x_indices = jnp.arange(nx)&#10;        y_indices = jnp.arange(ny)&#10;        &#10;        # Shift indices according to velocity&#10;        x_from = (x_indices - vx) % nx&#10;        y_from = (y_indices - vy) % ny&#10;        &#10;        # Stream: h_i at (x,y) comes from (x-vx, y-vy)&#10;        h_i_new = h_i_new.at[:, :, i].set(h_i[x_from[:, None], y_from[None, :], i])&#10;    &#10;    return h_i_new&#10;&#10;&#10;@partial(jit)&#10;def stream_h_i_vectorized(h_i: jnp.ndarray, c_i: jnp.ndarray) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Vectorized streaming step for electrical potential distribution h_i.&#10;    More efficient JAX implementation.&#10;    &#10;    Args:&#10;        h_i: Distribution function, shape (nx, ny, 9)&#10;        c_i: Lattice velocities, shape (9, 2)&#10;        &#10;    Returns:&#10;        Streamed distribution function, shape (nx, ny, 9)&#10;    &quot;&quot;&quot;&#10;    nx, ny, _ = h_i.shape&#10;    &#10;    # Create mesh grids for indices&#10;    x = jnp.arange(nx)&#10;    y = jnp.arange(ny)&#10;    xx, yy = jnp.meshgrid(x, y, indexing='ij')&#10;    &#10;    # Perform streaming for all 9 directions&#10;    def stream_one_direction(i):&#10;        vx = jnp.int32(c_i[i, 0])&#10;        vy = jnp.int32(c_i[i, 1])&#10;        &#10;        # Source indices with periodic boundary conditions&#10;        x_from = (xx - vx) % nx&#10;        y_from = (yy - vy) % ny&#10;        &#10;        return h_i[x_from, y_from, i]&#10;    &#10;    h_i_new = jnp.stack([stream_one_direction(i) for i in range(9)], axis=2)&#10;    &#10;    return h_i_new&#10;&#10;&#10;def apply_bounce_back_h_i(h_i: jnp.ndarray, mask: jnp.ndarray, &#10;                          boundary_value: float = 0.0) -&gt; jnp.ndarray:&#10;    &quot;&quot;&quot;&#10;    Apply bounce-back boundary conditions for h_i on solid surfaces.&#10;    &#10;    Args:&#10;        h_i: Distribution function, shape (nx, ny, 9)&#10;        mask: Boundary mask (True where boundary/solid), shape (nx, ny)&#10;        boundary_value: Potential value at boundary (default 0.0)&#10;        &#10;    Returns:&#10;        h_i with bounce-back applied&#10;    &quot;&quot;&quot;&#10;    # At boundaries, set h_i to equilibrium with boundary potential&#10;    h_i_new = h_i.copy()&#10;    &#10;    # For solid regions, enforce no-flux condition&#10;    # Bounce-back: h_i = h_i_opposite_direction&#10;    # This is typically handled by reversing the streaming direction&#10;    &#10;    return h_i_new&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wblbm/operators/wetting/differential_util.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>