/
    overview.py
    --- Code in overview.py ---
    import os
    
    
    def document_project(root_dir, output_file):
        with open(output_file, "w", encoding="utf-8") as doc:
            for dirpath, dirnames, filenames in os.walk(root_dir):
                # Remove hidden directories from dirnames in-place
                dirnames[:] = [d for d in dirnames if not d.startswith(".")]
                level = dirpath.replace(root_dir, "").count(os.sep)
                indent = "    " * level
                doc.write(f"{indent}{os.path.basename(dirpath)}/\n")
                subindent = "    " * (level + 1)
                for f in filenames:
                    if f.startswith("."):  # Skip hidden files as well (optional)
                        continue
                    file_path = os.path.join(dirpath, f)
                    doc.write(f"{subindent}{f}\n")
                    if f.endswith(".py"):
                        doc.write(f"{subindent}--- Code in {f} ---\n")
                        with open(file_path, "r", encoding="utf-8") as code_file:
                            for line in code_file:
                                doc.write(f"{subindent}{line}")
                        doc.write(f"{subindent}--- End of {f} ---\n\n")
    
    
    # Usage
    document_project("./", "./LBM_code_base.txt")
    --- End of overview.py ---

    LBM_code_base.txt
wblbm/
    __init__.py
    --- Code in __init__.py ---
    import wblbm.lattice
    import wblbm.grid
    from wblbm.operators.update import Update, UpdateMultiphase
    from wblbm.operators.initialise import Initialise
    from wblbm.operators.equilibrium import Equilibrium
    from wblbm.operators.stream import Streaming
    from wblbm.operators.macroscopic import Macroscopic, MacroscopicMultiphase
    from wblbm.operators.differential import (
        Gradient,
        Laplacian,
        GradientWetting,
        LaplacianWetting,
    )
    from wblbm.operators.collision import CollisionBGK, SourceTerm, CollisionMRT
    from wblbm.operators.boundary_condition import BoundaryCondition
    from wblbm.run import Run
    from wblbm.operators.force import (
        Force,
        GravityForceMultiphaseBubble,
        GravityForceMultiphaseDroplet,
        GravityForceSinglephase,
    )
    from wblbm.utils import (
        SimulationIO,
        visualise,
        JAXProfiler,
        time_function,
        TIMING_ENABLED,
    )
    from wblbm.lattice.lattice import Lattice
    from wblbm.grid.grid import Grid
    --- End of __init__.py ---

    operators/
        __init__.py
        --- Code in __init__.py ---
        --- End of __init__.py ---

        differential/
            gradient_wetting.py
            --- Code in gradient_wetting.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            from .abstract_wetting import AbstractWetting
            
            
            class GradientWetting(AbstractWetting):
                """
                Calculates gradients for wetting boundary conditions.
                """
            
                def __init__(
                    self, lattice: Lattice, rho_l=None, rho_v=None, interface_width: int = 1
                ):
                    super().__init__(lattice, rho_l, rho_v, interface_width=interface_width)
                    self.c = lattice.c
            
                def _compute_gradient(self, neighbors: dict, nx: int, ny: int) -> jnp.ndarray:
                    grad_ = jnp.zeros((2, nx, ny))
                    w = self.w
                    c = self.c
            
                    grad_ = grad_.at[0, :, :].set(
                        3
                        * (
                            w[1] * c[0, 1] * neighbors["ipos1_j0"]
                            + w[3] * c[0, 3] * neighbors["ineg1_j0"]
                            + w[5] * c[0, 5] * neighbors["ipos1_jpos1"]
                            + w[6] * c[0, 6] * neighbors["ineg1_jpos1"]
                            + w[7] * c[0, 7] * neighbors["ineg1_jneg1"]
                            + w[8] * c[0, 8] * neighbors["ipos1_jneg1"]
                        )
                    )
            
                    grad_ = grad_.at[1, :, :].set(
                        3
                        * (
                            w[2] * c[1, 2] * neighbors["i0_jpos1"]
                            + w[4] * c[1, 4] * neighbors["i0_jneg1"]
                            + w[5] * c[1, 5] * neighbors["ipos1_jpos1"]
                            + w[6] * c[1, 6] * neighbors["ineg1_jpos1"]
                            + w[7] * c[1, 7] * neighbors["ineg1_jneg1"]
                            + w[8] * c[1, 8] * neighbors["ipos1_jneg1"]
                        )
                    )
            
                    # Convert to 4D format: (nx, ny, 1, d)
                    grad_4d = jnp.zeros((nx, ny, 1, 2))
                    grad_4d = grad_4d.at[:, :, 0, 0].set(grad_[0, :, :])
                    grad_4d = grad_4d.at[:, :, 0, 1].set(grad_[1, :, :])
                    return grad_4d
            
                def gradient_chem_pot(self, grid: jnp.ndarray) -> jnp.ndarray:
                    """
                    Gradient for chemical potential with wetting boundary.
                    Args:
                        grid (jnp.ndarray): Input field, shape (nx, ny) or (nx, ny, 1, 1)
                    Returns:
                        jnp.ndarray: Gradient, shape (2, nx, ny)
                    """
                    # Extract 2D data from 4D input
                    if grid.ndim == 4:
                        grid_2d = grid[:, :, 0, 0]
                    else:
                        grid_2d = grid
                    edge = "bottom"
                    grid_padded = self._pad_grid(grid_2d, edge)
                    grid_padded = self._apply_wetting_boundary(grid_padded, edge)
                    neighbors = self._extract_neighbors(grid_padded)
                    return self._compute_gradient(neighbors, grid_2d.shape[0], grid_2d.shape[1])
            
                def __call__(
                    self, grid: jnp.ndarray, phi_left, phi_right, d_rho_left, d_rho_right
                ) -> jnp.ndarray:
                    """
                    Gradient for density with wetting boundary and CA masks.
                    Args:
                        grid (jnp.ndarray): Input field, shape (nx, ny) or (nx, ny, 1, 1)
                        phi_left, phi_right, d_rho_left, d_rho_right: wetting parameters
                    Returns:
                        jnp.ndarray: Gradient, shape (2, nx, ny)
                    """
                    # Extract 2D data from 4D input
                    if grid.ndim == 4:
                        grid_2d = grid[:, :, 0, 0]
                    else:
                        grid_2d = grid
                    edge = "bottom"
                    grid_padded = self._pad_grid(grid_2d, edge)
                    grid_padded = self._apply_wetting_boundary(grid_padded, edge)
                    grid_padded = self._apply_wetting_mask(
                        grid_padded, edge, phi_left, phi_right, d_rho_left, d_rho_right
                    )
                    neighbors = self._extract_neighbors(grid_padded)
                    return self._compute_gradient(neighbors, grid_2d.shape[0], grid_2d.shape[1])
            
                def compute(self, *args, **kwargs):
                    return (
                        self.__call__(*args, **kwargs)
                        if len(args) > 1
                        else self.gradient_chem_pot(*args, **kwargs)
                    )
            --- End of gradient_wetting.py ---

            gradient.py
            --- Code in gradient.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.lattice.lattice import Lattice
            
            
            class Gradient:
                """
                Callable class to calculate the gradient of a field using the provided stencil.
                """
            
                def __init__(self, lattice: Lattice):
                    self.w = lattice.w
                    self.c = lattice.c
            
                @partial(jit, static_argnums=(0,))
                def __call__(self, grid):
                    """
                    Calculate the gradient using the provided stencil.
            
                    Args:
                        grid (jnp.ndarray): Input field, shape (nx, ny, 1, 1)
            
                    Returns:
                        jnp.ndarray: Gradient, shape (nx, ny, 1, 2)
                    """
                    # Extract 2D data from 4D input
                    if grid.ndim == 4:
                        grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    else:
                        grid_2d = grid
            
                    w = self.w
                    c = self.c
            
                    grad_ = jnp.zeros((2, grid_2d.shape[0], grid_2d.shape[1]))
                    grid_padded = jnp.pad(grid_2d, pad_width=1, mode="wrap")
            
                    # Side nodes
                    grid_ineg1_j0 = grid_padded[:-2, 1:-1]
                    grid_ipos1_j0 = grid_padded[2:, 1:-1]
                    grid_i0_jneg1 = grid_padded[1:-1, :-2]
                    grid_i0_jpos1 = grid_padded[1:-1, 2:]
            
                    # Corner nodes
                    grid_ipos1_jpos1 = grid_padded[2:, 2:]
                    grid_ineg1_jpos1 = grid_padded[:-2, 2:]
                    grid_ineg1_jneg1 = grid_padded[:-2, :-2]
                    grid_ipos1_jneg1 = grid_padded[2:, :-2]
            
                    grad_ = grad_.at[0, :, :].set(
                        3
                        * (
                            w[1] * c[0, 1] * grid_ipos1_j0
                            + w[3] * c[0, 3] * grid_ineg1_j0
                            + w[5] * c[0, 5] * grid_ipos1_jpos1
                            + w[6] * c[0, 6] * grid_ineg1_jpos1
                            + w[7] * c[0, 7] * grid_ineg1_jneg1
                            + w[8] * c[0, 8] * grid_ipos1_jneg1
                        )
                    )
            
                    grad_ = grad_.at[1, :, :].set(
                        3
                        * (
                            w[2] * c[1, 2] * grid_i0_jpos1
                            + w[4] * c[1, 4] * grid_i0_jneg1
                            + w[5] * c[1, 5] * grid_ipos1_jpos1
                            + w[6] * c[1, 6] * grid_ineg1_jpos1
                            + w[7] * c[1, 7] * grid_ineg1_jneg1
                            + w[8] * c[1, 8] * grid_ipos1_jneg1
                        )
                    )
            
                    # Convert to 4D format: (nx, ny, 1, 2)
                    grad_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 2))
                    grad_4d = grad_4d.at[:, :, 0, 0].set(grad_[0, :, :])
                    grad_4d = grad_4d.at[:, :, 0, 1].set(grad_[1, :, :])
            
                    return grad_4d
            --- End of gradient.py ---

            __init__.py
            --- Code in __init__.py ---
            from .gradient import Gradient
            from .laplacian import Laplacian
            from .gradient_wetting import GradientWetting
            from .laplacian_wetting import LaplacianWetting
            --- End of __init__.py ---

            laplacian.py
            --- Code in laplacian.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.lattice.lattice import Lattice
            
            
            class Laplacian:
                """
                Callable class to calculate the Laplacian of a 2D grid using the LBM stencil.
                """
            
                def __init__(self, lattice: Lattice):
                    self.w = lattice.w
            
                @partial(jit, static_argnums=(0,))
                def __call__(self, grid):
                    """
                    Calculate the Laplacian of a 2D grid.
            
                    Args:
                        grid (jnp.ndarray): Input grid, shape (nx, ny, 1, 1)
            
                    Returns:
                        jnp.ndarray: Laplacian of the input grid, shape (nx, ny, 1, 1)
                    """
                    # Extract 2D data from 4D input
                    if grid.ndim == 4:
                        grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    else:
                        grid_2d = grid
            
                    w = self.w
            
                    laplacian_2d = jnp.zeros_like(grid_2d)
                    grid_padded = jnp.pad(grid_2d, pad_width=1, mode="wrap")
            
                    # Side nodes
                    grid_ineg1_j0 = grid_padded[:-2, 1:-1]
                    grid_ipos1_j0 = grid_padded[2:, 1:-1]
                    grid_i0_jneg1 = grid_padded[1:-1, :-2]
                    grid_i0_jpos1 = grid_padded[1:-1, 2:]
            
                    # Corner nodes
                    grid_ipos1_jpos1 = grid_padded[2:, 2:]
                    grid_ineg1_jpos1 = grid_padded[:-2, 2:]
                    grid_ineg1_jneg1 = grid_padded[:-2, :-2]
                    grid_ipos1_jneg1 = grid_padded[2:, :-2]
            
                    # Central node
                    grid_i0_j0 = grid_padded[1:-1, 1:-1]
            
                    laplacian_2d = laplacian_2d.at[:, :].set(
                        6
                        * (
                            w[1] * (grid_ipos1_j0 - grid_i0_j0)
                            + w[2] * (grid_i0_jpos1 - grid_i0_j0)
                            + w[3] * (grid_ineg1_j0 - grid_i0_j0)
                            + w[4] * (grid_i0_jneg1 - grid_i0_j0)
                            + w[5] * (grid_ipos1_jpos1 - grid_i0_j0)
                            + w[6] * (grid_ineg1_jpos1 - grid_i0_j0)
                            + w[7] * (grid_ineg1_jneg1 - grid_i0_j0)
                            + w[8] * (grid_ipos1_jneg1 - grid_i0_j0)
                        )
                    )
            
                    # Convert to 4D format: (nx, ny, 1, 1)
                    laplacian_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 1))
                    laplacian_4d = laplacian_4d.at[:, :, 0, 0].set(laplacian_2d)
            
                    return laplacian_4d
            --- End of laplacian.py ---

            abstract_wetting.py
            --- Code in abstract_wetting.py ---
            import jax.numpy as jnp
            from abc import ABC, abstractmethod
            from typing import Dict
            from wblbm.lattice.lattice import Lattice
            
            
            class AbstractWetting(ABC):
                """
                Abstract base class for wetting boundary condition calculations.
                Supports selectable edges via wetting_config.
                """
            
                def __init__(
                    self,
                    lattice: Lattice,
                    rho_l=None,
                    rho_v=None,
                    wetting_config: Dict[str, str] = None,
                    interface_width: int = 4,
                ):
                    self.w = lattice.w
                    self.interface_width = interface_width
                    self.c = getattr(lattice, "c", None)
                    self.rho_l = rho_l
                    self.rho_v = rho_v
                    self.wetting_config = wetting_config or {"bottom": "wetting"}
                    valid_edges = ["top", "bottom", "left", "right"]
                    valid_types = ["wetting"]
                    for edge, wc_type in self.wetting_config.items():
                        if edge not in valid_edges:
                            raise ValueError(f"Invalid edge: {edge}. Must be one of {valid_edges}.")
                        if wc_type not in valid_types:
                            raise ValueError(
                                f"Invalid wetting type: {wc_type}. Must be one of {valid_types}."
                            )
            
                def apply_wetting(
                    self, grid: jnp.ndarray, phi_left, phi_right, d_rho_left, d_rho_right
                ) -> jnp.ndarray:
                    """
                    Apply wetting boundary conditions to all configured edges.
                    """
                    for edge, wc_type in self.wetting_config.items():
                        if wc_type == "wetting":
                            grid = self._apply_wetting_to_edge(
                                grid, edge, phi_left, phi_right, d_rho_left, d_rho_right
                            )
                    return grid
            
                def _pad_grid(self, grid: jnp.ndarray, edge: str) -> jnp.ndarray:
            
                    return jnp.pad(grid, pad_width=1, mode="edge")
            
                def _apply_wetting_boundary(
                    self, grid_padded: jnp.ndarray, edge: str
                ) -> jnp.ndarray:
                    # Generalize for each edge
                    if edge == "bottom":
                        grid_padded = grid_padded.at[1:-1, 0].set(
                            (
                                1 / 3 * grid_padded[1:-1, 1]
                                + 1 / 12 * grid_padded[0:-2, 1]
                                + 1 / 12 * grid_padded[2:, 1]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                        grid_padded = grid_padded.at[0, 0].set(
                            (
                                1 / 3 * grid_padded[0, 1]
                                + 1 / 12 * grid_padded[-1, 1]
                                + 1 / 12 * grid_padded[1, 1]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                        grid_padded = grid_padded.at[-1, 0].set(
                            (
                                1 / 3 * grid_padded[-1, 1]
                                + 1 / 12 * grid_padded[0, 1]
                                + 1 / 12 * grid_padded[-2, 1]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                    elif edge == "top":
                        grid_padded = grid_padded.at[1:-1, -1].set(
                            (
                                1 / 3 * grid_padded[1:-1, -2]
                                + 1 / 12 * grid_padded[0:-2, -2]
                                + 1 / 12 * grid_padded[2:, -2]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                        grid_padded = grid_padded.at[0, -1].set(
                            (
                                1 / 3 * grid_padded[0, -2]
                                + 1 / 12 * grid_padded[-1, -2]
                                + 1 / 12 * grid_padded[1, -2]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                        grid_padded = grid_padded.at[-1, -1].set(
                            (
                                1 / 3 * grid_padded[-1, -2]
                                + 1 / 12 * grid_padded[0, -2]
                                + 1 / 12 * grid_padded[-2, -2]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                    elif edge == "left":
                        grid_padded = grid_padded.at[0, 1:-1].set(
                            (
                                1 / 3 * grid_padded[1, 1:-1]
                                + 1 / 12 * grid_padded[1, 0:-2]
                                + 1 / 12 * grid_padded[1, 2:]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                        grid_padded = grid_padded.at[0, 0].set(
                            (
                                1 / 3 * grid_padded[1, 0]
                                + 1 / 12 * grid_padded[1, -1]
                                + 1 / 12 * grid_padded[1, 1]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                        grid_padded = grid_padded.at[0, -1].set(
                            (
                                1 / 3 * grid_padded[1, -1]
                                + 1 / 12 * grid_padded[1, 0]
                                + 1 / 12 * grid_padded[1, -2]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                    elif edge == "right":
                        grid_padded = grid_padded.at[-1, 1:-1].set(
                            (
                                1 / 3 * grid_padded[-2, 1:-1]
                                + 1 / 12 * grid_padded[-2, 0:-2]
                                + 1 / 12 * grid_padded[-2, 2:]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                        grid_padded = grid_padded.at[-1, 0].set(
                            (
                                1 / 3 * grid_padded[-2, 0]
                                + 1 / 12 * grid_padded[-2, -1]
                                + 1 / 12 * grid_padded[-2, 1]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                        grid_padded = grid_padded.at[-1, -1].set(
                            (
                                1 / 3 * grid_padded[-2, -1]
                                + 1 / 12 * grid_padded[-2, 0]
                                + 1 / 12 * grid_padded[-2, -2]
                            )
                            / (1 / 3 + 1 / 12 + 1 / 12)
                        )
                    return grid_padded
            
                def _apply_wetting_mask(
                    self,
                    grid_padded: jnp.ndarray,
                    edge: str,
                    phi_left,
                    phi_right,
                    d_rho_left,
                    d_rho_right,
                ) -> jnp.ndarray:
                    rho_l = self.rho_l
                    rho_v = self.rho_v
                    # Select boundary slice based on edge
                    if edge == "bottom":
                        boundary_slice = grid_padded[1:-1, 0]
                    elif edge == "top":
                        boundary_slice = grid_padded[1:-1, -1]
                    elif edge == "left":
                        boundary_slice = grid_padded[0, 1:-1]
                    elif edge == "right":
                        boundary_slice = grid_padded[-1, 1:-1]
                    else:
                        raise ValueError(f"Unknown edge: {edge}")
            
                    # --- Fix: If any wetting parameter is None, skip mask logic and return grid_padded unchanged ---
                    if (
                        phi_left is None
                        or phi_right is None
                        or d_rho_left is None
                        or d_rho_right is None
                    ):
                        return grid_padded
            
                    mask1 = boundary_slice < (0.95 * rho_l + 0.05 * rho_v)
                    mask2 = boundary_slice > (0.95 * rho_v + 0.05 * rho_l)
                    mask_final = mask1 * mask2
            
                    mask1_int = jnp.array(mask1, dtype=int)
                    diff_mask1 = jnp.diff(mask1_int)
            
                    # --- Fix: use self.interface_width instead of self.w ---
                    transition_index_left_mask1 = (
                        jnp.where(diff_mask1 == -1, size=1, fill_value=0)[0]
                        + 2 * self.interface_width
                    )
                    transition_index_right_mask1 = jnp.where(diff_mask1 == 1, size=1, fill_value=0)[
                        0
                    ] - (2 * self.interface_width + 1)
            
                    indices = jnp.arange(mask_final.shape[0])
                    mask_cover_left = jnp.where(
                        indices >= transition_index_right_mask1[0], False, mask_final
                    )
                    mask_cover_right = jnp.where(
                        indices <= transition_index_left_mask1[0], False, mask_final
                    )
            
                    new_values_left = jnp.minimum(
                        jnp.maximum(
                            (phi_left * boundary_slice) - d_rho_left,
                            0.95 * rho_v + 0.05 * rho_l,
                        ),
                        0.95 * rho_l + 0.05 * rho_v,
                    )
            
                    new_values_right = jnp.minimum(
                        jnp.maximum(
                            (phi_right * boundary_slice) - d_rho_right,
                            0.95 * rho_v + 0.05 * rho_l,
                        ),
                        0.95 * rho_l + 0.05 * rho_v,
                    )
            
                    updated_slice = jnp.where(mask_cover_left, new_values_left, boundary_slice)
                    updated_slice = jnp.where(mask_cover_right, new_values_right, updated_slice)
            
                    # Set back to grid_padded
                    if edge == "bottom":
                        grid_padded = grid_padded.at[1:-1, 0].set(updated_slice)
                    elif edge == "top":
                        grid_padded = grid_padded.at[1:-1, -1].set(updated_slice)
                    elif edge == "left":
                        grid_padded = grid_padded.at[0, 1:-1].set(updated_slice)
                    elif edge == "right":
                        grid_padded = grid_padded.at[-1, 1:-1].set(updated_slice)
                    return grid_padded
            
                def _apply_wetting_to_edge(
                    self, grid: jnp.ndarray, edge: str, phi_left, phi_right, d_rho_left, d_rho_right
                ) -> jnp.ndarray:
                    grid_padded = self._pad_grid(grid, edge)
                    grid_padded = self._apply_wetting_boundary(grid_padded, edge)
                    grid_padded = self._apply_wetting_mask(
                        grid_padded, edge, phi_left, phi_right, d_rho_left, d_rho_right
                    )
                    # Unflip if needed
                    if edge == "top":
                        grid_padded = jnp.flip(grid_padded, axis=1)
                    elif edge == "right":
                        grid_padded = jnp.flip(grid_padded, axis=0)
                    # Unpad
                    grid = grid_padded[1:-1, 1:-1]
                    return grid
            
                def _extract_neighbors(self, grid_padded: jnp.ndarray) -> dict:
                    """
                    Extract neighbor slices for finite difference stencils.
                    """
                    return {
                        "ineg1_j0": grid_padded[:-2, 1:-1],
                        "ipos1_j0": grid_padded[2:, 1:-1],
                        "i0_jneg1": grid_padded[1:-1, :-2],
                        "i0_jpos1": grid_padded[1:-1, 2:],
                        "ipos1_jpos1": grid_padded[2:, 2:],
                        "ineg1_jpos1": grid_padded[:-2, 2:],
                        "ineg1_jneg1": grid_padded[:-2, :-2],
                        "ipos1_jneg1": grid_padded[2:, :-2],
                        "i0_j0": grid_padded[1:-1, 1:-1],
                    }
            
                @abstractmethod
                def compute(self, *args, **kwargs):
                    pass
            --- End of abstract_wetting.py ---

            laplacian_wetting.py
            --- Code in laplacian_wetting.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            from .abstract_wetting import AbstractWetting
            
            
            class LaplacianWetting(AbstractWetting):
                """
                Callable class to calculate the Laplacian of a 2D grid with wetting boundary conditions.
                """
            
                def __init__(
                    self, lattice: Lattice, rho_l=None, rho_v=None, interface_width: int = 1
                ):
                    super().__init__(lattice, rho_l, rho_v, interface_width=interface_width)
            
                def __call__(self, grid, phi_left, phi_right, d_rho_left, d_rho_right):
                    if grid.ndim == 4:
                        grid_2d = grid[:, :, 0, 0]
                    else:
                        grid_2d = grid
            
                    edge = "bottom"
                    grid_padded = self._pad_grid(grid_2d, edge)
                    grid_padded = self._apply_wetting_boundary(grid_padded, edge)
                    grid_padded = self._apply_wetting_mask(
                        grid_padded, edge, phi_left, phi_right, d_rho_left, d_rho_right
                    )
            
                    w = self.w
                    neighbors = self._extract_neighbors(grid_padded)
            
                    laplacian_2d = jnp.zeros_like(grid_2d)
                    laplacian_2d = laplacian_2d.at[:, :].set(
                        6
                        * (
                            w[1] * (neighbors["ipos1_j0"] - neighbors["i0_j0"])
                            + w[2] * (neighbors["i0_jpos1"] - neighbors["i0_j0"])
                            + w[3] * (neighbors["ineg1_j0"] - neighbors["i0_j0"])
                            + w[4] * (neighbors["i0_jneg1"] - neighbors["i0_j0"])
                            + w[5] * (neighbors["ipos1_jpos1"] - neighbors["i0_j0"])
                            + w[6] * (neighbors["ineg1_jpos1"] - neighbors["i0_j0"])
                            + w[7] * (neighbors["ineg1_jneg1"] - neighbors["i0_j0"])
                            + w[8] * (neighbors["ipos1_jneg1"] - neighbors["i0_j0"])
                        )
                    )
            
                    # Convert to 4D format: (nx, ny, 1, 1)
                    laplacian_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 1))
                    laplacian_4d = laplacian_4d.at[:, :, 0, 0].set(laplacian_2d)
                    return laplacian_4d
            
                def compute(self, *args, **kwargs):
                    return self.__call__(*args, **kwargs)
            --- End of laplacian_wetting.py ---

            __pycache__/
                abstract_wetting.cpython-312.pyc
                gradient_wetting.cpython-312.pyc
                laplacian_wetting.cpython-312.pyc
                laplacian.cpython-312.pyc
                gradient.cpython-312.pyc
                __init__.cpython-312.pyc
        macroscopic/
            macroscopic.py
            --- Code in macroscopic.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit, Array
            
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from typing import Tuple
            from wblbm.operators.differential.gradient import Gradient
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            
            class Macroscopic:
                """
                Calculates the macroscopic density and velocity fields from the population distribution.
                """
            
                def __init__(
                    self, grid: Grid, lattice: Lattice, force_enabled: bool = False
                ) -> None:
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.cx: jnp.ndarray = jnp.array(lattice.c[0])
                    self.cy: jnp.ndarray = jnp.array(lattice.c[1])
                    self.gradient = Gradient(lattice)
                    self.force_enabled = force_enabled
            
                @time_function(enable_timing=TIMING_ENABLED)
                @partial(jit, static_argnums=(0,))
                def __call__(
                    self, f: jnp.ndarray, force: jnp.ndarray = None
                ) -> tuple[Array, Array, Array] | tuple[Array, Array]:
                    """
                    Args:
                        f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)
                        force (jnp.ndarray, optional): Force field, shape (nx, ny, 1, 2). Required if force_enabled is True.
            
                    Returns:
                        tuple: (rho, u)
                            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                            u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                    """
                    if self.d == 2:
                        # Compute density
                        rho = jnp.sum(f, axis=2, keepdims=True)  # (nx, ny, 1, 1)
            
                        # Compute velocity WITHOUT force correction
                        cx = self.cx.reshape((1, 1, self.q, 1))
                        cy = self.cy.reshape((1, 1, self.q, 1))
                        ux = jnp.sum(f * cx, axis=2, keepdims=True)
                        uy = jnp.sum(f * cy, axis=2, keepdims=True)
                        u = jnp.concatenate([ux, uy], axis=-1) / rho  # (nx, ny, 1, 2)
            
                        if force is not None:
                            u_eq = u + force / (2 * rho)
                            return rho, u_eq, force
                        if force is None:
                            return rho, u
                    elif self.d == 3:
                        raise NotImplementedError("Dimension larger than 2 not supported.")
            --- End of macroscopic.py ---

            __init__.py
            --- Code in __init__.py ---
            from .macroscopic import Macroscopic
            from .macroscopic_multiphase import MacroscopicMultiphase
            --- End of __init__.py ---

            macroscopic_multiphase.py
            --- Code in macroscopic_multiphase.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid import Grid
            from wblbm.operators.macroscopic.macroscopic import Macroscopic
            from wblbm.operators.differential.gradient import Gradient
            from wblbm.operators.differential.laplacian import Laplacian
            from wblbm.lattice.lattice import Lattice
            
            
            class MacroscopicMultiphase(Macroscopic):
                """
                Calculates macroscopic variables for multiphase simulations.
                Inherits from Macroscopic and adds multiphase-specific methods.
                """
            
                def __init__(
                    self,
                    grid: Grid,
                    lattice: Lattice,
                    kappa: float,
                    interface_width: int,
                    rho_l: float,
                    rho_v: float,
                    force_enabled: bool = False,
                ):
                    super().__init__(
                        grid, lattice, force_enabled=force_enabled
                    )  # Pass force_enabled to parent
                    self.kappa = kappa
                    self.rho_l = rho_l
                    self.rho_v = rho_v
                    self.gradient = Gradient(lattice)
                    self.laplacian = Laplacian(lattice)
                    self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)
            
                @partial(jit, static_argnums=(0,))
                def __call__(
                    self, f: jnp.ndarray, force: jnp.ndarray = None
                ) -> tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
                    """
                    Calculate the macroscopic density and velocity fields from the population distribution.
            
                    Args:
                        f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)
                        force (jnp.ndarray, optional): External force field, shape (nx, ny, 1, 2)
            
                    Returns:
                        tuple: (rho, u_eq, force_total)
                            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                            u_eq (jnp.ndarray): Force-corrected velocity for equilibrium, shape (nx, ny, 1, 2)
                            force_total (jnp.ndarray): Total force (interaction + external), shape (nx, ny, 1, 2)
                    """
                    # Get raw macroscopic variables (no force correction)
                    rho, u = super().__call__(f, force=None)  # Pass None to avoid any correction
            
                    # Calculate interaction force
                    force_int = self.force_int(rho)
                    # Total force for equilibrium calculation
                    if force is not None:
                        force_total = force + force_int
                    else:
                        force_total = force_int
            
                    # Correct velocity ONLY for equilibrium calculation
                    u_eq = u + force_total / (2 * rho)  # divide by rho for proper correction
            
                    return rho, u_eq, force_total
            
                @partial(jit, static_argnums=(0,))
                def eos(self, rho):
                    """Equation of state - extract 2D data for computation"""
                    rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    eos_2d = (
                        2
                        * self.beta
                        * (rho_2d - self.rho_l)
                        * (rho_2d - self.rho_v)
                        * (2 * rho_2d - self.rho_l - self.rho_v)
                    )
            
                    # Convert back to 4D format
                    eos_4d = jnp.zeros_like(rho)
                    eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)
                    return eos_4d
            
                @partial(jit, static_argnums=(0,))
                def chem_pot(self, rho):
                    """
                    Calculate the chemical potential.
                    """
                    mu_0 = self.eos(rho)
                    chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)
                    return chem_pot__
            
                @partial(jit, static_argnums=(0,))
                def force_int(self, rho):
                    """
                    Calculate the interaction force.
                    """
                    grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)
                    # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)
                    return -rho * grad_chem_pot
            
                @partial(jit, static_argnums=(0,))
                def u_new(self, u, force):
                    """
                    Update velocity with interaction force.
                    """
                    # Both u and force have shape (nx, ny, 1, 2)
                    return u + force / 2
            --- End of macroscopic_multiphase.py ---

            macroscopic_multiphase_wetting.py
            --- Code in macroscopic_multiphase_wetting.py ---
            from functools import partial
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.macroscopic.macroscopic import Macroscopic
            from wblbm.operators.differential.gradient_wetting import GradientWetting
            from wblbm.operators.differential.laplacian_wetting import LaplacianWetting
            
            
            class MacroscopicWetting(Macroscopic):
                """
                Calculates macroscopic variables for wetting-aware multiphase simulations.
                Uses wetting-specific differential operators for gradient and Laplacian.
                """
            
                def __init__(
                    self,
                    grid: Grid,
                    lattice: Lattice,
                    kappa: float,
                    interface_width: int,
                    rho_l: float,
                    rho_v: float,
                    force_enabled: bool = False,
                    wetting_enabled: bool = False,  # Flag to enable wetting-specific operators
                ):
                    super().__init__(grid, lattice, force_enabled)
                    self.kappa = kappa
                    self.rho_l = rho_l
                    self.rho_v = rho_v
                    self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)
                    self.gradient = GradientWetting(
                        lattice, rho_l, rho_v, interface_width=interface_width
                    )
                    self.laplacian = LaplacianWetting(
                        lattice, rho_l, rho_v, interface_width=interface_width
                    )
                    self.wetting_enabled = wetting_enabled
            
                @partial(jit, static_argnums=(0,))
                def __call__(
                    self,
                    f: jnp.ndarray,
                    force: jnp.ndarray = None,
                    phi_left: jnp.ndarray = None,
                    phi_right: jnp.ndarray = None,
                    d_rho_left: jnp.ndarray = None,
                    d_rho_right: jnp.ndarray = None,
                ) -> tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
                    rho, u = super().__call__(f, force=force)
                    force_int = self.force_int(rho, phi_left, phi_right, d_rho_left, d_rho_right)
                    u_updated = self.u_new(u, force_int)
                    if force is None:
                        force_total = force_int
                    else:
                        force_total = force_int + force
                    return rho, u_updated, force_total
            
                @partial(jit, static_argnums=(0,))
                def chem_pot(
                    self,
                    rho,
                    phi_left=None,
                    phi_right=None,
                    d_rho_left=None,
                    d_rho_right=None,
                ):
                    mu_0 = self.eos(rho)
                    if self.wetting_enabled:
                        chem_pot__ = mu_0 - self.kappa * self.laplacian(
                            rho, phi_left, phi_right, d_rho_left, d_rho_right
                        )
                    else:
                        raise ValueError(
                            "When using the MacroscopicWetting class wetting must be enabled."
                        )
                    return chem_pot__
            
                @partial(jit, static_argnums=(0,))
                def force_int(
                    self,
                    rho,
                    phi_left=None,
                    phi_right=None,
                    d_rho_left=None,
                    d_rho_right=None,
                ):
                    if self.wetting_enabled:
                        grad_chem_pot = self.gradient(
                            self.chem_pot(rho, phi_left, phi_right, d_rho_left, d_rho_right),
                            phi_left,
                            phi_right,
                            d_rho_left,
                            d_rho_right,
                        )
                    else:
                        raise ValueError(
                            "When using the MacroscopicWetting class wetting must be enabled."
                        )
                    return -rho * grad_chem_pot
            
                @partial(jit, static_argnums=(0,))
                def u_new(self, u, force):
                    """
                    Update velocity with interaction force.
                    """
                    # Both u and force have shape (nx, ny, 1, 2)
                    return u + force / 2
            
                @partial(jit, static_argnums=(0,))
                def eos(self, rho):
                    """Equation of state - extract 2D data for computation"""
                    rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    eos_2d = (
                        2
                        * self.beta
                        * (rho_2d - self.rho_l)
                        * (rho_2d - self.rho_v)
                        * (2 * rho_2d - self.rho_l - self.rho_v)
                    )
            
                    # Convert back to 4D format
                    eos_4d = jnp.zeros_like(rho)
                    eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)
                    return eos_4d
            --- End of macroscopic_multiphase_wetting.py ---

            __pycache__/
                macroscopic_multiphase.cpython-312.pyc
                __init__.cpython-312.pyc
                macroscopic.cpython-312.pyc
        update/
            update.py
            --- Code in update.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.boundary_condition.boundary_condition import BoundaryCondition
            from wblbm.operators.collision import CollisionBGK, CollisionMRT, SourceTerm
            from wblbm.operators.equilibrium.equilibrium import Equilibrium
            from wblbm.operators.macroscopic.macroscopic import Macroscopic
            from wblbm.operators.stream import Streaming
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            
            class Update(object):
                def __init__(
                    self,
                    grid: Grid,
                    lattice: Lattice,
                    tau: float,
                    bc_config: dict = None,
                    force_enabled: bool = False,
                    collision_scheme: str = "bgk",
                    kvec=None,
                ):
                    self.grid = grid
                    self.lattice = lattice
                    self.tau = tau
                    self.macroscopic = Macroscopic(grid, lattice, force_enabled=force_enabled)
                    self.equilibrium = Equilibrium(grid, lattice)
                    # Select collision scheme
                    if collision_scheme == "mrt":
                        self.collision = CollisionMRT(grid, lattice, k_diag=kvec)
                    else:
                        self.collision = CollisionBGK(grid, lattice, tau)
                    self.source_term = SourceTerm(grid, lattice)
                    self.streaming = Streaming(lattice)
                    if bc_config is not None:
                        self.boundary_condition = BoundaryCondition(grid, lattice, bc_config)
                    else:
                        self.boundary_condition = None
                    self.force_enabled = force_enabled
            
                @partial(jit, static_argnums=(0,))
                @time_function(enable_timing=TIMING_ENABLED)
                def __call__(self, f: jnp.ndarray, force: jnp.ndarray = None):
                    if self.force_enabled:
                        rho, u, force_tot = self.macroscopic(f, force=force)
                    else:
                        rho, u = self.macroscopic(f)
                    feq = self.equilibrium(rho, u)
                    fcol = self.collision(f, feq)
                    fstream = self.streaming(fcol)
                    if self.boundary_condition is not None:
                        fbc = self.boundary_condition(fstream, fcol)
                        return fbc
                    else:
                        return fstream
            --- End of update.py ---

            update_multiphase_wetting.py
            --- Code in update_multiphase_wetting.py ---
            from functools import partial
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision.collision_BGK import CollisionBGK
            from wblbm.operators.collision.collision_MRT import CollisionMRT
            from wblbm.operators.update.update import Update
            from wblbm.operators.macroscopic.macroscopic_multiphase_wetting import (
                MacroscopicWetting,
            )
            from wblbm.operators.boundary_condition.boundary_condition import BoundaryCondition
            
            
            class UpdateMultiphaseWetting(Update):
                def __init__(
                    self,
                    grid: Grid,
                    lattice: Lattice,
                    tau: float,
                    kappa: float,
                    interface_width: int,
                    rho_l: float,
                    rho_v: float,
                    bc_config: dict = None,
                    force_enabled: bool = False,
                    wetting_enabled: bool = True,
                    collision_scheme: str = "bgk",
                    kvec=None,
                ):
                    super().__init__(grid, lattice, tau, bc_config, force_enabled=force_enabled, collision_scheme=collision_scheme, kvec=kvec)
                    self.macroscopic = MacroscopicWetting(
                        grid,
                        lattice,
                        kappa,
                        interface_width,
                        rho_l,
                        rho_v,
                        force_enabled=force_enabled,
                        wetting_enabled=wetting_enabled,
                    )
                    self.wetting_enabled = wetting_enabled
            
                @partial(jit, static_argnums=(0,))
                def __call__(
                    self,
                    f: jnp.array,
                    force: jnp.ndarray = None,
                    phi_left: jnp.ndarray = None,
                    phi_right: jnp.ndarray = None,
                    d_rho_left: jnp.ndarray = None,
                    d_rho_right: jnp.ndarray = None,
                ):
            
                    if self.force_enabled and force is None:
                        raise TypeError(
                            "When the force is enabled an external force needs to be provided"
                        )
                    elif self.force_enabled:
                        rho, u, force_tot = self.macroscopic(
                            f,
                            force=force,
                            phi_left=phi_left,
                            phi_right=phi_right,
                            d_rho_left=d_rho_left,
                            d_rho_right=d_rho_right,
                        )
                    else:
                        rho, u, force_tot = self.macroscopic(
                            f,
                            phi_left=phi_left,
                            phi_right=phi_right,
                            d_rho_left=d_rho_left,
                            d_rho_right=d_rho_right,
                        )  # In this case the total force is only the interaction force
            
                    feq = self.equilibrium(rho, u)
                    source = self.source_term(rho, u, force_tot)
                    fcol = self.collision(f, feq, source)
                    fstream = self.streaming(fcol)
                    if self.boundary_condition is not None:
                        fbc = self.boundary_condition(fstream, fcol)
                        return fbc
                    else:
                        return fstream
            --- End of update_multiphase_wetting.py ---

            __init__.py
            --- Code in __init__.py ---
            from .update import Update
            from .update_multiphase import UpdateMultiphase
            --- End of __init__.py ---

            update_multiphase.py
            --- Code in update_multiphase.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision.collision_BGK import CollisionBGK
            from wblbm.operators.collision.collision_MRT import CollisionMRT
            from wblbm.operators.update.update import Update
            from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
            from wblbm.operators.boundary_condition.boundary_condition import BoundaryCondition
            
            
            class UpdateMultiphase(Update):
                def __init__(
                    self,
                    grid: Grid,
                    lattice: Lattice,
                    tau: float,
                    kappa: float,
                    interface_width: int,
                    rho_l: float,
                    rho_v: float,
                    bc_config: dict = None,
                    force_enabled: bool = False,
                    collision_scheme: str = "bgk",
                    kvec=None,
                ):
                    super().__init__(grid, lattice, tau, bc_config, force_enabled=force_enabled, collision_scheme=collision_scheme, kvec=kvec)
                    self.macroscopic = MacroscopicMultiphase(
                        grid,
                        lattice,
                        kappa,
                        interface_width,
                        rho_l,
                        rho_v,
                        force_enabled=force_enabled,
                    )
            
                @partial(jit, static_argnums=(0,))
                def __call__(self, f: jnp.array, force: jnp.ndarray = None):
                    # If force_enabled and no force provided, use a simple constant force for testing
                    if self.force_enabled and force is None:
                        raise TypeError(
                            "When the force is enabled an external force needs to be provided"
                        )
                    elif self.force_enabled:
                        rho, u, force_tot = self.macroscopic(f, force=force)
                    else:
                        rho, u, force_tot = self.macroscopic(
                            f
                        )  # In this case the total force is only the interaction force
                    feq = self.equilibrium(rho, u)
                    source = self.source_term(rho, u, force_tot)
                    fcol = self.collision(f, feq, source)
                    fstream = self.streaming(fcol)
                    if self.boundary_condition is not None:
                        fbc = self.boundary_condition(fstream, fcol)
                        return fbc
                    else:
                        return fstream
            --- End of update_multiphase.py ---

            __pycache__/
                update_multiphase.cpython-312.pyc
                update.cpython-312.pyc
                __init__.cpython-312.pyc
        stream/
            __init__.py
            --- Code in __init__.py ---
            from .stream import Streaming
            --- End of __init__.py ---

            stream.py
            --- Code in stream.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            
            class Streaming:
                """
                Callable class to perform the streaming step of the LBM.
                """
            
                def __init__(self, lattice: Lattice):
                    self.c = lattice.c  # Shape: (2, Q)
                    self.q = lattice.q
            
                @time_function(enable_timing=TIMING_ENABLED)
                def __call__(self, f):
                    """
                    Perform the streaming step of the LBM.
            
                    Args:
                        f (jnp.ndarray): Distribution function, shape (nx, ny, q, 1)
            
                    Returns:
                        jnp.ndarray: Post-streaming distribution function.
                    """
                    for i in range(self.q):
                        f = f.at[:, :, i, 0].set(
                            jnp.roll(
                                jnp.roll(f[:, :, i, 0], self.c[0, i], axis=0), self.c[1, i], axis=1
                            )
                        )
                    return f
            --- End of stream.py ---

            __pycache__/
                stream.cpython-312.pyc
                __init__.cpython-312.pyc
        initialise/
            __init__.py
            --- Code in __init__.py ---
            from .init import Initialise
            --- End of __init__.py ---

            init.py
            --- Code in init.py ---
            import jax.numpy as jnp
            import numpy as np
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.operators.equilibrium.equilibrium import Equilibrium
            
            
            class Initialise:
                """
                Handles the initialisation of the simulation for various scenarios.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice):
                    self.grid = grid
                    self.lattice = lattice
                    self.nx, self.ny = grid.nx, grid.ny
                    self.q = self.lattice.q
                    self.equilibrium = Equilibrium(self.grid, self.lattice)
            
                def initialise_standard(
                    self, density: float = 1.0, velocity: np.ndarray = np.array([0.0, 0.0])
                ):
                    """
                    Initialises a standard simulation with uniform density and velocity.
            
                    Args:
                        density (float): Initial uniform density.
                        velocity (np.ndarray): Initial uniform velocity [ux, uy].
            
                    Returns:
                        jnp.ndarray: Initialised population distribution f.
                    """
                    # Create density and velocity fields with the correct 4D shape
                    rho = jnp.full((self.nx, self.ny, 1, 1), density)
            
                    u = jnp.broadcast_to(
                        jnp.array(velocity).reshape(1, 1, 1, 2), (self.nx, self.ny, 1, 2)
                    )
            
                    # Return the equilibrium distribution for this state
                    return self.equilibrium(rho, u)
            
                def initialise_multiphase_droplet(
                    self, rho_l: float, rho_v: float, interface_width: int
                ):
                    """
                    Initialises a multiphase simulation with a low-density bubble in the center.
            
                    Args:
                        rho_l (float): Liquid phase density.
                        rho_v (float): Vapour phase (bubble) density.
            
                    Returns:
                        jnp.ndarray: Initialised population distribution f.
                    """
                    # Create a density field with a bubble in the center
                    x, y = jnp.meshgrid(jnp.arange(self.nx), jnp.arange(self.ny), indexing="ij")
                    center_x, center_y = self.nx // 2, self.ny // 2
                    radius = min(self.nx, self.ny) // 4
            
                    # Use tanh for a smooth, stable interface
                    distance = jnp.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
                    rho_field_2d = (rho_l + rho_v) / 2 - (rho_l - rho_v) / 2 * jnp.tanh(
                        (distance - radius) / interface_width
                    )
            
                    # Reshape to 4D
                    rho = rho_field_2d.reshape((self.nx, self.ny, 1, 1))
            
                    # Initialise with zero velocity
                    u = jnp.zeros((self.nx, self.ny, 1, 2))
            
                    # Return the equilibrium distribution
                    return self.equilibrium(rho, u)
            
                def initialise_multiphase_bubble(
                    self, rho_l: float, rho_v: float, interface_width: int
                ):
                    """
                    Initialises a multiphase simulation with a low-density bubble in the center.
            
                    Args:
                        rho_l (float): Liquid phase density.
                        rho_v (float): Vapour phase (bubble) density.
            
                    Returns:
                        jnp.ndarray: Initialised population distribution f.
                    """
                    # Create a density field with a bubble in the center
                    x, y = jnp.meshgrid(jnp.arange(self.nx), jnp.arange(self.ny), indexing="ij")
                    center_x, center_y = self.nx // 2, self.ny // 2
                    radius = min(self.nx, self.ny) // 4
            
                    # Use tanh for a smooth, stable interface
                    distance = jnp.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
                    rho_field_2d = (rho_l + rho_v) / 2 + (rho_l - rho_v) / 2 * jnp.tanh(
                        (distance - radius) / interface_width
                    )
            
                    # Reshape to 4D
                    rho = rho_field_2d.reshape((self.nx, self.ny, 1, 1))
            
                    # Initialise with zero velocity
                    u = jnp.zeros((self.nx, self.ny, 1, 2))
            
                    # Return the equilibrium distribution
                    return self.equilibrium(rho, u)
            
                def initialise_wetting_chemical_step(
                    self, rho_l: float, rho_v: float, interface_width: int
                ):
                    """
                    Initialize the simulation with a droplet wetting a solid surface.
            
                    Args:
                        rho_l (float): Liquid phase density.
                        rho_v (float): Vapour phase density.
                        interface_width (int): Width of the interface for tanh profile.
            
                    Returns:
                        jnp.ndarray: Initial distribution function.
                    """
                    # Radius of the droplet (adapted from user query)
                    r = (self.ny) / 3.3
            
                    # Initialize velocity (zero) and density fields with correct shapes
                    u = jnp.zeros((self.nx, self.ny, 1, 2))
                    rho = jnp.zeros((self.nx, self.ny, 1, 1))
            
                    # Create grid (shifted by 0.5 for cell centers)
                    x, y = jnp.meshgrid(jnp.arange(self.nx), jnp.arange(self.ny), indexing="ij")
            
                    # Calculate center coordinates (droplet centered horizontally, near bottom)
                    xc, yc = self.nx / 2, self.ny / 2
            
                    # Calculate distance from center (shifted to simulate wetting at bottom)
                    distance = jnp.sqrt((x - xc / 2) ** 2 + (y) ** 2)
            
                    # Calculate density distribution using tanh for smooth interface
                    rho_2d = (rho_l + rho_v) / 2 + (rho_l - rho_v) / 2 * jnp.tanh(
                        2 * (r - distance) / interface_width
                    )
            
                    # Assign to rho (reshape to 4D)
                    rho = rho.at[:, :, 0, 0].set(rho_2d)
            
                    # Return equilibrium distribution
                    return self.equilibrium(rho, u)
            
                def initialise_wetting(self, rho_l: float, rho_v: float, interface_width: int):
                    """
                    Initialize the simulation with a droplet wetting a solid surface.
            
                    Args:
                        rho_l (float): Liquid phase density.
                        rho_v (float): Vapour phase density.
                        interface_width (int): Width of the interface for tanh profile.
            
                    Returns:
                        jnp.ndarray: Initial distribution function.
                    """
                    # Radius of the droplet (adapted from user query)
                    r = (self.ny) / 3.3
            
                    # Initialize velocity (zero) and density fields with correct shapes
                    u = jnp.zeros((self.nx, self.ny, 1, 2))
                    rho = jnp.zeros((self.nx, self.ny, 1, 1))
            
                    # Create grid (shifted by 0.5 for cell centers)
                    x, y = jnp.meshgrid(jnp.arange(self.nx), jnp.arange(self.ny), indexing="ij")
            
                    # Calculate center coordinates (droplet centered horizontally, near bottom)
                    xc, yc = self.nx / 2, self.ny / 2
            
                    # Calculate distance from center (shifted to simulate wetting at bottom)
                    distance = jnp.sqrt((x - xc) ** 2 + (y) ** 2)
            
                    # Calculate density distribution using tanh for smooth interface
                    rho_2d = (rho_l + rho_v) / 2 + (rho_l - rho_v) / 2 * jnp.tanh(
                        2 * (r - distance) / interface_width
                    )
            
                    # Assign to rho (reshape to 4D)
                    rho = rho.at[:, :, 0, 0].set(rho_2d)
            
                    # Return equilibrium distribution
                    return self.equilibrium(rho, u)
            --- End of init.py ---

            __pycache__/
                init.cpython-312.pyc
                __init__.cpython-312.pyc
        __pycache__/
            __init__.cpython-312.pyc
        boundary_condition/
            boundary_condition.py
            --- Code in boundary_condition.py ---
            from functools import partial
            import jax.numpy as jnp
            from jax import jit
            from typing import Dict
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            
            class BoundaryCondition:
                """
                Applies boundary conditions to the post-streaming distribution function.
                Supports bounce-back, symmetry, and periodic BCs on specified grid edges.
                Uses dynamic indices from Lattice class instead of hardcoding.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, bc_config: Dict[str, str]):
                    self.grid = grid
                    self.lattice = lattice
                    self.bc_config = bc_config
                    self.opp_indices = lattice.opp_indices
                    self.edges = grid.get_edges()
                    valid_edges = ["top", "bottom", "left", "right"]
                    valid_types = ["bounce-back", "symmetry", "periodic"]
                    for edge, bc_type in bc_config.items():
                        if edge not in valid_edges:
                            raise ValueError(f"Invalid edge: {edge}. Must be one of {valid_edges}.")
                        if bc_type not in valid_types:
                            raise ValueError(
                                f"Invalid BC type: {bc_type}. Must be one of {valid_types}."
                            )
            
                @time_function(enable_timing=TIMING_ENABLED)
                @partial(jit, static_argnums=(0,))
                def __call__(
                    self, f_streamed: jnp.ndarray, f_collision: jnp.ndarray
                ) -> jnp.ndarray:
                    for edge, bc_type in self.bc_config.items():
                        if bc_type == "bounce-back":
                            f_streamed = self._apply_bounce_back(f_streamed, f_collision, edge)
                        elif bc_type == "symmetry":
                            f_streamed = self._apply_symmetry(f_streamed, f_collision, edge)
                        elif bc_type == "periodic":
                            f_streamed = self._apply_periodic(f_streamed)
                    return f_streamed
            
                @partial(jit, static_argnums=(0, 3))
                def _apply_bounce_back(
                    self, f_streamed: jnp.ndarray, f_collision: jnp.ndarray, edge: str
                ) -> jnp.ndarray:
                    lattice = self.lattice
                    if edge == "bottom":
                        idx = 0
                        incoming_dirs = lattice.construct_top_indices
                        for i in incoming_dirs:
                            opp_i = self.opp_indices[i]
                            f_streamed = f_streamed.at[:, idx, i, 0].set(
                                f_collision[:, idx, opp_i, 0]
                            )
                    elif edge == "top":
                        idx = -1
                        incoming_dirs = lattice.construct_bottom_indices
                        for i in incoming_dirs:
                            opp_i = self.opp_indices[i]
                            f_streamed = f_streamed.at[:, idx, i, 0].set(
                                f_collision[:, idx, opp_i, 0]
                            )
                    elif edge == "left":
                        idx = 0
                        incoming_dirs = lattice.construct_right_indices
                        for i in incoming_dirs:
                            opp_i = self.opp_indices[i]
                            f_streamed = f_streamed.at[idx, :, i, 0].set(
                                f_collision[idx, :, opp_i, 0]
                            )
                    elif edge == "right":
                        idx = -1
                        incoming_dirs = lattice.construct_left_indices
                        for i in incoming_dirs:
                            opp_i = self.opp_indices[i]
                            f_streamed = f_streamed.at[idx, :, i, 0].set(
                                f_collision[idx, :, opp_i, 0]
                            )
                    return f_streamed
            
                @partial(jit, static_argnums=(0, 3))
                def _apply_symmetry(
                    self, f_streamed: jnp.ndarray, f_collision: jnp.ndarray, edge: str
                ) -> jnp.ndarray:
                    lattice = self.lattice
                    if edge == "bottom":
                        idx = 0
                        top_dirs = lattice.construct_top_indices
                        bottom_dirs = lattice.construct_bottom_indices
                        diag_top_right = lattice.construct_top_indices[2]
                        diag_bottom_right = lattice.construct_bottom_indices[2]
                        diag_top_left = lattice.construct_top_indices[1]
                        diag_bottom_left = lattice.construct_bottom_indices[1]
                        f_streamed = f_streamed.at[:, idx, top_dirs[0], 0].set(
                            f_collision[:, idx, bottom_dirs[0], 0]
                        )
                        f_streamed = f_streamed.at[:, idx, diag_top_right, 0].set(
                            f_collision[:, idx, diag_bottom_right, 0]
                        )
                        f_streamed = f_streamed.at[:, idx, diag_top_left, 0].set(
                            f_collision[:, idx, diag_bottom_left, 0]
                        )
                    elif edge == "top":
                        idx = -1
                        bottom_dirs = lattice.construct_bottom_indices
                        top_dirs = lattice.construct_top_indices
                        f_streamed = f_streamed.at[:, idx, bottom_dirs[0], 0].set(
                            f_collision[:, idx, top_dirs[0], 0]
                        )
                        f_streamed = f_streamed.at[:, idx, bottom_dirs[1], 0].set(
                            jnp.roll(f_collision[:, idx, top_dirs[1], 0], 1, axis=0)
                        )
                        f_streamed = f_streamed.at[:, idx, bottom_dirs[2], 0].set(
                            jnp.roll(f_collision[:, idx, top_dirs[2], 0], -1, axis=0)
                        )
                    elif edge == "left":
                        idx = 0
                        right_dirs = lattice.construct_right_indices
                        left_dirs = lattice.construct_left_indices
                        f_streamed = f_streamed.at[idx, :, right_dirs[0], 0].set(
                            f_collision[idx, :, left_dirs[0], 0]
                        )
                        f_streamed = f_streamed.at[idx, :, right_dirs[1], 0].set(
                            f_collision[idx, :, left_dirs[1], 0]
                        )
                        f_streamed = f_streamed.at[idx, :, right_dirs[2], 0].set(
                            f_collision[idx, :, left_dirs[2], 0]
                        )
                    elif edge == "right":
                        idx = -1
                        left_dirs = lattice.construct_left_indices
                        right_dirs = lattice.construct_right_indices
                        f_streamed = f_streamed.at[idx, :, left_dirs[0], 0].set(
                            f_collision[idx, :, right_dirs[0], 0]
                        )
                        f_streamed = f_streamed.at[idx, :, left_dirs[1], 0].set(
                            f_collision[idx, :, right_dirs[1], 0]
                        )
                        f_streamed = f_streamed.at[idx, :, left_dirs[2], 0].set(
                            f_collision[idx, :, right_dirs[2], 0]
                        )
                    return f_streamed
            
                @partial(jit, static_argnums=(0,))
                def _apply_periodic(self, f_streamed: jnp.ndarray) -> jnp.ndarray:
                    # For periodic boundaries, no additional transformation is needed
                    # The streaming step already handles periodicity correctly
                    return f_streamed
            --- End of boundary_condition.py ---

            __init__.py
            --- Code in __init__.py ---
            from .boundary_condition import BoundaryCondition
            --- End of __init__.py ---

            __pycache__/
                boundary_condition.cpython-312.pyc
                __init__.cpython-312.pyc
        equilibrium/
            equilibrium.py
            --- Code in equilibrium.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            
            class Equilibrium:
                """
                Callable class to calculate the equilibrium population distribution for LBM.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice) -> None:
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.w = lattice.w
                    self.cx = lattice.c[0]
                    self.cy = lattice.c[1]
            
                @time_function(enable_timing=TIMING_ENABLED)
                @partial(jit, static_argnums=(0,))
                def __call__(self, rho_, u_):
                    """
                    Calculate the equilibrium distribution function.
            
                    Args:
                        rho_ (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                        u_ (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
            
                    Returns:
                        jnp.ndarray: Equilibrium distribution function, shape (nx, ny, q, 1)
                    """
                    nx, ny, q = self.nx, self.ny, self.q
                    w = self.w
                    cx, cy = self.cx, self.cy
            
                    # Extract velocity components
                    ux = u_[..., 0]  # Shape: (nx, ny, 1)
                    uy = u_[..., 1]  # Shape: (nx, ny, 1)
            
                    # Squeeze density to match velocity dimensions
                    rho = rho_.squeeze(axis=-1)  # Shape: (nx, ny, 1)
            
                    # Initialize equilibrium distribution - note the 4D shape
                    f_eq = jnp.zeros((nx, ny, q, 1))
            
                    # Calculate equilibrium for each velocity direction
                    for i in range(q):
                        cu = cx[i] * ux + cy[i] * uy
                        cu2 = cu * cu
                        u2 = ux * ux + uy * uy
            
                        f_eq = f_eq.at[:, :, i, :].set(w[i] * rho * (3 * cu + 4.5 * cu2 - 1.5 * u2))
                    f_eq = f_eq.at[:, :, 0, :].set(
                        rho[:, :, :] * (1 - w[0] * (3 / 2 * (ux * ux + uy * uy)))
                    )
            
                    return f_eq
            --- End of equilibrium.py ---

            __init__.py
            --- Code in __init__.py ---
            from .equilibrium import Equilibrium
            --- End of __init__.py ---

            __pycache__/
                equilibrium.cpython-312.pyc
                __init__.cpython-312.pyc
        force/
            gravitational_force_multiphase.py
            --- Code in gravitational_force_multiphase.py ---
            import jax.numpy as jnp
            from wblbm.operators.force.force import Force
            
            
            class GravityForceMultiphaseDroplet(Force):
                """
                Subclass for gravitational force, constant across the grid.
                """
            
                def __init__(
                    self, nx: int, ny: int, d: int, force_g: float, inclination_angle_deg: float
                ):
                    if d != 2:
                        raise ValueError("Currently supports 2D (d=2) only")
            
                    force_x = force_g * jnp.sin(jnp.deg2rad(inclination_angle_deg))
                    force_y = force_g * -jnp.cos(jnp.deg2rad(inclination_angle_deg))
            
                    force_array = jnp.zeros((nx, ny, 1, d))
                    force_array = force_array.at[:, :, 0, 0].set(force_x)
                    force_array = force_array.at[:, :, 0, 1].set(force_y)
            
                    super().__init__(force_array)
            
                def compute_force(
                    self, rho: jnp.ndarray, rho_l: float, rho_v: float
                ) -> jnp.ndarray:
                    """
                    Returns the constant gravitational force field.
                    Ignores rho as gravity is density-independent.
                    """
                    mask = rho > 0.95 * rho_v + 0.05 * rho_l
                    return self.force * rho * mask
            --- End of gravitational_force_multiphase.py ---

            force.py
            --- Code in force.py ---
            from abc import ABC, abstractmethod
            import jax.numpy as jnp
            
            
            class Force(ABC):
                """
                Abstract base class for forces in the simulation.
                Holds a force array of shape (nx, ny, 1, d).
                """
            
                def __init__(self, force_array: jnp.ndarray):
                    if force_array.ndim != 4 or force_array.shape[2] != 1:
                        raise ValueError("Force array must have shape (nx, ny, 1, d)")
                    self.force = force_array
            
                @abstractmethod
                def compute_force(self, *args, **kwargs) -> jnp.ndarray:
                    """
                    Compute the force field based on the density field rho.
                    Must return an array of shape (nx, ny, 1, d).
                    """
                    pass
            --- End of force.py ---

            __init__.py
            --- Code in __init__.py ---
            from .force import Force
            from .gravitational_force_bubble import GravityForceMultiphaseBubble
            from .gravitational_force_single_phase import GravityForceSinglephase
            from .gravitational_force_multiphase import GravityForceMultiphaseDroplet
            --- End of __init__.py ---

            gravitational_force_single_phase.py
            --- Code in gravitational_force_single_phase.py ---
            import jax.numpy as jnp
            from wblbm.operators.force.force import Force
            
            
            class GravityForceSinglephase(Force):
                """
                Subclass for gravitational force, constant across the grid.
                """
            
                def __init__(
                    self, nx: int, ny: int, d: int, force_g: float, inclination_angle_deg: float
                ):
                    if d != 2:
                        raise ValueError("Currently supports 2D (d=2) only")
            
                    force_x = force_g * jnp.sin(jnp.deg2rad(inclination_angle_deg))
                    force_y = force_g * -jnp.cos(jnp.deg2rad(inclination_angle_deg))
            
                    force_array = jnp.zeros((nx, ny, 1, d))
                    force_array = force_array.at[:, :, 0, 0].set(force_x)
                    force_array = force_array.at[:, :, 0, 1].set(force_y)
            
                    super().__init__(force_array)
            
                def compute_force(self, rho: jnp.ndarray) -> jnp.ndarray:
                    """
                    Returns the constant gravitational force field.
                    Ignores rho as gravity is density-independent.
                    """
                    return self.force * rho
            --- End of gravitational_force_single_phase.py ---

            gravitational_force_bubble.py
            --- Code in gravitational_force_bubble.py ---
            import jax.numpy as jnp
            from wblbm.operators.force.force import Force
            
            
            class GravityForceMultiphaseBubble(Force):
                """
                Subclass for gravitational force, constant across the grid.
                I have tested this class and compared it to the masked implementation.
                The masked implementation has better stability.
                """
            
                def __init__(
                    self, nx: int, ny: int, d: int, force_g: float, inclination_angle_deg: float
                ):
                    if d != 2:
                        raise ValueError("Currently supports 2D (d=2) only")
            
                    force_x = force_g * jnp.sin(jnp.deg2rad(inclination_angle_deg))
                    force_y = force_g * jnp.cos(jnp.deg2rad(inclination_angle_deg))
            
                    force_array = jnp.zeros((nx, ny, 1, d))
                    force_array = force_array.at[:, :, 0, 0].set(force_x)
                    force_array = force_array.at[:, :, 0, 1].set(force_y)
            
                    super().__init__(force_array)
            
                def compute_force(
                    self, rho: jnp.ndarray, rho_l: float, rho_v: float
                ) -> jnp.ndarray:
                    """
                    Returns the constant gravitational force field.
                    Ignores rho as gravity is density-independent.
                    """
                    mask = rho < 0.95 * rho_l + 0.05 * rho_v
                    return self.force * rho * mask
            --- End of gravitational_force_bubble.py ---

            __pycache__/
                force.cpython-312.pyc
                gravitational_force_single_phase.cpython-312.pyc
                gravitational_force_multiphase.cpython-312.pyc
                __init__.cpython-312.pyc
                gravitational_force_bubble.cpython-312.pyc
        wetting/
            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            hysteresis.py
            --- Code in hysteresis.py ---
            import jax.numpy as jnp
            import logging
            
            
            class Hysteresis:
                """
                Class to model contact angle hysteresis in wetting simulations.
                """
            
                def __init__(
                    self,
                    advancing_ca_hydrophobic,
                    receding_ca_hydrophobic,
                    advancing_ca_hydrophilic,
                    receding_ca_hydrophilic,
                    cll_threshold,
                    ca_threshold,
                    change_d_rho,
                    change_phi,
                    while_limiter,
                    nx,
                    phi_val,
                    d_rho_val,
                    w,
                ):
                    self.advancing_ca_hydrophobic = advancing_ca_hydrophobic
                    self.receding_ca_hydrophobic = receding_ca_hydrophobic
                    self.advancing_ca_hydrophilic = advancing_ca_hydrophilic
                    self.receding_ca_hydrophilic = receding_ca_hydrophilic
                    self.cll_threshold = cll_threshold
                    self.ca_threshold = ca_threshold
                    self.change_d_rho = change_d_rho
                    self.change_phi = change_phi
                    self.while_limiter = while_limiter
                    self.nx = nx
                    self.phi_val = phi_val
                    self.d_rho_val = d_rho_val
                    self.w = w
            
                def apply(
                    self,
                    f_prev,
                    it,
                    left_step_passed,
                    right_step_passed,
                    cah_window_left_philic,
                    cah_window_right_philic,
                    cah_window_left_phobic,
                    cah_window_right_phobic,
                    pinned_count_left,
                    pinned_count_right,
                    update_func,
                    contact_angle_func,
                    cll_func,
                    get_rho_func,
                ):
                    # Initialize parameters
                    phi_left = jnp.ones(self.nx)
                    d_rho_left = jnp.zeros(self.nx)
                    phi_left = phi_left.at[(self.nx // 2) :].set(self.phi_val)
                    d_rho_left = d_rho_left.at[: (self.nx // 2)].set(self.d_rho_val)
            
                    phi_right = jnp.ones(self.nx)
                    d_rho_right = jnp.zeros(self.nx)
                    phi_right = phi_right.at[(self.nx // 2) :].set(self.phi_val)
                    d_rho_right = d_rho_right.at[: (self.nx // 2)].set(self.d_rho_val)
            
                    f_t = f_prev
                    f_tplus1, rho_t = update_func(f_t, phi_left, phi_right, d_rho_left, d_rho_right)
                    rho_tplus1 = get_rho_func(f_tplus1)
                    ca_left_t, ca_right_t = contact_angle_func(rho_t)
                    cll_left_t, cll_right_t = cll_func(rho_t, ca_left_t, ca_right_t)
                    ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                    cll_left_tplus1, cll_right_tplus1 = cll_func(
                        rho_tplus1, ca_left_tplus1, ca_right_tplus1
                    )
            
                    # --- Hysteresis logic ---
                    # Left side
                    if ca_left_tplus1 < self.advancing_ca_hydrophilic:
                        cah_window_left_philic = True
                    if cll_left_tplus1 > self.nx // 2 - self.w // 2:
                        left_step_passed = True
                    if cll_left_tplus1 < self.nx // 2 - self.w // 2 and not left_step_passed:
                        receding_ca_left = self.receding_ca_hydrophobic
                        advancing_ca_left = self.advancing_ca_hydrophobic
                        cll_threshold_left = self.cll_threshold
                    elif (
                        ca_left_tplus1 > self.advancing_ca_hydrophilic
                        and left_step_passed
                        and not cah_window_left_philic
                    ):
                        receding_ca_left = ca_left_tplus1 * (1 + 1e-7)
                        advancing_ca_left = ca_left_tplus1
                        cll_threshold_left = self.cll_threshold
                    else:
                        receding_ca_left = self.receding_ca_hydrophilic
                        advancing_ca_left = self.advancing_ca_hydrophilic
                        cll_threshold_left = self.cll_threshold
            
                    # Right side
                    if ca_right_tplus1 < self.advancing_ca_hydrophilic:
                        cah_window_right_philic = True
                    if cll_right_tplus1 > self.nx // 2 - self.w // 2:
                        right_step_passed = True
                    if cll_right_tplus1 < self.nx // 2 - self.w // 2 and not right_step_passed:
                        receding_ca_right = self.receding_ca_hydrophobic
                        advancing_ca_right = self.advancing_ca_hydrophobic
                        cll_threshold_right = self.cll_threshold
                    elif (
                        ca_right_tplus1 > self.advancing_ca_hydrophilic
                        and right_step_passed
                        and not cah_window_right_philic
                    ):
                        receding_ca_right = ca_right_tplus1
                        advancing_ca_right = ca_right_tplus1 * (1 - 1e-7)
                        cll_threshold_right = self.cll_threshold
                    else:
                        receding_ca_right = self.receding_ca_hydrophilic
                        advancing_ca_right = self.advancing_ca_hydrophilic
                        cll_threshold_right = self.cll_threshold
            
                    # --- Left logic ---
                    p_m_left = None
                    if cll_left_tplus1 > cll_left_t:
                        # receding left
                        if ca_left_tplus1 >= receding_ca_left:
                            count = 0
                            p_m_left = "receding pinned"
                            pinned_count_left += 1
                            while True:
                                if (
                                    (1 + cll_threshold_left) * cll_left_t
                                    > cll_left_tplus1
                                    > (1 - cll_threshold_left) * cll_left_t
                                ):
                                    break
                                if count > self.while_limiter:
                                    print(
                                        f"At it= {it} count>WHILE_LIMITER, in the left receding pinned while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    logging.info(
                                        f"At it= {it} count>WHILE_LIMITER, in the left receding pinned while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    break
                                elif cll_left_tplus1 > cll_left_t:
                                    if jnp.max(d_rho_left) > 0:
                                        d_rho_left = d_rho_left - self.change_d_rho
                                    else:
                                        phi_left = phi_left + self.change_phi
                                    count += 1
                                else:
                                    if jnp.min(phi_left) > 1:
                                        phi_left = phi_left - self.change_phi
                                    else:
                                        d_rho_left = d_rho_left + self.change_d_rho
                                    count += 1
                                f_tplus1, rho_t = update_func(
                                    f_t, phi_left, phi_right, d_rho_left, d_rho_right
                                )
                                rho_tplus1 = get_rho_func(f_tplus1)
                                ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                                cll_left_tplus1, cll_right_tplus1 = cll_func(
                                    rho_tplus1, ca_left_tplus1, ca_right_tplus1
                                )
                        else:
                            if jnp.min(phi_left) > 1:
                                phi_left = phi_left - self.change_phi
                            else:
                                d_rho_left = d_rho_left + self.change_d_rho
                            f_tplus1, rho_t = update_func(
                                f_t, phi_left, phi_right, d_rho_left, d_rho_right
                            )
                            rho_tplus1 = get_rho_func(f_tplus1)
                            ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                            cll_left_tplus1, cll_right_tplus1 = cll_func(
                                rho_tplus1, ca_left_tplus1, ca_right_tplus1
                            )
                            count = 0
                            p_m_left = "receding moving"
                            while True:
                                if (
                                    (1 + self.ca_threshold) * receding_ca_left
                                    > ca_left_tplus1
                                    > (1 - self.ca_threshold) * receding_ca_left
                                ):
                                    break
                                if count > self.while_limiter:
                                    print(
                                        f"At it= {it} count>WHILE_LIMITER, in the left receding moving while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    logging.info(
                                        f"At it= {it} count>WHILE_LIMITER, in the left receding moving while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    break
                                elif jnp.min(d_rho_left) > 1:
                                    print(
                                        f"At it= {it} min(d_rho_left) > 1, in the left receding moving while loop\n"
                                        "This means that there is a problem, possibly the threshold values for "
                                        "the wetting parameters are too large"
                                    )
                                    logging.info(
                                        f"At it= {it} min(d_rho_left) > 1, in the left receding moving while loop\n"
                                        "This means that there is a problem, possibly the threshold values for "
                                        "the wetting parameters are too large"
                                    )
                                    break
                                elif ca_left_tplus1 < receding_ca_left:
                                    if jnp.min(phi_left) > 1:
                                        phi_left = phi_left - self.change_phi
                                    else:
                                        d_rho_left = d_rho_left + self.change_d_rho
                                    count += 1
                                else:
                                    if jnp.max(d_rho_left) > 0:
                                        d_rho_left = d_rho_left - self.change_d_rho
                                    else:
                                        phi_left = phi_left + self.change_phi
                                    count += 1
                                f_tplus1, rho_t = update_func(
                                    f_t, phi_left, phi_right, d_rho_left, d_rho_right
                                )
                                rho_tplus1 = get_rho_func(f_tplus1)
                                ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                                cll_left_tplus1, cll_right_tplus1 = cll_func(
                                    rho_tplus1, ca_left_tplus1, ca_right_tplus1
                                )
                    else:
                        # advancing left
                        if ca_left_tplus1 <= advancing_ca_left:
                            count = 0
                            p_m_left = "advancing pinned"
                            pinned_count_left += 1
                            while True:
                                if (
                                    (1 + cll_threshold_left) * cll_left_t
                                    > cll_left_tplus1
                                    > (1 - cll_threshold_left) * cll_left_t
                                ):
                                    break
                                if count > self.while_limiter:
                                    print(
                                        f"At it= {it} count>WHILE_LIMITER, in the left advancing pinned while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    logging.info(
                                        f"At it= {it} count>WHILE_LIMITER, in the left advancing pinned while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    break
                                elif cll_left_tplus1 < cll_left_t:
                                    if jnp.min(phi_left) > 1:
                                        phi_left = phi_left - self.change_phi
                                    else:
                                        d_rho_left = d_rho_left + self.change_d_rho
                                    count += 1
                                else:
                                    if jnp.max(d_rho_left) > 0:
                                        d_rho_left = d_rho_left - self.change_d_rho
                                    else:
                                        phi_left = phi_left + self.change_phi
                                    count += 1
                                f_tplus1, rho_t = update_func(
                                    f_t, phi_left, phi_right, d_rho_left, d_rho_right
                                )
                                rho_tplus1 = get_rho_func(f_tplus1)
                                ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                                cll_left_tplus1, cll_right_tplus1 = cll_func(
                                    rho_tplus1, ca_left_tplus1, ca_right_tplus1
                                )
                        else:
                            if jnp.max(d_rho_left) > 0:
                                d_rho_left = d_rho_left - self.change_d_rho
                            else:
                                phi_left = phi_left + self.change_phi
                            f_tplus1, rho_t = update_func(
                                f_t, phi_left, phi_right, d_rho_left, d_rho_right
                            )
                            rho_tplus1 = get_rho_func(f_tplus1)
                            ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                            cll_left_tplus1, cll_right_tplus1 = cll_func(
                                rho_tplus1, ca_left_tplus1, ca_right_tplus1
                            )
                            count = 0
                            p_m_left = "advancing moving"
                            while True:
                                if (
                                    (1 + self.ca_threshold) * advancing_ca_left
                                    > ca_left_tplus1
                                    > (1 - self.ca_threshold) * advancing_ca_left
                                ):
                                    break
                                if count > self.while_limiter:
                                    print(
                                        f"At it= {it} count>WHILE_LIMITER, in the left advancing moving while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    logging.info(
                                        f"At it= {it} count>WHILE_LIMITER, in the left advancing moving while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    break
                                elif ca_left_tplus1 > advancing_ca_left:
                                    if jnp.max(d_rho_left) > 0:
                                        d_rho_left = d_rho_left - self.change_d_rho
                                    else:
                                        phi_left = phi_left + self.change_phi
                                    count += 1
                                else:
                                    if jnp.min(phi_left) > 1:
                                        phi_left = phi_left - self.change_phi
                                    else:
                                        d_rho_left = d_rho_left + self.change_d_rho
                                    count += 1
                                f_tplus1, rho_t = update_func(
                                    f_t, phi_left, phi_right, d_rho_left, d_rho_right
                                )
                                rho_tplus1 = get_rho_func(f_tplus1)
                                ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                                cll_left_tplus1, cll_right_tplus1 = cll_func(
                                    rho_tplus1, ca_left_tplus1, ca_right_tplus1
                                )
            
                    # --- Right logic ---
                    p_m_right = None
                    if cll_right_tplus1 > cll_right_t:
                        # advancing right
                        if ca_right_tplus1 <= advancing_ca_right:
                            count = 0
                            p_m_right = "advancing pinned"
                            pinned_count_right += 1
                            while True:
                                if (
                                    (1 + cll_threshold_right) * cll_right_t
                                    > cll_right_tplus1
                                    > (1 - cll_threshold_right) * cll_right_t
                                ):
                                    break
                                if count > self.while_limiter:
                                    print(
                                        f"At it= {it} count>WHILE_LIMITER, in the right advancing pinned while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    logging.info(
                                        f"At it= {it} count>WHILE_LIMITER, in the right advancing pinned while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    break
                                elif cll_right_tplus1 > cll_right_t:
                                    if jnp.min(phi_right) > 1:
                                        phi_right = phi_right - self.change_phi
                                    else:
                                        d_rho_right = d_rho_right + self.change_d_rho
                                    count += 1
                                else:
                                    if jnp.max(d_rho_right) > 0:
                                        d_rho_right = d_rho_right - self.change_d_rho
                                    else:
                                        phi_right = phi_right + self.change_phi
                                    count += 1
                                f_tplus1, rho_t = update_func(
                                    f_t, phi_left, phi_right, d_rho_left, d_rho_right
                                )
                                rho_tplus1 = get_rho_func(f_tplus1)
                                ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                                cll_left_tplus1, cll_right_tplus1 = cll_func(
                                    rho_tplus1, ca_left_tplus1, ca_right_tplus1
                                )
                        else:
                            if jnp.max(d_rho_right) > 0:
                                d_rho_right = d_rho_right - self.change_d_rho
                                count += 1
                            else:
                                phi_right = phi_right + self.change_phi
                                count += 1
                            f_tplus1, rho_t = update_func(
                                f_t, phi_left, phi_right, d_rho_left, d_rho_right
                            )
                            rho_tplus1 = get_rho_func(f_tplus1)
                            ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                            cll_left_tplus1, cll_right_tplus1 = cll_func(
                                rho_tplus1, ca_left_tplus1, ca_right_tplus1
                            )
                            count = 0
                            p_m_right = "advancing moving"
                            while True:
                                if (
                                    (1 + self.ca_threshold) * advancing_ca_right
                                    > ca_right_tplus1
                                    > (1 - self.ca_threshold) * advancing_ca_right
                                ):
                                    break
                                if count > self.while_limiter:
                                    print(
                                        f"At it= {it} count>WHILE_LIMITER, in the right advancing moving while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    logging.info(
                                        f"At it= {it} count>WHILE_LIMITER, in the right advancing moving while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    break
                                elif ca_right_tplus1 > advancing_ca_right:
                                    if jnp.max(d_rho_right) > 0:
                                        d_rho_right = d_rho_right - self.change_d_rho
                                    else:
                                        phi_right = phi_right + self.change_phi
                                    count += 1
                                else:
                                    if jnp.min(phi_right) > 1:
                                        phi_right = phi_right - self.change_phi
                                    else:
                                        d_rho_right = d_rho_right + self.change_d_rho
                                    count += 1
                                f_tplus1, rho_t = update_func(
                                    f_t, phi_left, phi_right, d_rho_left, d_rho_right
                                )
                                rho_tplus1 = get_rho_func(f_tplus1)
                                ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                                cll_left_tplus1, cll_right_tplus1 = cll_func(
                                    rho_tplus1, ca_left_tplus1, ca_right_tplus1
                                )
                    else:
                        # receding right
                        if ca_right_tplus1 >= receding_ca_right:
                            count = 0
                            p_m_right = "receding pinned"
                            pinned_count_right += 1
                            while True:
                                if (
                                    (1 + cll_threshold_right) * cll_right_t
                                    > cll_right_tplus1
                                    > (1 - cll_threshold_right) * cll_right_t
                                ):
                                    break
                                if count > self.while_limiter:
                                    print(
                                        f"At it= {it} count>WHILE_LIMITER, in the right receding pinned while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large."
                                    )
                                    logging.info(
                                        f"At it= {it} count>WHILE_LIMITER, in the right receding pinned while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large."
                                    )
                                    break
                                elif cll_right_tplus1 > cll_right_t:
                                    if jnp.min(phi_right) > 1:
                                        phi_right = phi_right - self.change_phi
                                    else:
                                        d_rho_right = d_rho_right + self.change_d_rho
                                    count += 1
                                else:
                                    if jnp.max(d_rho_right) > 0:
                                        d_rho_right = d_rho_right - self.change_d_rho
                                    else:
                                        phi_right = phi_right + self.change_phi
                                    count += 1
                                f_tplus1, rho_t = update_func(
                                    f_t, phi_left, phi_right, d_rho_left, d_rho_right
                                )
                                rho_tplus1 = get_rho_func(f_tplus1)
                                ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                                cll_left_tplus1, cll_right_tplus1 = cll_func(
                                    rho_tplus1, ca_left_tplus1, ca_right_tplus1
                                )
                        else:
                            if jnp.min(phi_right) > 1:
                                phi_right = phi_right - self.change_phi
                                count += 1
                            else:
                                d_rho_right = d_rho_right + self.change_d_rho
                                count += 1
                            f_tplus1, rho_t = update_func(
                                f_t, phi_left, phi_right, d_rho_left, d_rho_right
                            )
                            rho_tplus1 = get_rho_func(f_tplus1)
                            ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                            cll_left_tplus1, cll_right_tplus1 = cll_func(
                                rho_tplus1, ca_left_tplus1, ca_right_tplus1
                            )
                            count = 0
                            p_m_right = "receding moving"
                            while True:
                                if (
                                    (1 + self.ca_threshold) * receding_ca_right
                                    > ca_right_tplus1
                                    > (1 - self.ca_threshold) * receding_ca_right
                                ):
                                    break
                                if count > self.while_limiter:
                                    print(
                                        f"At it= {it} count>WHILE_LIMITER, in the right receding moving while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    logging.info(
                                        f"At it= {it} count>WHILE_LIMITER, in the right receding moving while loop\n"
                                        "This means that there is a problem, possibly the adaptation values for "
                                        "the wetting parameters are too large"
                                    )
                                    break
                                elif ca_right_tplus1 < receding_ca_right:
                                    if jnp.min(phi_right) > 1:
                                        phi_right = phi_right - self.change_phi
                                    else:
                                        d_rho_right = d_rho_right + self.change_d_rho
                                    count += 1
                                else:
                                    if jnp.max(d_rho_right) > 0:
                                        d_rho_right = d_rho_right - self.change_d_rho
                                    else:
                                        phi_right = phi_right + self.change_phi
                                    count += 1
                                f_tplus1, rho_t = update_func(
                                    f_t, phi_left, phi_right, d_rho_left, d_rho_right
                                )
                                rho_tplus1 = get_rho_func(f_tplus1)
                                ca_left_tplus1, ca_right_tplus1 = contact_angle_func(rho_tplus1)
                                cll_left_tplus1, cll_right_tplus1 = cll_func(
                                    rho_tplus1, ca_left_tplus1, ca_right_tplus1
                                )
            
                    # --- Pinning count logic ---
                    if ca_left_t < receding_ca_left + 1 or ca_left_t > advancing_ca_left - 1:
                        pinned_count_left += -1
                    if ca_right_t < receding_ca_right + 1 or ca_right_t > advancing_ca_right - 1:
                        pinned_count_right += -1
            
                    return (
                        phi_left,
                        phi_right,
                        d_rho_left,
                        d_rho_right,
                        left_step_passed,
                        right_step_passed,
                        cah_window_left_philic,
                        cah_window_right_philic,
                        cah_window_left_phobic,
                        cah_window_right_phobic,
                        pinned_count_left,
                        pinned_count_right,
                        p_m_left,
                        p_m_right,
                    )
            --- End of hysteresis.py ---

            contact_line_location.py
            --- Code in contact_line_location.py ---
            import jax.numpy as jnp
            
            
            class ContactLineLocation:
                """
                Class to calculate contact line locations (left and right) from density and angles.
                """
            
                def __init__(self, rho_mean):
                    self.rho_mean = rho_mean
            
                def compute(self, rho, ca_left, ca_right):
                    array_i_j0 = rho[:, 0]
            
                    mask_i_j0 = array_i_j0 < self.rho_mean
            
                    mask_int_i_j0 = jnp.array(mask_i_j0, dtype=int)
            
                    diff_mask_i_j0 = jnp.diff(mask_int_i_j0)
            
                    transition_index_left_i_j0 = jnp.where(
                        diff_mask_i_j0 == -1, size=1, fill_value=0
                    )[0]
                    transition_index_right_i_j0 = (
                        jnp.where(diff_mask_i_j0 == 1, size=1, fill_value=0)[0]
                    ) + 1
            
                    index_left_i_j0 = transition_index_left_i_j0[0].astype(int)
                    index_right_i_j0 = transition_index_right_i_j0[0].astype(int)
            
                    x_val_left_j0 = index_left_i_j0 + (
                        self.rho_mean - array_i_j0[index_left_i_j0]
                    ) / (array_i_j0[index_left_i_j0 + 1] - array_i_j0[index_left_i_j0])
                    x_val_right_j0 = (index_right_i_j0) - (
                        self.rho_mean - array_i_j0[index_right_i_j0]
                    ) / (array_i_j0[index_right_i_j0 - 1] - array_i_j0[index_right_i_j0])
            
                    x_val_left_jsolid = x_val_left_j0 - (1 / (2 * jnp.tan(jnp.deg2rad(ca_left))))
                    x_val_right_jsolid = x_val_right_j0 + (1 / (2 * jnp.tan(jnp.deg2rad(ca_right))))
            
                    return x_val_left_jsolid, x_val_right_jsolid
            --- End of contact_line_location.py ---

            contact_angle.py
            --- Code in contact_angle.py ---
            import jax.numpy as jnp
            import math
            
            
            class ContactAngle:
                """
                Class to calculate contact angles (left and right) from a density field.
                """
            
                def __init__(self, rho_mean):
                    self.rho_mean = rho_mean
            
                def compute(self, rho):
                    array_i_j0 = rho[:, 1]
                    array_i_jpos1 = rho[:, 2]
            
                    mask_i_j0 = array_i_j0 < self.rho_mean
                    mask_i_jpos1 = array_i_jpos1 < self.rho_mean
            
                    mask_int_i_j0 = jnp.array(mask_i_j0, dtype=int)
                    mask_int_i_jpos1 = jnp.array(mask_i_jpos1, dtype=int)
            
                    diff_mask_i_j0 = jnp.diff(mask_int_i_j0)
                    diff_mask_i_jpos1 = jnp.diff(mask_int_i_jpos1)
            
                    transition_index_left_i_j0 = jnp.where(
                        diff_mask_i_j0 == -1, size=1, fill_value=0
                    )[0]
                    transition_index_left_i_jpos1 = jnp.where(
                        diff_mask_i_jpos1 == -1, size=1, fill_value=0
                    )[0]
                    transition_index_right_i_j0 = (
                        jnp.where(diff_mask_i_j0 == 1, size=1, fill_value=0)[0]
                    ) + 1
                    transition_index_right_i_jpos1 = (
                        jnp.where(diff_mask_i_jpos1 == 1, size=1, fill_value=0)[0] + 1
                    )
            
                    index_left_i_j0 = transition_index_left_i_j0[0].astype(int)
                    index_left_i_jpos1 = transition_index_left_i_jpos1[0].astype(int)
                    index_right_i_j0 = transition_index_right_i_j0[0].astype(int)
                    index_right_i_jpos1 = transition_index_right_i_jpos1[0].astype(int)
            
                    x_val_left_j0 = index_left_i_j0 + (
                        self.rho_mean - array_i_j0[index_left_i_j0]
                    ) / (array_i_j0[index_left_i_j0 + 1] - array_i_j0[index_left_i_j0])
                    x_val_left_jpos1 = index_left_i_jpos1 + (
                        self.rho_mean - array_i_jpos1[index_left_i_jpos1]
                    ) / (array_i_jpos1[index_left_i_jpos1 + 1] - array_i_jpos1[index_left_i_jpos1])
                    x_val_right_j0 = index_right_i_j0 - (
                        self.rho_mean - array_i_j0[index_right_i_j0]
                    ) / (array_i_j0[index_right_i_j0 - 1] - array_i_j0[index_right_i_j0])
                    x_val_right_jpos1 = index_right_i_jpos1 - (
                        self.rho_mean - array_i_jpos1[index_right_i_jpos1]
                    ) / (
                        array_i_jpos1[index_right_i_jpos1 - 1] - array_i_jpos1[index_right_i_jpos1]
                    )
            
                    contact_angle_left = jnp.rad2deg(
                        math.pi / 2 + jnp.arctan(x_val_left_j0 - x_val_left_jpos1)
                    )
                    contact_angle_right = jnp.rad2deg(
                        math.pi / 2 + jnp.arctan(x_val_right_jpos1 - x_val_right_j0)
                    )
            
                    return contact_angle_left, contact_angle_right
            --- End of contact_angle.py ---

            __pycache__/
        collision/
            __init__.py
            --- Code in __init__.py ---
            from .collision_BGK import CollisionBGK
            from .collision_MRT import CollisionMRT
            from .source import SourceTerm
            --- End of __init__.py ---

            collision_MRT.py
            --- Code in collision_MRT.py ---
            import jax.numpy as jnp
            from .base import CollisionBase
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            
            # Moment transformation matrix for D2Q9 lattice
            M = jnp.array(
                [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [-4, -1, -1, -1, -1, 2, 2, 2, 2],
                    [4, -2, -2, -2, -2, 1, 1, 1, 1],
                    [0, 1, 0, -1, 0, 1, -1, -1, 1],
                    [0, -2, 0, 2, 0, 1, -1, -1, 1],
                    [0, 0, 1, 0, -1, 1, 1, -1, -1],
                    [0, 0, -2, 0, 2, 1, 1, -1, -1],
                    [0, 1, -1, 1, -1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 1, -1, 1, -1],
                ],
            )
            M_INV = jnp.linalg.inv(M)
            
            
            class CollisionMRT(CollisionBase):
                """
                Implements the MRT (Multiple Relaxation Time) collision operator for LBM.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, k_diag=None, **kwargs):
                    """
                    Initialize the MRT collision operator.
            
                    Args:
                        grid (Grid): Grid object containing simulation domain information
                        lattice (Lattice): Lattice object containing lattice properties
                        k_diag (jnp.ndarray, optional): Diagonal relaxation rates for moments.
                        kwargs: Optional relaxation rates for specific moments.
                    """
                    super().__init__(grid, lattice)
                    if k_diag is None:
                        k_diag = jnp.array(
                            [
                                1 / kwargs.get("k0", 1.0),
                                1 / kwargs.get("kb", 1.0),
                                1 / kwargs.get("k2", 1.0),
                                1 / kwargs.get("k0", 1.0),
                                1 / kwargs.get("k4", 1.0),
                                1 / kwargs.get("k0", 1.0),
                                1 / kwargs.get("k4", 1.0),
                                1 / kwargs.get("kv", 0.8),
                                1 / kwargs.get("kv", 0.8),
                            ],
                        )
                    self.K = k_diag
            
                def __call__(
                    self, f: jnp.ndarray, feq: jnp.ndarray, source: jnp.ndarray = None
                ) -> jnp.ndarray:
                    """
                    Perform the MRT collision step.
            
                    Args:
                        f (jnp.ndarray): Distribution function.
                        feq (jnp.ndarray): Equilibrium distribution function.
                        source (jnp.ndarray, optional): Source term.
            
                    Returns:
                        jnp.ndarray: Post-collision distribution function.
                    """
                    # Transform to moment space
                    m = jnp.einsum("ij,xyj->xyi", M, f[..., 0])
                    m_eq = jnp.einsum("ij,xyj->xyi", M, feq[..., 0])
                    if source is None:
                        S = 0.0
                    else:
                        S = jnp.einsum("ij,xyj->xyi", M, source[..., 0])
                    # Relaxation in moment space
                    m_post = m - self.K * (m - m_eq) + (1 - 0.5 * self.K) * S
                    # Transform back to distribution space
                    f_post = jnp.einsum("ij,xyi->xyj", M_INV, m_post)[..., None]
                    return f_post
            --- End of collision_MRT.py ---

            collision_BGK.py
            --- Code in collision_BGK.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from .base import CollisionBase
            
            
            class CollisionBGK(CollisionBase):
                """
                Implements the BGK (Bhatnagar-Gross-Krook) collision operator for LBM.
                Optionally supports a source term.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, tau: float) -> None:
                    """
                    Initialize the CollisionBGK operator.
            
                    Args:
                        grid (Grid): Grid object containing simulation domain information
                        lattice (Lattice): Lattice object containing lattice properties
                        tau (float): Relaxation time parameter
                    """
                    super().__init__(grid, lattice)
                    self.tau: float = tau
            
                def __call__(
                    self, f: jnp.ndarray, feq: jnp.ndarray, source: jnp.ndarray = None
                ) -> jnp.ndarray:
                    """
                    Perform the BGK collision step.
            
                    Args:
                        f (jnp.ndarray): Distribution function.
                        feq (jnp.ndarray): Equilibrium distribution function.
                        source (jnp.ndarray, optional): Source term.
            
                    Returns:
                        jnp.ndarray: Post-collision distribution function.
                    """
                    if source is None:
                        # Standard BGK collision without source term
                        return (1 - (1 / self.tau)) * f + (1 / self.tau) * feq
                    else:
                        # BGK collision with source term
                        return (
                            (1 - (1 / self.tau)) * f
                            + (1 / self.tau) * feq
                            + (1 - (1 / (2 * self.tau))) * source
                        )
            --- End of collision_BGK.py ---

            source.py
            --- Code in source.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.operators.differential.gradient import Gradient
            
            
            class SourceTerm:
                """
                Callable class to calculate the source term for the LBM equation.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice):
                    """
                    Initialize the source term calculator.
            
                    Args:
                        grid (Grid): Grid object containing simulation domain information
                        lattice (Lattice): Lattice object containing lattice properties
                    """
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.w = lattice.w
                    self.cx = lattice.c[0]
                    self.cy = lattice.c[1]
                    self.gradient = Gradient(lattice)
            
                def __call__(
                    self, rho: jnp.ndarray, u: jnp.ndarray, force: jnp.ndarray
                ) -> jnp.ndarray:
                    """
                    Calculate the source term for the LBM equation.
            
                    Args:
                        rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                        u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                        force (jnp.ndarray): Force field, shape (nx, ny, 1, 2)
            
                    Returns:
                        jnp.ndarray: Source term, shape (nx, ny, q, 1)
                    """
                    nx, ny, q = self.nx, self.ny, self.q
                    w = self.w
                    c = (self.cx, self.cy)
                    d = self.d
                    gradient = self.gradient
            
                    # Extract 2D data from 4D arrays
                    u_2d = u[:, :, 0, :]  # Shape: (nx, ny, 2)
                    force_2d = force[:, :, 0, :]  # Shape: (nx, ny, 2)
                    rho_2d = rho[:, :, 0, 0]  # Shape: (nx, ny)
            
                    # Calculate gradient of rho
                    grad_rho = gradient(rho)  # Shape: (nx, ny, 1, 2)
                    grad_rho_2d = grad_rho[:, :, 0, :]  # Shape: (nx, ny, 2)
            
                    def source_term(u_2d_, force_2d_, grad_rho_2d_):
                        """
                        Compute the source term for each lattice direction.
            
                        Args:
                            u_2d_ (jnp.ndarray): Velocity field, shape (nx, ny, 2)
                            force_2d_ (jnp.ndarray): Force field, shape (nx, ny, 2)
                            grad_rho_2d_ (jnp.ndarray): Gradient of density, shape (nx, ny, 2)
            
                        Returns:
                            jnp.ndarray: Source term, shape (nx, ny, q)
                        """
                        cx, cy = c[0], c[1]
                        fx, fy = force_2d_[:, :, 0], force_2d_[:, :, 1]
                        ux, uy = u_2d_[:, :, 0], u_2d_[:, :, 1]
                        grad_rho_x, grad_rho_y = grad_rho_2d_[:, :, 0], grad_rho_2d_[:, :, 1]
            
                        fx_cor = fx + (grad_rho_x / 3)
                        fy_cor = fy + (grad_rho_y / 3)
                        source_ = jnp.zeros((nx, ny, q))
            
                        for i in range(q):
                            # Compute the source term for each direction
                            source_ = source_.at[:, :, i].set(
                                w[i]
                                * (
                                    3 * (cx[i] * fx + cy[i] * fy)
                                    + 9
                                    * (cx[i] * fx_cor + cy[i] * fy_cor)
                                    * (cx[i] * ux + cy[i] * uy)
                                    - 3 * (ux * fx_cor + uy * fy_cor)
                                    + 0.5
                                    * (3 * (cx[i] * cx[i] + cy[i] * cy[i]) - d)
                                    * (ux * grad_rho_x + uy * grad_rho_y)
                                )
                            )
            
                        return source_
            
                    source_2d = source_term(u_2d, force_2d, grad_rho_2d)
            
                    # Convert to 4D format: (nx, ny, q, 1)
                    source_4d = jnp.expand_dims(source_2d, axis=-1)
            
                    return source_4d
            --- End of source.py ---

            base.py
            --- Code in base.py ---
            from abc import ABC
            
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            
            
            class CollisionBase(ABC):
                """
                Base class for LBM collision operators.
                Implements the BGK collision operators with source terms.
                Subclasses should implement the __call__ method.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice) -> None:
                    """
                    Initializes the grid and lattice parameters required for the collision step.
                    Args:
                        grid (Grid): Grid object containing simulation domain information
                        lattice (Lattice): Lattice object containing lattice properties
                    """
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
            
                def __call__(self, f: jnp.ndarray, feq: jnp.ndarray) -> jnp.ndarray:
                    """
                    Perform the collision step of the LBM.
            
                    Needs to be implemented by the subclass.
                    """
                    pass
            --- End of base.py ---

            __pycache__/
                base.cpython-312.pyc
                collision_MRT.cpython-312.pyc
                collision_BGK.cpython-312.pyc
                source.cpython-312.pyc
                __init__.cpython-312.pyc
    utils/
        plotting.py
        --- Code in plotting.py ---
        import os
        import numpy as np
        import matplotlib.pyplot as plt
        
        
        def visualise(sim_instance, title="LBM Simulation Results"):
            """
            Visualizes simulation results by loading and plotting every saved timestep.
            This version includes a vector plot overlay on the velocity magnitude heatmap.
        
            Args:
                sim_instance: The completed simulation instance from the Run class.
                title (str): The base title for the plots.
            """
            try:
                # Get the directory where data files are stored
                data_dir = sim_instance.io_handler.data_dir
        
                # Create a new directory within the run to store the plots
                plot_dir = os.path.join(sim_instance.io_handler.run_dir, "plots")
                os.makedirs(plot_dir, exist_ok=True)
                print(f"Saving plots to: {plot_dir}")
        
                # Get all data files and sort them by timestep
                files = [f for f in os.listdir(data_dir) if f.endswith(".npz")]
                if not files:
                    print("No data files found to visualize.")
                    return
        
                # Sort files based on the iteration number in the filename
                files.sort(key=lambda f: int(f.split("_")[-1].split(".")[0]))
        
                # Loop through each timestep file and generate a plot
                for filename in files:
                    file_path = os.path.join(data_dir, filename)
                    timestep = int(filename.split("_")[-1].split(".")[0])
        
                    data = np.load(file_path)
                    final_rho = data["rho"]
                    final_u = data["u"]
                    final_force = data.get("force", None)
        
                    fig, axes = plt.subplots(
                        1,
                        2 if final_force is None else 3,
                        figsize=(12 if final_force is None else 18, 5),
                    )
        
                    # Plot density
                    im1 = axes[0].imshow(
                        final_rho[:, :, 0, 0].T, origin="lower", cmap="viridis"
                    )
                    axes[0].set_title(f"Density (t={timestep})")
                    plt.colorbar(im1, ax=axes[0], label="Density")
        
                    # --- Velocity Plotting with Vector Overlay ---
        
                    # 1. Plot velocity magnitude heatmap
                    vel_mag = np.sqrt(final_u[:, :, 0, 0] ** 2 + final_u[:, :, 0, 1] ** 2)
                    im2 = axes[1].imshow(vel_mag.T, origin="lower", cmap="plasma")
                    axes[1].set_title("Velocity Magnitude & Vectors")
                    plt.colorbar(im2, ax=axes[1], label="Velocity Magnitude")
        
                    # 2. Overlay velocity vector plot (quiver)
                    nx, ny = final_u.shape[0], final_u.shape[1]
                    x = np.arange(0, nx)
                    y = np.arange(0, ny)
                    X, Y = np.meshgrid(x, y)
        
                    # Extract velocity components
                    U = final_u[:, :, 0, 0]
                    V = final_u[:, :, 0, 1]
        
                    # Downsample the vectors to avoid a cluttered plot
                    # Plot one vector every `skip` grid points
                    skip = 10
        
                    # Plotting quiver requires transposing U and V to match the meshgrid and imshow orientation
                    axes[1].quiver(
                        X[::skip, ::skip],
                        Y[::skip, ::skip],
                        U.T[::skip, ::skip],
                        V.T[::skip, ::skip],
                        color="white",
                        scale=None,
                        scale_units="xy",
                        angles="xy",
                    )
        
                    # --- End of Velocity Plotting Section ---
        
                    if final_force is not None:
                        # Plot force magnitude and vectors
                        force_mag = np.sqrt(
                            final_force[:, :, 0, 0] ** 2 + final_force[:, :, 0, 1] ** 2
                        )
                        im3 = axes[2].imshow(force_mag.T, origin="lower", cmap="cividis")
                        axes[2].set_title("Force Magnitude & Vectors")
                        plt.colorbar(im3, ax=axes[2], label="Force Magnitude")
                        U_force = final_force[:, :, 0, 0]
                        V_force = final_force[:, :, 0, 1]
                        axes[2].quiver(
                            X[::skip, ::skip],
                            Y[::skip, ::skip],
                            U_force.T[::skip, ::skip],
                            V_force.T[::skip, ::skip],
                            color="white",
                            scale=None,
                            scale_units="xy",
                            angles="xy",
                        )
        
                    for ax in axes:
                        ax.set_xlabel("x")
                        ax.set_ylabel("y")
        
                    plt.suptitle(f"{title} - Timestep {timestep}")
                    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        
                    # Save the figure to the plots directory
                    plot_filename = os.path.join(plot_dir, f"timestep_{timestep}.png")
                    plt.savefig(plot_filename)
                    plt.close(fig)  # Close the figure to free up memory
        
                print(f"Finished generating plots for all {len(files)} timesteps.")
        
            except ImportError:
                print("Matplotlib not found. Please install it to visualize results.")
            except Exception as e:
                print(f"An error occurred during visualization: {e}")
        --- End of plotting.py ---

        io.py
        --- Code in io.py ---
        import json
        import jax.numpy as jnp
        from typing import Any, Dict
        from pathlib import Path
        import numpy as np
        from datetime import datetime
        import os
        
        
        class CustomJSONEncoder(json.JSONEncoder):
            def default(self, obj):
                # Handle JAX arrays
                if isinstance(obj, jnp.ndarray):
                    return obj.tolist()
                # Handle custom force objects
                if hasattr(obj, "__class__") and hasattr(obj, "__dict__"):
                    result = {
                        "__class__": obj.__class__.__name__,
                        "__module__": obj.__class__.__module__,
                    }
                    for key, value in obj.__dict__.items():
                        try:
                            json.dumps(value, cls=CustomJSONEncoder)
                            result[key] = value
                        except (TypeError, ValueError):
                            result[key] = str(value)
                    return result
                # Handle other numpy arrays if present
                if hasattr(obj, "tolist"):
                    return obj.tolist()
                return super().default(obj)
        
        
        class SimulationIO:
            """
            Handles all I/O operations for the simulation, including logging and saving results.
            """
        
            def __init__(self, base_dir: str = "results", config: Dict = None):
                """
                Initializes the IO handler.
        
                Args:
                    base_dir (str): The base directory to store simulation results.
                    config (Dict, optional): A dictionary containing the simulation configuration to save.
                """
                self.base_dir = base_dir
                self.run_dir = self._create_timestamped_directory()
                self.data_dir = os.path.join(self.run_dir, "data")
                os.makedirs(self.data_dir, exist_ok=True)
        
                if config:
                    self.save_config(config)
        
            def _create_timestamped_directory(self) -> str:
                """Creates a unique, timestamped directory for a single simulation run."""
                timestamp = datetime.now().strftime("%Y-%m-%d/%H-%M-%S")
                run_dir = os.path.join(self.base_dir, timestamp)
                os.makedirs(run_dir, exist_ok=True)
                print(f"Created results directory: {run_dir}")
                return run_dir
        
            def save_config(self, config: Dict):
                """Saves the simulation configuration to a JSON file using CustomJSONEncoder."""
                config_path = os.path.join(self.run_dir, "config.json")
        
                # Rename boundary condition details if present (avoids duplication)
                if "bc_config" in config:
                    config["boundary_conditions"] = config.pop("bc_config")
        
                with open(config_path, "w") as f:
                    json.dump(config, f, indent=4, cls=CustomJSONEncoder)
                print(f"Configuration saved to {config_path}")
        
            def save_data_step(self, iteration: int, data: Dict[str, np.ndarray]):
                """Saves the data for a single timestep to a compressed .npz file."""
                filename = os.path.join(self.data_dir, f"timestep_{iteration}.npz")
                np.savez(filename, **data)
        --- End of io.py ---

        __init__.py
        --- Code in __init__.py ---
        from .io import SimulationIO
        from .plotting import visualise
        from .profiler import JAXProfiler
        from .timing import time_function, TIMING_ENABLED
        
        __all__ = [
            "SimulationIO",
            "visualise",
            "JAXProfiler",
            "time_function",
            "TIMING_ENABLED",
        ]
        --- End of __init__.py ---

        timing.py
        --- Code in timing.py ---
        import time
        from functools import wraps
        import jax.numpy as jnp
        
        TIMING_ENABLED = False  # Default: no timing print; set to True to enable
        
        
        def time_function(enable_timing=TIMING_ENABLED):
            def decorator(func):
                @wraps(func)
                def wrapper(*args, **kwargs):
                    if not enable_timing:
                        return func(*args, **kwargs)
                    start = time.perf_counter()
                    result = func(*args, **kwargs)
                    # Block until computation completes (important for JAX)
                    if hasattr(result, "block_until_ready"):
                        result.block_until_ready()
                    elif isinstance(result, tuple):
                        # Handle multiple return values
                        for item in result:
                            if hasattr(item, "block_until_ready"):
                                item.block_until_ready()
                    end = time.perf_counter()
                    print(f"{func.__name__}: {end - start:.4f} seconds")
                    return result
        
                return wrapper
        
            return decorator
        --- End of timing.py ---

        profiler.py
        --- Code in profiler.py ---
        import jax
        from jax import profiler
        import os
        
        # Have not managed to get this to work, removed the profiling from the run class.
        
        
        class JAXProfiler:
            def __init__(self, output_dir="./profiler_output", create_perfetto_link=True):
                self.output_dir = output_dir
                self.create_perfetto_link = create_perfetto_link
                os.makedirs(output_dir, exist_ok=True)
        
            def __enter__(self):
                # Configure profiler options for better traces
                options = jax.profiler.ProfileOptions()
                options.host_tracer_level = 2  # Include high-level program execution details
                options.python_tracer_level = 1  # Enable Python tracing
        
                profiler.start_trace(self.output_dir, profiler_options=options)
                return self
        
            def __exit__(self, exc_type, exc_val, exc_tb):
                profiler.stop_trace()
                if self.create_perfetto_link:
                    print(f"Profiling completed! Trace saved to: {self.output_dir}")
                    print("To view the trace, you can:")
                    print("1. Use TensorBoard: tensorboard --logdir=" + self.output_dir)
                    print("2. Or upload the .pb files to https://ui.perfetto.dev/")
        --- End of profiler.py ---

        __pycache__/
            io.cpython-312.pyc
            profiler.cpython-312.pyc
            timing.cpython-312.pyc
            __init__.cpython-312.pyc
            plotting.cpython-312.pyc
    __pycache__/
        __init__.cpython-312.pyc
    lattice/
        __init__.py
        --- Code in __init__.py ---
        from .lattice import Lattice
        --- End of __init__.py ---

        lattice.py
        --- Code in lattice.py ---
        import numpy as np
        import re
        from numpy import ndarray
        from typing import Any
        
        
        class Lattice(object):
        
            def __init__(self, name: str) -> None:
                self.name: str = name
                dq = re.findall(r"\d+", name)
                self.d: int = int(dq[0])
                self.q: int = int(dq[1])
        
                # Construct the properties of a lattice
                self.c: ndarray = self.construct_lattice_velocities
                self.w: ndarray = self.construct_lattice_weigths
                self.opp_indices: ndarray = self.construct_opposite_indices
                self.main_indices: ndarray = self.construct_main_indices
                self.right_indices: ndarray = self.construct_right_indices
                self.left_indices: ndarray = self.construct_left_indices
                self.top_indices: ndarray = self.construct_top_indices
                self.bottom_indices: ndarray = self.construct_bottom_indices
                if self.d == 3:
                    self.front_indices: ndarray = self.construct_front_indices
                    self.back_indices: ndarray = self.construct_back_indices
        
            @property
            def construct_lattice_velocities(self) -> ndarray:
                if self.name == "D2Q9":
                    cx = [0, 1, 0, -1, 0, 1, -1, -1, 1]
                    cy = [0, 0, 1, 0, -1, 1, 1, -1, -1]
                    c = np.array(tuple(zip(cx, cy)))
                else:
                    raise ValueError(
                        "Lattice not supported, D2Q9 is currently the only supported lattice."
                    )
        
                return c.T
        
            @property
            def construct_lattice_weigths(self) -> ndarray:
                if self.name == "D2Q9":
                    w = np.array(
                        [4 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 36, 1 / 36, 1 / 36, 1 / 36]
                    )
                elif self.name == "D3Q15":
                    raise NotImplementedError("Dimension larger than 2 not supported.")
                else:
                    raise ValueError(
                        "Lattice not supported, D2Q9 is currently the only supported lattice."
                    )
        
                return w
        
            @property
            def construct_opposite_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.array([c.tolist().index((-c[i]).tolist()) for i in range(self.q)])
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_main_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_right_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 0] == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_left_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 0] == -1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_top_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 1] == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_bottom_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 1] == -1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_front_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    raise ValueError("Only have front indices in 3D.")
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_back_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    raise ValueError("Only have front indices in 3D.")
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        --- End of lattice.py ---

        __pycache__/
            lattice.cpython-312.pyc
            __init__.cpython-312.pyc
    simulations/
        singlephase.py
        --- Code in singlephase.py ---
        from .base import BaseSimulation
        from wblbm.operators.update.update import Update
        from wblbm.operators.macroscopic.macroscopic import Macroscopic
        from wblbm.operators.initialise.init import Initialise
        import jax.numpy as jnp
        
        
        class SinglePhaseSimulation(BaseSimulation):
            def __init__(
                self,
                grid_shape,
                lattice_type="D2Q9",
                tau=1.0,
                nt=1000,
                force_enabled=False,
                force_obj=None,
                bc_config=None,
                collision_scheme="bgk",
                k_diag=None,
                **kwargs
            ):
                super().__init__(grid_shape, lattice_type, tau, nt)
        
                # Set simulation type flags
                self.multiphase = False
                self.wetting_enabled = False
        
                self.force_enabled = force_enabled
                self.force_obj = force_obj
                self.bc_config = bc_config
                self.collision_scheme = collision_scheme
                self.k_diag = k_diag
                self.setup_operators()
        
            def setup_operators(self):
                self.initialiser = Initialise(self.grid, self.lattice)
                self.update = Update(
                    self.grid,
                    self.lattice,
                    self.tau,
                    bc_config=self.bc_config,
                    force_enabled=self.force_enabled,
                    collision_scheme=self.collision_scheme,
                    kvec=self.k_diag,
                )
                self.macroscopic = Macroscopic(
                    self.grid, self.lattice, force_enabled=self.force_enabled
                )
                if self.bc_config:
                    from wblbm.operators.boundary_condition.boundary_condition import (
                        BoundaryCondition,
                    )
        
                    self.boundary_condition = BoundaryCondition(
                        self.grid, self.lattice, self.bc_config
                    )
        
            def initialize_fields(self, init_type="standard"):
                return self.initialiser.initialise_standard()
        
            def run_timestep(self, fprev, it):
                force_ext = None
                if self.force_enabled and self.force_obj:
                    rho = jnp.sum(fprev, axis=2, keepdims=True)
                    force_ext = self.force_obj.compute_force(rho)
                fnext = (
                    self.update(fprev, force=force_ext)
                    if self.force_enabled
                    else self.update(fprev)
                )
                return fnext
        --- End of singlephase.py ---

        __init__.py
        --- Code in __init__.py ---
        --- End of __init__.py ---

        wetting.py
        --- Code in wetting.py ---
        from .multiphase import MultiphaseSimulation
        from wblbm.operators.update.update_multiphase_wetting import UpdateMultiphaseWetting
        from wblbm.operators.macroscopic.macroscopic_multiphase_wetting import (
            MacroscopicWetting,
        )
        
        
        class WettingSimulation(MultiphaseSimulation):
            def __init__(
                self,
                grid_shape,
                phi_value=1.0,
                d_rho_value=0.0,
                hysteresis_params=None,
                collision_scheme="bgk",
                k_diag=None,
                **kwargs
            ):
                super().__init__(
                    grid_shape, collision_scheme=collision_scheme, k_diag=k_diag, **kwargs
                )
                self.macroscopic = None
                self.update = None
                self.hysteresis = None
                self.phi_value = phi_value
                self.d_rho_value = d_rho_value
                self.hysteresis_params = hysteresis_params
                self.multiphase = True
                self.wetting_enabled = True
        
            def setup_operators(self):
                super().setup_operators()
                # Override with wetting-specific operators
                self.update = UpdateMultiphaseWetting(
                    self.grid,
                    self.lattice,
                    self.tau,
                    self.kappa,
                    self.interface_width,
                    self.rho_l,
                    self.rho_v,
                    wetting_enabled=True,
                    collision_scheme=self.collision_scheme,
                    kvec=self.k_diag,
                )
                self.macroscopic = MacroscopicWetting(
                    self.grid,
                    self.lattice,
                    self.kappa,
                    self.interface_width,
                    self.rho_l,
                    self.rho_v,
                    wetting_enabled=True,
                )
                # Setup wetting-specific components
                if self.hysteresis_params:
                    defaults = {
                        "receding_ca_hydrophobic": None,
                        "advancing_ca_hydrophilic": None,
                        "receding_ca_hydrophilic": None,
                        "cll_threshold": None,
                        "ca_threshold": None,
                        "change_d_rho": None,
                        "change_phi": None,
                        "while_limiter": None,
                        "nx": None,
                        "phi_val": None,
                        "d_rho_val": None,
                        "w": None,
                    }
                    for key, value in defaults.items():
                        self.hysteresis_params.setdefault(key, value)
                    from wblbm.operators.wetting.hysteresis import Hysteresis
        
                    self.hysteresis = Hysteresis(**self.hysteresis_params)
        
            def initialize_fields(self, init_type="wetting"):
                if init_type == "wetting":
                    return self.initialiser.initialise_wetting(
                        self.rho_l, self.rho_v, self.interface_width
                    )
                else:
                    return super().initialize_fields(init_type)
        
            def run_timestep(self, fprev, it):
                # You may want to add hysteresis logic here if needed
                return self.update(fprev)
        --- End of wetting.py ---

        multiphase.py
        --- Code in multiphase.py ---
        from .base import BaseSimulation
        from wblbm.operators.update.update_multiphase import UpdateMultiphase
        from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
        from wblbm.operators.initialise.init import Initialise
        import jax.numpy as jnp
        
        
        class MultiphaseSimulation(BaseSimulation):
            def __init__(
                self,
                grid_shape,
                lattice_type="D2Q9",
                tau=1.0,
                nt=1000,
                kappa=0.1,
                rho_l=1.0,
                rho_v=0.1,
                interface_width=4,
                force_enabled=False,
                force_obj=None,
                bc_config=None,
                collision_scheme="bgk",
                k_diag=None,
                **kwargs
            ):
                super().__init__(grid_shape, lattice_type, tau, nt)
                self.kappa = kappa
                self.rho_l = rho_l
                self.rho_v = rho_v
                self.interface_width = interface_width
                self.force_enabled = force_enabled
                self.force_obj = force_obj
                self.bc_config = bc_config
                self.collision_scheme = collision_scheme
                self.k_diag = k_diag
                self.setup_operators()
                self.multiphase = True
        
            def setup_operators(self):
                self.initialiser = Initialise(self.grid, self.lattice)
                self.update = UpdateMultiphase(
                    self.grid,
                    self.lattice,
                    self.tau,
                    self.kappa,
                    self.interface_width,
                    self.rho_l,
                    self.rho_v,
                    self.bc_config,
                    self.force_enabled,
                    collision_scheme=self.collision_scheme,
                    kvec=self.k_diag,
                )
                self.macroscopic = MacroscopicMultiphase(
                    self.grid,
                    self.lattice,
                    self.kappa,
                    self.interface_width,
                    self.rho_l,
                    self.rho_v,
                    self.force_enabled,
                )
        
            def initialize_fields(self, init_type="multiphase_droplet"):
                if init_type == "multiphase_droplet":
                    return self.initialiser.initialise_multiphase_droplet(
                        self.rho_l, self.rho_v, self.interface_width
                    )
                elif init_type == "multiphase_bubble":
                    return self.initialiser.initialise_multiphase_bubble(
                        self.rho_l, self.rho_v, self.interface_width
                    )
                else:
                    return self.initialiser.initialise_standard()
        
            def run_timestep(self, fprev, it):
                force_ext = None
                if self.force_enabled and self.force_obj:
                    rho = jnp.sum(fprev, axis=2, keepdims=True)
                    force_ext = self.force_obj.compute_force(rho, self.rho_l, self.rho_v)
                fnext = (
                    self.update(fprev, force=force_ext)
                    if self.force_enabled
                    else self.update(fprev)
                )
        
                return fnext
        --- End of multiphase.py ---

        base.py
        --- Code in base.py ---
        from abc import ABC, abstractmethod
        from wblbm.grid import Grid
        from wblbm.lattice import Lattice
        
        
        class BaseSimulation(ABC):
            def __init__(self, grid_shape, lattice_type="D2Q9", tau=1.0, nt=1000):
                self.grid_shape = grid_shape
                self.nt = nt
                self.grid = Grid(grid_shape)
                self.lattice = Lattice(lattice_type)
                self.tau = tau
        
                self.update = None
                self.initialiser = None
                self.macroscopic = None
        
                # Add simulation type flags
                self.multiphase = False
                self.wetting_enabled = False
        
            @abstractmethod
            def setup_operators(self):
                """Setup simulation-specific operators"""
                pass
        
            @abstractmethod
            def initialize_fields(self, init_type):
                """Initialize simulation fields"""
                pass
        
            @abstractmethod
            def run_timestep(self, fprev, it):
                """Execute one timestep"""
                pass
        --- End of base.py ---

        __pycache__/
            base.cpython-312.pyc
            singlephase.cpython-312.pyc
            multiphase.cpython-312.pyc
            __init__.cpython-312.pyc
    run/
        run.py
        --- Code in run.py ---
        import numpy as np
        import jax.numpy as jnp
        
        
        class SimulationFactory:
            @staticmethod
            def create_simulation(simulation_type, **kwargs):
                if simulation_type == "singlephase":
                    from wblbm.simulations.singlephase import SinglePhaseSimulation
        
                    return SinglePhaseSimulation(**kwargs)
                elif simulation_type == "multiphase":
                    from wblbm.simulations.multiphase import MultiphaseSimulation
        
                    return MultiphaseSimulation(**kwargs)
                elif simulation_type == "wetting":
                    from wblbm.simulations.wetting import WettingSimulation
        
                    return WettingSimulation(**kwargs)
                else:
                    raise ValueError(f"Unknown simulation type: {simulation_type}")
        
        
        class Run:
            """
            Main class to configure and run lattice Boltzmann simulations using the simulation factory.
            """
        
            def __init__(
                self,
                simulation_type="singlephase",
                save_interval=100,
                results_dir="results",
                **kwargs,
            ):
                # Allow collision config as a dict or CLI/JSON entry and pass it untouched
                collision_cfg = kwargs.pop("collision", None)
                if collision_cfg is not None:
                    # Flatten collision config into kwargs for simulation constructors
                    kwargs.update(collision_cfg)
                self.simulation = SimulationFactory.create_simulation(simulation_type, **kwargs)
                self.save_interval = save_interval
                self.results_dir = results_dir
                self.config = self._build_config(
                    simulation_type=simulation_type,
                    save_interval=save_interval,
                    results_dir=results_dir,
                    **kwargs,
                )
                from wblbm.utils.io import SimulationIO
        
                self.io_handler = SimulationIO(base_dir=results_dir, config=self.config)
        
            def _build_config(self, **kwargs):
                # Simple config builder for demonstration; extend as needed
                return dict(**kwargs)
        
            def _save_data(self, it, fprev):
                # Save data using the simulation's macroscopic operator
                if hasattr(self.simulation, "macroscopic"):
                    macroscopic = self.simulation.macroscopic
                    try:
                        if self.config.get("force_enabled") and self.config.get("force_obj"):
                            rho = jnp.sum(fprev, axis=2, keepdims=True)
                            force = self.config.get("force_obj")
                            if self.config.get("simulation_type") == "multiphase":
                                force_ext = force.compute_force(
                                    rho, self.config.get("rho_l"), self.config.get("rho_v")
                                )
                            else:
                                force_ext = force.compute_force(rho)
                            result = macroscopic(fprev, force_ext)
                        else:
                            result = macroscopic(fprev)
                        if isinstance(result, tuple) and len(result) == 3:
                            rho, u, force = result
                            data_to_save = {
                                "rho": np.array(rho),
                                "u": np.array(u),
                                "force": np.array(force),
                            }
                        else:
                            rho, u = result
                            data_to_save = {
                                "rho": np.array(rho),
                                "u": np.array(u),
                            }
                    except Exception:
                        data_to_save = {"f": np.array(fprev)}
                else:
                    data_to_save = {"f": np.array(fprev)}
                self.io_handler.save_data_step(it, data_to_save)
        
            def run(self, init_type="standard", verbose=True):
                fprev = self.simulation.initialize_fields(init_type)
                nt = getattr(self.simulation, "nt", 1000)
                if verbose:
                    print(f"Starting LBM simulation with {nt} time steps...")
                    print(
                        f"Config -> Grid: {self.simulation.grid_shape}, Multiphase: {self.simulation.multiphase}, Wetting: {self.simulation.wetting_enabled}, Force: {self.simulation.force_enabled}"
                    )
                for it in range(nt):
                    fprev = self.simulation.run_timestep(fprev, it)
                    if it % self.save_interval == 0 or it == nt - 1:
                        self._save_data(it, fprev)
                        if verbose and hasattr(self.simulation, "macroscopic"):
                            result = self.simulation.macroscopic(fprev)
                            if isinstance(result, tuple) and len(result) >= 2:
                                rho, u = result[:2]
                                avg_rho = np.mean(rho)
                                max_u = np.max(np.sqrt(u[..., 0] ** 2 + u[..., 1] ** 2))
                                print(
                                    f"Step {it}/{nt}: avg_rho={avg_rho:.4f}, max_u={max_u:.6f}"
                                )
                if verbose:
                    print("Simulation completed!")
                    print(f"Results saved in: {self.io_handler.run_dir}")
        --- End of run.py ---

        __init__.py
        --- Code in __init__.py ---
        from .run import Run
        --- End of __init__.py ---

        __pycache__/
            run.cpython-312.pyc
            __init__.cpython-312.pyc
    grid/
        grid.py
        --- Code in grid.py ---
        from typing import Tuple
        
        import numpy as np
        
        
        class Grid(object):
            def __init__(self, shape: Tuple[int, ...]):
                self.shape = shape
                self.dim = len(self.shape)
                if self.dim == 2:
                    self.nx, self.ny = self.shape
                if self.dim == 3:
                    self.nx, self.ny, self.nz = self.shape
        
            def get_edges(self):
                grid = np.indices(self.shape)
                if self.dim == 2:
                    edges = {
                        "left": (grid[0][0, :], grid[1][0, :]),
                        "right": (grid[0][-1, :], grid[1][-1, :]),
                        "bottom": (grid[0][:, 0], grid[1][:, 0]),
                        "top": (grid[0][:, -1], grid[1][:, -1]),
                    }
                    return edges
                elif self.dim == 3:
                    edges = {
                        "left": (grid[0][0, :, :], grid[1][0, :, :], grid[2][0, :, :]),
                        "right": (grid[0][-1, :, :], grid[1][-1, :, :], grid[2][-1, :, :]),
                        "bottom": (grid[0][:, 0, :], grid[1][:, 0, :], grid[2][:, 0, :]),
                        "top": (grid[0][:, -1, :], grid[1][:, -1, :], grid[2][:, -1, :]),
                        "front": (grid[0][:, :, 0], grid[1][:, :, 0], grid[2][:, :, 0]),
                        "back": (grid[0][:, :, -1], grid[1][:, :, -1], grid[2][:, :, -1]),
                    }
                    return edges
                else:
                    raise NotImplementedError(
                        "Edge extraction for grids with dim != 2 or 3 is not implemented."
                    )
        --- End of grid.py ---

        __init__.py
        --- Code in __init__.py ---
        from .grid import Grid
        --- End of __init__.py ---

        __pycache__/
            grid.cpython-312.pyc
            __init__.cpython-312.pyc
example/
    tests/
        single_phase_gravity_test.py
        --- Code in single_phase_gravity_test.py ---
        import numpy as np
        from wblbm.run import Run
        from wblbm import GravityForceSinglephase
        from wblbm import visualise
        import jax
        
        # this line is added for debugging
        # jax.config.update("jax_disable_jit", True)
        
        
        def test_single_phase_gravity_simulation():
            """Test a single-phase LBM simulation with gravity."""
            print("\n=== Single-Phase LBM Simulation with Gravity Test ===")
        
            grid_shape = (200, 200)
            tau = 1.0
            nt = 1000
            save_interval = 100
        
            force_g = 0.01
            inclination_angle = 0
            gravity = GravityForceSinglephase(
                grid_shape[0], grid_shape[1], 2, force_g, inclination_angle
            )
        
            bc_config = {"left": "bounce-back", "right": "bounce-back"}
        
            sim = Run(
                simulation_type="singlephase",
                grid_shape=grid_shape,
                lattice_type="D2Q9",
                tau=tau,
                nt=nt,
                save_interval=save_interval,
                force_enabled=True,
                force_obj=gravity,
                bc_config=bc_config,
            )
            sim.run(init_type="standard", verbose=True)
            return sim
        
        
        if __name__ == "__main__":
            print("Testing Single-Phase LBM Codebase with Gravity")
            print("=" * 60)
        
            # Run simulation
            sim_single_phase_gravity = test_single_phase_gravity_simulation()
        
            # Visualize results
            print("\n=== Visualizing Results ===")
            visualise(sim_single_phase_gravity, "Single-Phase with Gravity Force")
        
            print("\nTest completed!")
        --- End of single_phase_gravity_test.py ---

        test_bc_multiphase.py
        --- Code in test_bc_multiphase.py ---
        import numpy as np
        from wblbm.run import Run
        from wblbm import visualise
        
        
        def test_boundary_conditions():
            """
            Test various boundary conditions in the LBM simulation.
        
            This function configures a small multiphase simulation with custom boundary conditions,
            runs it for a limited number of steps, and visualizes the results to verify BC behavior.
            """
            print("\n=== Testing LBM Boundary Conditions ===")
        
            # Define boundary configuration
            bc_config = {
                "top": "bounce-back",  # No-slip wall at top
                "bottom": "bounce-back",  # Symmetric boundary at bottom
                "left": "bounce-back",  # Periodic left-right wrapping
                "right": "bounce-back",
            }
        
            # Set up the simulation
            sim = Run(
                simulation_type="multiphase",
                grid_shape=(200, 200),  # Small grid for quick testing
                lattice_type="D2Q9",
                tau=0.8,
                nt=10000,  # Short run to observe BC effects
                kappa=0.01,
                rho_l=1.0,
                rho_v=0.1,
                interface_width=5,
                save_interval=2000,
                bc_config=bc_config,  # Apply custom BCs
            )
        
            # Run the simulation with a droplet initialization to test interactions with boundaries
            sim.run(init_type="multiphase_bubble", verbose=True)
        
            # Visualize results
            print("\n=== Visualizing Boundary Condition Effects ===")
            visualise(sim, "LBM Boundary Condition Test")
        
            print("\nTest completed! Check the 'results' directory for saved data and plots.")
        
        
        if __name__ == "__main__":
            test_boundary_conditions()
        --- End of test_bc_multiphase.py ---

        test_bc_singlephase.py
        --- Code in test_bc_singlephase.py ---
        from wblbm.run import Run
        from wblbm.operators.force import Force
        from wblbm.utils.plotting import visualise
        import jax.numpy as jnp
        
        
        class UniformForce(Force):
            """
            A uniform force class that applies a constant force in the x-direction
            across the entire domain.
            """
        
            def __init__(self, nx: int, ny: int, d: int, force_magnitude: float):
                """
                Initialize uniform force in x-direction.
        
                Args:
                    nx (int): Grid size in x-direction
                    ny (int): Grid size in y-direction
                    d (int): Number of dimensions (should be 2)
                    force_magnitude (float): Magnitude of force in x-direction
                """
                if d != 2:
                    raise ValueError("Currently supports 2D (d=2) only")
        
                # Create force array with uniform force in x-direction
                force_array = jnp.zeros((nx, ny, 1, d))
                force_array = force_array.at[:, :, 0, 0].set(
                    force_magnitude
                )  # Force in x-direction
                force_array = force_array.at[:, :, 0, 1].set(0.0)  # No force in y-direction
        
                super().__init__(force_array)
        
            def compute_force(
                self, rho: jnp.ndarray, rho_l: float, rho_v: float
            ) -> jnp.ndarray:
                """
                Compute the uniform force field.
        
                Args:
                    rho: Density field (not used for uniform force)
                    rho_l: Liquid density (not used for uniform force)
                    rho_v: Vapor density (not used for uniform force)
        
                Returns:
                    jnp.ndarray: Uniform force field
                """
                return self.force
        
        
        def test_boundary_conditions_uniform_force():
            """
            Test boundary conditions with uniform force in x-direction.
        
            This test applies:
            - Uniform force in x-direction
            - Bounce-back boundary conditions at top and bottom
            - Periodic boundary conditions on left and right
            """
            print("Testing LBM Boundary Conditions with Uniform Force")
            print("=" * 60)
        
            # Simulation parameters
            grid_shape = (200, 100)  # (nx, ny)
            tau = 1.0
            nt = 100
            save_interval = 10
            force_magnitude = 0.001  # Uniform force in x-direction
        
            # Create uniform force object
            uniform_force = UniformForce(
                nx=grid_shape[0], ny=grid_shape[1], d=2, force_magnitude=force_magnitude
            )
        
            # Define boundary conditions
            bc_config = {
                "top": "bounce-back",  # No-slip wall at top
                "bottom": "bounce-back",  # No-slip wall at bottom
                "left": "periodic",  # Periodic boundary on left
                "right": "periodic",  # Periodic boundary on right
            }
        
            print(f"Grid shape: {grid_shape}")
            print(f"Uniform force magnitude (x-direction): {force_magnitude}")
            print(f"Boundary conditions: {bc_config}")
            print(f"Simulation steps: {nt}")
            print()
        
            # Set up the simulation
            sim = Run(
                simulation_type="singlephase",
                grid_shape=grid_shape,
                lattice_type="D2Q9",
                tau=tau,
                nt=nt,
                save_interval=save_interval,
                bc_config=bc_config,
                force_enabled=True,
                force_obj=uniform_force,
            )
        
            # Run the simulation with standard initialization
            sim.run(init_type="standard", verbose=True)
        
            return sim
        
        
        if __name__ == "__main__":
            print("Testing LBM Boundary Conditions with Uniform Force")
            print("=" * 60)
        
            # Run the test
            sim = test_boundary_conditions_uniform_force()
        
            # Visualize results
            print("\nVisualizing Results...")
            visualise(sim, "Boundary Conditions Test - Uniform Force")
        
            print("\nTest completed! Check the results directory for saved data and plots.")
        --- End of test_bc_singlephase.py ---

        multiphase_gravity_bubble_test.py
        --- Code in multiphase_gravity_bubble_test.py ---
        import numpy as np
        from wblbm.run import Run
        from wblbm.operators.force import GravityForceMultiphaseBubble
        from wblbm import visualise
        import jax
        
        # this line is added for debugging
        # jax.config.update("jax_disable_jit", True)
        
        
        def test_multiphase_gravity_simulation():
            """Test a multiphase LBM simulation with gravity and a central droplet."""
            print("\n=== Multiphase LBM Simulation with Gravity Test ===")
        
            grid_shape = (200, 800)
            tau = 0.9
            nt = 40000
            save_interval = 4000
            kappa = 0.04
            rho_l = 1.0
            rho_v = 0.001
            interface_width = 10
        
            force_g = 0.000002
            inclination_angle = 0
            gravity = GravityForceMultiphaseBubble(
                grid_shape[0], grid_shape[1], 2, force_g, inclination_angle
            )
        
            sim = Run(
                simulation_type="multiphase",
                grid_shape=grid_shape,
                lattice_type="D2Q9",
                tau=tau,
                nt=nt,
                kappa=kappa,
                rho_l=rho_l,
                rho_v=rho_v,
                interface_width=interface_width,
                save_interval=save_interval,
                force_enabled=True,
                force_obj=gravity,
            )
            sim.run(init_type="multiphase_bubble", verbose=True)
            return sim
        
        
        if __name__ == "__main__":
            print("Testing Multiphase LBM Codebase with Gravity")
            print("=" * 60)
        
            # Run simulation
            sim_multiphase_gravity = test_multiphase_gravity_simulation()
        
            # Visualize results
            print("\n=== Visualizing Results ===")
            visualise(sim_multiphase_gravity, "Multiphase with Gravity Force")
        
            print("\nTest completed!")
        --- End of multiphase_gravity_bubble_test.py ---

        timing_analysis.py
        --- Code in timing_analysis.py ---
        import time
        import numpy as np
        from wblbm.run import Run
        from wblbm import time_function, TIMING_ENABLED
        
        
        def detailed_timing_analysis():
            """Run a small simulation with detailed timing for each component."""
        
            print("=== Detailed Timing Analysis ===")
        
            sim = Run(
                simulation_type="multiphase",
                grid_shape=(1000, 1000),
                lattice_type="D2Q9",
                tau=1.0,
                nt=100,
                kappa=0.01,
                rho_l=1.0,
                rho_v=0.1,
                interface_width=4,
                save_interval=50,
                bc_config={"top": "symmetry", "bottom": "bounce-back"},
            )
        
            # Initialize
            f_prev = sim.simulation.initialize_fields("multiphase_bubble")
        
            # Warm up JAX compilation
            print("Warming up JAX compilation...")
            for _ in range(5):
                f_next = sim.simulation.run_timestep(f_prev, 0)
                if hasattr(sim.simulation, "boundary_condition"):
                    f_next = sim.simulation.boundary_condition(f_next, f_next)
                f_prev = f_next
        
            print("\nStarting detailed timing analysis...")
        
            total_times = {
                "macroscopic": [],
                "equilibrium": [],
                "collision": [],
                "streaming": [],
                "total_update": [],
            }
        
            for i in range(50):
                start_total = time.perf_counter()
        
                # Macroscopic calculation
                start = time.perf_counter()
                rho, u, force = sim.simulation.macroscopic(f_prev)
                if hasattr(rho, "block_until_ready"):
                    rho.block_until_ready()
                macro_time = time.perf_counter() - start
        
                # Equilibrium calculation
                start = time.perf_counter()
                feq = sim.simulation.update.equilibrium(rho, u)
                if hasattr(feq, "block_until_ready"):
                    feq.block_until_ready()
                eq_time = time.perf_counter() - start
        
                # Source term
                start = time.perf_counter()
                source = sim.simulation.update.source_term(rho, u, force)
                if hasattr(source, "block_until_ready"):
                    source.block_until_ready()
                source_time = time.perf_counter() - start
        
                # CollisionBGK
                start = time.perf_counter()
                fcol = sim.simulation.update.collision(f_prev, feq, source)
                if hasattr(fcol, "block_until_ready"):
                    fcol.block_until_ready()
                collision_time = time.perf_counter() - start
        
                # Streaming
                start = time.perf_counter()
                fstream = sim.simulation.update.streaming(fcol)
                if hasattr(fstream, "block_until_ready"):
                    fstream.block_until_ready()
                stream_time = time.perf_counter() - start
        
                # Apply boundary conditions if present
                if hasattr(sim.simulation, "boundary_condition"):
                    fstream = sim.simulation.boundary_condition(fstream, fcol)
                    if hasattr(fstream, "block_until_ready"):
                        fstream.block_until_ready()
                total_time = time.perf_counter() - start_total
        
                total_times["macroscopic"].append(macro_time + source_time)
                total_times["equilibrium"].append(eq_time)
                total_times["collision"].append(collision_time)
                total_times["streaming"].append(stream_time)
                total_times["total_update"].append(total_time)
        
                f_prev = fstream
        
                if i % 10 == 0:
                    print(f"Completed {i + 1}/50 timing iterations")
        
            print("\n=== Timing Results (milliseconds) ===")
            print(
                f"{'Component':<15} {'Mean':<8} {'Std':<8} {'Min':<8} {'Max':<8} {'% of Total':<12}"
            )
            print("-" * 70)
        
            total_mean = np.mean(total_times["total_update"]) * 1000
        
            for component, times in total_times.items():
                if component != "total_update":
                    times_ms = np.array(times) * 1000
                    mean_time = np.mean(times_ms)
                    std_time = np.std(times_ms)
                    min_time = np.min(times_ms)
                    max_time = np.max(times_ms)
                    percentage = (mean_time / total_mean) * 100
        
                    print(
                        f"{component:<15} {mean_time:<8.3f} {std_time:<8.3f} {min_time:<8.3f} {max_time:<8.3f} {percentage:<12.1f}"
                    )
        
            times_ms = np.array(total_times["total_update"]) * 1000
            mean_time = np.mean(times_ms)
            std_time = np.std(times_ms)
            min_time = np.min(times_ms)
            max_time = np.max(times_ms)
        
            print("-" * 70)
            print(
                f"{'TOTAL':<15} {mean_time:<8.3f} {std_time:<8.3f} {min_time:<8.3f} {max_time:<8.3f} {'100.0':<12}"
            )
        
        
        if __name__ == "__main__":
            detailed_timing_analysis()
        --- End of timing_analysis.py ---

        multiphase_gravity_droplet_test_MRT.py
        --- Code in multiphase_gravity_droplet_test_MRT.py ---
        from wblbm.run import Run
        from wblbm.operators.force import GravityForceMultiphaseDroplet
        from wblbm.utils.plotting import visualise
        import jax
        
        # this line is added for debugging
        # jax.config.update("jax_disable_jit", True)
        
        
        def test_multiphase_gravity_simulation():
            """Test a multiphase LBM simulation with gravity and a central droplet."""
            print("\n=== Multiphase LBM Simulation with Gravity Test ===")
        
            grid_shape = (200, 800)
            nt = 20000
            save_interval = 1000
            kappa = 0.02
            rho_l = 1.0
            rho_v = 0.001
            interface_width = 12
        
            force_g = 0.000002
            inclination_angle = 0
            gravity = GravityForceMultiphaseDroplet(
                grid_shape[0], grid_shape[1], 2, force_g, inclination_angle
            )
        
            # Specify MRT collision operator and its rates
            collision = {
                "collision_scheme": "mrt",
                "kv": 1.0,
                "kb": 1.0,
                "k0": 1.0,
                "k2": 1.0,
                "k4": 1.0,
            }
        
            sim = Run(
                simulation_type="multiphase",
                grid_shape=grid_shape,
                lattice_type="D2Q9",
                # tau is omitted for MRT operator
                nt=nt,
                kappa=kappa,
                rho_l=rho_l,
                rho_v=rho_v,
                interface_width=interface_width,
                save_interval=save_interval,
                force_enabled=True,
                force_obj=gravity,
                collision=collision,
            )
            sim.run(init_type="multiphase_droplet", verbose=True)
            return sim
        
        
        if __name__ == "__main__":
            print("Testing Multiphase LBM Codebase with Gravity")
            print("=" * 60)
        
            # Run simulation
            sim_multiphase_gravity = test_multiphase_gravity_simulation()
        
            # Visualize results
            print("\n=== Visualizing Results ===")
            visualise(sim_multiphase_gravity, "Multiphase with Gravity Force")
        
            print("\nTest completed!")
        --- End of multiphase_gravity_droplet_test_MRT.py ---

        complexity_analysis.py
        --- Code in complexity_analysis.py ---
        import time
        import numpy as np
        import matplotlib.pyplot as plt
        from wblbm.run import Run
        
        
        def complexity_analysis():
            """Analyze how timing scales with grid size."""
        
            grid_sizes = [(50, 50), (100, 100), (150, 150), (200, 200), (1000, 1000)]
            timing_results = []
        
            for nx, ny in grid_sizes:
                print(f"\nTesting grid size: {nx}x{ny}")
        
                sim = Run(
                    simulation_type="multiphase",
                    grid_shape=(nx, ny),
                    lattice_type="D2Q9",
                    tau=1.0,
                    nt=10,  # Just a few steps for timing
                    kappa=0.01,
                    rho_l=1.0,
                    rho_v=0.1,
                    interface_width=4,
                    save_interval=10,
                    bc_config={"top": "symmetry", "bottom": "bounce-back"},  # Example BCs
                )
        
                f_prev = sim.simulation.initialize_fields("multiphase_bubble")
        
                # Warm up
                for _ in range(3):
                    f_next = sim.simulation.run_timestep(f_prev, 0)
                    if hasattr(sim.simulation, "boundary_condition"):
                        f_next = sim.simulation.boundary_condition(f_next, f_next)
                    f_prev = f_next
        
                # Time multiple iterations
                times = []
                for _ in range(10):
                    start = time.perf_counter()
                    f_next = sim.simulation.run_timestep(f_prev, 0)
                    if hasattr(sim.simulation, "boundary_condition"):
                        f_next = sim.simulation.boundary_condition(f_next, f_next)
                    if hasattr(f_next, "block_until_ready"):
                        f_next.block_until_ready()
                    end = time.perf_counter()
                    times.append(end - start)
                    f_prev = f_next
        
                avg_time = np.mean(times) * 1000  # Convert to ms
                grid_points = nx * ny
        
                timing_results.append(
                    {
                        "grid_size": f"{nx}x{ny}",
                        "grid_points": grid_points,
                        "avg_time_ms": avg_time,
                        "time_per_point_us": (avg_time * 1000) / grid_points,
                    }
                )
        
                print(f"Average time per iteration: {avg_time:.3f} ms")
                print(f"Time per grid point: {(avg_time * 1000) / grid_points:.3f} μs")
        
            # Display results
            print("\n=== Complexity Analysis Results ===")
            print(f"{'Grid Size':<12} {'Points':<10} {'Time (ms)':<12} {'μs/point':<12}")
            print("-" * 50)
        
            for result in timing_results:
                print(
                    f"{result['grid_size']:<12} {result['grid_points']:<10} "
                    f"{result['avg_time_ms']:<12.3f} {result['time_per_point_us']:<12.3f}"
                )
        
        
        if __name__ == "__main__":
            complexity_analysis()
        --- End of complexity_analysis.py ---

        wetting_test.py
        --- Code in wetting_test.py ---
        import numpy as np
        from wblbm.run import Run
        from wblbm import GravityForceMultiphaseDroplet, visualise
        import jax
        
        # this line is added for debugging
        # jax.config.update("jax_disable_jit", True)
        
        
        def test_wetting_simulation():
            """Test wetting implementation with a droplet on a surface under gravity."""
            print("\n=== Testing LBM Wetting Implementation ===")
        
            # Simulation parameters
            grid_shape = (200, 100)  # nx, ny
            tau = 0.99  # Relaxation time
            nt = 100  # Number of time steps
            save_interval = 10  # Save every 500 steps
            kappa = 0.04  # Surface tension parameter
            rho_l = 1.0  # Liquid density
            rho_v = 0.001  # Vapor density
            interface_width = 5  # Interface width for smooth transition
        
            # Wetting parameters
            phi_value = 1.0  # Wetting strength parameter
            d_rho_value = 0.0  # Density adjustment parameter
        
            # Gravity setup (downward force for droplet settling)
            force_g = 0.0000002  # Small gravity to observe wetting without rapid fall
            inclination_angle = 0  # Vertical gravity
            gravity = GravityForceMultiphaseDroplet(
                grid_shape[0], grid_shape[1], 2, force_g, inclination_angle
            )
        
            # Boundary conditions: bounce-back at bottom for solid surface
            bc_config = {
                "bottom": "bounce-back",  # Solid wall for wetting
                "top": "symmetry",  # Open top
                "left": "periodic",  # Periodic sides
                "right": "periodic",
            }
        
            # Initialize and run simulation with wetting enabled
            sim = Run(
                simulation_type="wetting",
                grid_shape=grid_shape,
                lattice_type="D2Q9",
                tau=tau,
                nt=nt,
                kappa=kappa,
                rho_l=rho_l,
                rho_v=rho_v,
                interface_width=interface_width,
                save_interval=save_interval,
                bc_config=bc_config,
                force_enabled=True,
                force_obj=gravity,
                phi_value=phi_value,
                d_rho_value=d_rho_value,
                wetting_enabled=True,
                hysteresis_params=None,
            )
        
            # Run with wetting initialization
            sim.run(init_type="wetting", verbose=True)
            return sim
        
        
        if __name__ == "__main__":
            sim_wetting = test_wetting_simulation()
        
            # Visualize results
            print("\n=== Visualizing Wetting Test Results ===")
            visualise(sim_wetting, "Wetting Implementation Test")
        
            print("\nTest completed! Check the 'results' directory for data and plots.")
        --- End of wetting_test.py ---

        test.py
        --- Code in test.py ---
        import numpy as np
        from wblbm.run import Run
        from wblbm import visualise
        
        
        def test_basic_simulation():
            """Test a basic single-phase LBM simulation."""
            print("\n=== Basic LBM Simulation Test ===")
            sim = Run(
                simulation_type="singlephase",
                grid_shape=(100, 50),
                lattice_type="D2Q9",
                tau=1.0,
                nt=5000,
                save_interval=1000,
            )
            sim.run(init_type="standard", verbose=True)
            return sim
        
        
        def test_multiphase_simulation():
            """Test a multiphase LBM simulation with a central bubble."""
            print("\n=== Multiphase LBM Simulation Test ===")
            sim = Run(
                simulation_type="multiphase",
                grid_shape=(400, 400),
                lattice_type="D2Q9",
                tau=0.9,
                nt=5000,
                save_interval=1000,
                kappa=0.01,
                rho_l=1.0,
                rho_v=0.001,
                interface_width=10,
            )
            sim.run(init_type="multiphase_droplet", verbose=True)
            return sim
        
        
        if __name__ == "__main__":
            print("Testing LBM Codebase with Refactored IO and Initialization")
            print("=" * 60)
        
            # Run simulations
            sim_basic = test_basic_simulation()
            sim_multiphase = test_multiphase_simulation()
        
            # Visualize results using the new, centralized function
            print("\n=== Visualizing Results ===")
            visualise(sim_basic, "Basic LBM Simulation")
            visualise(sim_multiphase, "Multiphase LBM Simulation")
        
            print("\nAll tests completed!")
        --- End of test.py ---

        multiphase_gravity_droplet_test.py
        --- Code in multiphase_gravity_droplet_test.py ---
        from wblbm.run import Run
        from wblbm.operators.force import GravityForceMultiphaseDroplet
        from wblbm.utils.plotting import visualise
        import jax
        
        # this line is added for debugging
        # jax.config.update("jax_disable_jit", True)
        
        
        def test_multiphase_gravity_simulation():
            """Test a multiphase LBM simulation with gravity and a central droplet."""
            print("\n=== Multiphase LBM Simulation with Gravity Test ===")
        
            grid_shape = (200, 800)
            tau = 0.9
            nt = 10000
            save_interval = 1000
            kappa = 0.04
            rho_l = 1.0
            rho_v = 0.001
            interface_width = 10
        
            force_g = 0.00002
            inclination_angle = 0
            gravity = GravityForceMultiphaseDroplet(
                grid_shape[0], grid_shape[1], 2, force_g, inclination_angle
            )
        
            bc_config = {
                "top": "bounce-back",  # No-slip wall at top
                "bottom": "bounce-back",  # Symmetric boundary at bottom
                "left": "bounce-back",  # Periodic left-right wrapping
                "right": "bounce-back",
            }
        
            sim = Run(
                simulation_type="multiphase",
                grid_shape=grid_shape,
                lattice_type="D2Q9",
                tau=tau,
                nt=nt,
                kappa=kappa,
                rho_l=rho_l,
                rho_v=rho_v,
                interface_width=interface_width,
                save_interval=save_interval,
                bc_config=bc_config,
                force_enabled=True,
                force_obj=gravity,
            )
            sim.run(init_type="multiphase_droplet", verbose=True)
            return sim
        
        
        if __name__ == "__main__":
            print("Testing Multiphase LBM Codebase with Gravity")
            print("=" * 60)
        
            # Run simulation
            sim_multiphase_gravity = test_multiphase_gravity_simulation()
        
            # Visualize results
            print("\n=== Visualizing Results ===")
            visualise(sim_multiphase_gravity, "Multiphase with Gravity Force")
        
            print("\nTest completed!")
        --- End of multiphase_gravity_droplet_test.py ---

        bubble_high_density.py
        --- Code in bubble_high_density.py ---
        from wblbm.run import Run
        from wblbm import visualise
        
        
        def test_multiphase_simulation():
            """
            Test a multiphase LBM simulation with a central bubble.
        
            This function sets up and runs a multiphase lattice Boltzmann method (LBM) simulation
            using a high density ratio and a central bubble. The simulation parameters are specified
            for a 2D grid with D2Q9 lattice, and the results are returned for further analysis or visualization.
        
            Returns:
                Run: The simulation object after running the multiphase bubble test.
            """
            print("\n=== Multiphase LBM Simulation Test ===")
            sim = Run(
                simulation_type="multiphase",
                grid_shape=(400, 400),
                lattice_type="D2Q9",
                tau=0.9,
                nt=5000,
                save_interval=1000,
                kappa=0.01,
                rho_l=1.0,
                rho_v=0.001,
                interface_width=10,
            )
            sim.run(init_type="multiphase_bubble", verbose=True)
            return sim
        
        
        if __name__ == "__main__":
            """
            Main entry point for running and visualizing the high density ratio static bubble simulation.
        
            This script runs the multiphase LBM simulation and visualizes the results using the centralized
            plotting function. It prints status messages to indicate progress and completion.
            """
            print("Testing LBM Codebase with high density ratio static bubble simulation.")
            print("=" * 60)
        
            sim_multiphase = test_multiphase_simulation()
        
            # Visualize results using the new, centralized function
            print("\n=== Visualizing Results ===")
            visualise(sim_multiphase, "Multiphase LBM Simulation")
        
            print("\nAll tests completed!")
        --- End of bubble_high_density.py ---

        test_droplet_periodic_top_bot_bc.py
        --- Code in test_droplet_periodic_top_bot_bc.py ---
        from wblbm.run import Run
        from wblbm.operators.force import GravityForceMultiphaseDroplet
        from wblbm.utils.plotting import visualise
        
        
        def test_multiphase_gravity_simulation():
            """Test a multiphase LBM simulation with gravity and a central droplet."""
            print("\n=== Multiphase LBM Simulation with Gravity Test ===")
        
            grid_shape = (200, 800)
            tau = 0.9
            nt = 1000
            save_interval = 100
            kappa = 0.04
            rho_l = 1.0
            rho_v = 0.001
            interface_width = 10
        
            force_g = 0.0000002
            inclination_angle = 0
            gravity = GravityForceMultiphaseDroplet(
                grid_shape[0], grid_shape[1], 2, force_g, inclination_angle
            )
        
            bc_config = {
                "top": "periodic",
                "bottom": "periodic",
                "left": "bounce-back",
                "right": "bounce-back",
            }
        
            sim = Run(
                simulation_type="multiphase",
                grid_shape=grid_shape,
                lattice_type="D2Q9",
                tau=tau,
                nt=nt,
                kappa=kappa,
                rho_l=rho_l,
                rho_v=rho_v,
                interface_width=interface_width,
                save_interval=save_interval,
                bc_config=bc_config,
                force_enabled=True,
                force_obj=gravity,
            )
            sim.run(init_type="multiphase_droplet", verbose=True)
            return sim
        
        
        if __name__ == "__main__":
            print("Testing Multiphase LBM Codebase with Gravity")
            print("=" * 60)
        
            # Run simulation
            sim_multiphase_gravity = test_multiphase_gravity_simulation()
        
            # Visualize results
            print("\n=== Visualizing Results ===")
            visualise(sim_multiphase_gravity, "Multiphase with Gravity Force")
        
            print("\nTest completed!")
        --- End of test_droplet_periodic_top_bot_bc.py ---

        results/
            2025-07-23/
                13-12-29/
                    config.json
                    data/
                        timestep_1000.npz
                        timestep_0.npz
                        timestep_2000.npz
                10-50-48/
                    config.json
                    data/
                        timestep_3500.npz
                        timestep_1100.npz
                        timestep_1300.npz
                        timestep_3700.npz
                        timestep_3300.npz
                        timestep_1700.npz
                        timestep_1500.npz
                        timestep_2800.npz
                        timestep_900.npz
                        timestep_3100.npz
                        timestep_1200.npz
                        timestep_3600.npz
                        timestep_3400.npz
                        timestep_1000.npz
                        timestep_2900.npz
                        timestep_800.npz
                        timestep_1400.npz
                        timestep_3000.npz
                        timestep_3200.npz
                        timestep_1600.npz
                        timestep_600.npz
                        timestep_2700.npz
                        timestep_0.npz
                        timestep_3999.npz
                        timestep_1800.npz
                        timestep_2500.npz
                        timestep_400.npz
                        timestep_2100.npz
                        timestep_3800.npz
                        timestep_2300.npz
                        timestep_200.npz
                        timestep_2400.npz
                        timestep_500.npz
                        timestep_1900.npz
                        timestep_700.npz
                        timestep_2600.npz
                        timestep_2200.npz
                        timestep_300.npz
                        timestep_100.npz
                        timestep_2000.npz
                        timestep_3900.npz
                    plots/
                        timestep_3500.png
                        timestep_1100.png
                        timestep_1300.png
                        timestep_3700.png
                        timestep_3300.png
                        timestep_1700.png
                        timestep_1500.png
                        timestep_900.png
                        timestep_2800.png
                        timestep_3100.png
                        timestep_1200.png
                        timestep_3600.png
                        timestep_3400.png
                        timestep_1000.png
                        timestep_800.png
                        timestep_2900.png
                        timestep_1400.png
                        timestep_3000.png
                        timestep_3200.png
                        timestep_1600.png
                        timestep_2700.png
                        timestep_600.png
                        timestep_0.png
                        timestep_3999.png
                        timestep_1800.png
                        timestep_400.png
                        timestep_2500.png
                        timestep_2100.png
                        timestep_3800.png
                        timestep_200.png
                        timestep_2300.png
                        timestep_500.png
                        timestep_2400.png
                        timestep_1900.png
                        timestep_2600.png
                        timestep_700.png
                        timestep_300.png
                        timestep_2200.png
                        timestep_2000.png
                        timestep_100.png
                        timestep_3900.png
                11-03-42/
                    config.json
                    data/
                        timestep_7000.npz
                        timestep_5000.npz
                        timestep_9000.npz
                        timestep_1000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_6000.npz
                        timestep_4000.npz
                        timestep_8000.npz
                        timestep_9999.npz
                        timestep_2000.npz
                    plots/
                        timestep_7000.png
                        timestep_5000.png
                        timestep_9000.png
                        timestep_1000.png
                        timestep_3000.png
                        timestep_0.png
                        timestep_6000.png
                        timestep_4000.png
                        timestep_8000.png
                        timestep_9999.png
                        timestep_2000.png
                10-53-32/
                    config.json
                    data/
                        timestep_1000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_4000.npz
                        timestep_2000.npz
                11-55-31/
                    config.json
                    data/
                        timestep_7000.npz
                        timestep_15000.npz
                        timestep_19000.npz
                        timestep_5000.npz
                        timestep_9000.npz
                        timestep_17000.npz
                        timestep_13000.npz
                        timestep_1000.npz
                        timestep_11000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_14000.npz
                        timestep_18000.npz
                        timestep_6000.npz
                        timestep_16000.npz
                        timestep_4000.npz
                        timestep_8000.npz
                        timestep_12000.npz
                        timestep_19999.npz
                        timestep_2000.npz
                        timestep_10000.npz
                    plots/
                        timestep_7000.png
                        timestep_15000.png
                        timestep_19000.png
                        timestep_5000.png
                        timestep_9000.png
                        timestep_17000.png
                        timestep_13000.png
                        timestep_1000.png
                        timestep_11000.png
                        timestep_3000.png
                        timestep_0.png
                        timestep_14000.png
                        timestep_18000.png
                        timestep_6000.png
                        timestep_16000.png
                        timestep_4000.png
                        timestep_8000.png
                        timestep_12000.png
                        timestep_19999.png
                        timestep_2000.png
                        timestep_10000.png
                11-24-55/
                    config.json
                    data/
                        timestep_7000.npz
                        timestep_15000.npz
                        timestep_19000.npz
                        timestep_5000.npz
                        timestep_9000.npz
                        timestep_17000.npz
                        timestep_13000.npz
                        timestep_1000.npz
                        timestep_11000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_14000.npz
                        timestep_18000.npz
                        timestep_6000.npz
                        timestep_16000.npz
                        timestep_4000.npz
                        timestep_8000.npz
                        timestep_12000.npz
                        timestep_19999.npz
                        timestep_2000.npz
                        timestep_10000.npz
                    plots/
                        timestep_7000.png
                        timestep_15000.png
                        timestep_19000.png
                        timestep_5000.png
                        timestep_9000.png
                        timestep_17000.png
                        timestep_13000.png
                        timestep_1000.png
                        timestep_11000.png
                        timestep_3000.png
                        timestep_0.png
                        timestep_14000.png
                        timestep_18000.png
                        timestep_6000.png
                        timestep_16000.png
                        timestep_4000.png
                        timestep_8000.png
                        timestep_12000.png
                        timestep_19999.png
                        timestep_2000.png
                        timestep_10000.png
                13-14-14/
                    config.json
                    data/
                11-41-40/
                    config.json
                    data/
                        timestep_1000.npz
                        timestep_0.npz
                10-35-55/
                    config.json
                    data/
                        timestep_900.npz
                        timestep_999.npz
                        timestep_800.npz
                        timestep_600.npz
                        timestep_0.npz
                        timestep_400.npz
                        timestep_200.npz
                        timestep_500.npz
                        timestep_700.npz
                        timestep_300.npz
                        timestep_100.npz
                    plots/
                        timestep_900.png
                        timestep_999.png
                        timestep_800.png
                        timestep_600.png
                        timestep_0.png
                        timestep_400.png
                        timestep_200.png
                        timestep_500.png
                        timestep_700.png
                        timestep_300.png
                        timestep_100.png
                13-11-41/
                    config.json
                    data/
                        timestep_1000.npz
                        timestep_0.npz
                11-05-12/
                    config.json
                    data/
                        timestep_31000.npz
                        timestep_7000.npz
                        timestep_23000.npz
                        timestep_40000.npz
                        timestep_15000.npz
                        timestep_19000.npz
                        timestep_49999.npz
                        timestep_42000.npz
                        timestep_5000.npz
                        timestep_21000.npz
                        timestep_9000.npz
                        timestep_33000.npz
                        timestep_17000.npz
                        timestep_13000.npz
                        timestep_29000.npz
                        timestep_37000.npz
                        timestep_46000.npz
                        timestep_1000.npz
                        timestep_25000.npz
                        timestep_11000.npz
                        timestep_3000.npz
                        timestep_27000.npz
                        timestep_39000.npz
                        timestep_44000.npz
                        timestep_35000.npz
                        timestep_48000.npz
                        timestep_0.npz
                        timestep_14000.npz
                        timestep_18000.npz
                        timestep_30000.npz
                        timestep_41000.npz
                        timestep_22000.npz
                        timestep_6000.npz
                        timestep_16000.npz
                        timestep_20000.npz
                        timestep_4000.npz
                        timestep_43000.npz
                        timestep_32000.npz
                        timestep_8000.npz
                        timestep_36000.npz
                        timestep_28000.npz
                        timestep_24000.npz
                        timestep_47000.npz
                        timestep_12000.npz
                        timestep_45000.npz
                        timestep_38000.npz
                        timestep_26000.npz
                        timestep_2000.npz
                        timestep_49000.npz
                        timestep_34000.npz
                        timestep_10000.npz
                    plots/
                        timestep_31000.png
                        timestep_40000.png
                        timestep_7000.png
                        timestep_23000.png
                        timestep_15000.png
                        timestep_19000.png
                        timestep_49999.png
                        timestep_5000.png
                        timestep_21000.png
                        timestep_42000.png
                        timestep_33000.png
                        timestep_9000.png
                        timestep_17000.png
                        timestep_13000.png
                        timestep_37000.png
                        timestep_29000.png
                        timestep_1000.png
                        timestep_25000.png
                        timestep_46000.png
                        timestep_11000.png
                        timestep_44000.png
                        timestep_39000.png
                        timestep_3000.png
                        timestep_27000.png
                        timestep_48000.png
                        timestep_35000.png
                        timestep_0.png
                        timestep_14000.png
                        timestep_18000.png
                        timestep_30000.png
                        timestep_22000.png
                        timestep_6000.png
                        timestep_41000.png
                        timestep_16000.png
                        timestep_43000.png
                        timestep_20000.png
                        timestep_4000.png
                        timestep_8000.png
                        timestep_32000.png
                        timestep_28000.png
                        timestep_36000.png
                        timestep_47000.png
                        timestep_24000.png
                        timestep_12000.png
                        timestep_26000.png
                        timestep_2000.png
                        timestep_38000.png
                        timestep_45000.png
                        timestep_34000.png
                        timestep_49000.png
                        timestep_10000.png
                13-11-12/
                    config.json
                    data/
                13-09-26/
                    config.json
                    data/
                        timestep_0.npz
                11-22-34/
                    config.json
                    data/
                        timestep_4999.npz
                        timestep_1000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_4000.npz
                        timestep_2000.npz
                    plots/
                        timestep_4999.png
                        timestep_1000.png
                        timestep_3000.png
                        timestep_0.png
                        timestep_4000.png
                        timestep_2000.png
                11-02-41/
                    config.json
                    data/
                        timestep_5000.npz
                        timestep_1000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_4000.npz
                        timestep_2000.npz
                13-09-00/
                    config.json
                    data/
                        timestep_1000.npz
                        timestep_0.npz
                10-48-22/
                    config.json
                    data/
                        timestep_7000.npz
                        timestep_5000.npz
                        timestep_9000.npz
                        timestep_1000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_6000.npz
                        timestep_4000.npz
                        timestep_8000.npz
                        timestep_9999.npz
                        timestep_2000.npz
                    plots/
                        timestep_7000.png
                        timestep_5000.png
                        timestep_9000.png
                        timestep_1000.png
                        timestep_3000.png
                        timestep_0.png
                        timestep_6000.png
                        timestep_4000.png
                        timestep_8000.png
                        timestep_9999.png
                        timestep_2000.png
                11-27-12/
                    config.json
                    data/
                        timestep_7000.npz
                        timestep_15000.npz
                        timestep_19000.npz
                        timestep_5000.npz
                        timestep_9000.npz
                        timestep_17000.npz
                        timestep_13000.npz
                        timestep_1000.npz
                        timestep_11000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_14000.npz
                        timestep_18000.npz
                        timestep_6000.npz
                        timestep_16000.npz
                        timestep_4000.npz
                        timestep_8000.npz
                        timestep_12000.npz
                        timestep_19999.npz
                        timestep_2000.npz
                        timestep_10000.npz
                    plots/
                        timestep_7000.png
                        timestep_15000.png
                        timestep_19000.png
                        timestep_5000.png
                        timestep_9000.png
                        timestep_17000.png
                        timestep_13000.png
                        timestep_1000.png
                        timestep_11000.png
                        timestep_3000.png
                        timestep_0.png
                        timestep_14000.png
                        timestep_18000.png
                        timestep_6000.png
                        timestep_16000.png
                        timestep_4000.png
                        timestep_8000.png
                        timestep_12000.png
                        timestep_19999.png
                        timestep_2000.png
                        timestep_10000.png
                09-48-22/
                    config.json
                    data/
                        timestep_900.npz
                        timestep_999.npz
                        timestep_800.npz
                        timestep_600.npz
                        timestep_0.npz
                        timestep_400.npz
                        timestep_200.npz
                        timestep_500.npz
                        timestep_700.npz
                        timestep_300.npz
                        timestep_100.npz
                    plots/
                        timestep_900.png
                        timestep_999.png
                        timestep_800.png
                        timestep_600.png
                        timestep_0.png
                        timestep_400.png
                        timestep_200.png
                        timestep_500.png
                        timestep_700.png
                        timestep_300.png
                        timestep_100.png
                13-10-02/
                    config.json
                    data/
                        timestep_0.npz
                11-18-00/
                    config.json
                    data/
                        timestep_7000.npz
                        timestep_15000.npz
                        timestep_19000.npz
                        timestep_5000.npz
                        timestep_9000.npz
                        timestep_17000.npz
                        timestep_13000.npz
                        timestep_1000.npz
                        timestep_11000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_14000.npz
                        timestep_18000.npz
                        timestep_6000.npz
                        timestep_16000.npz
                        timestep_4000.npz
                        timestep_8000.npz
                        timestep_12000.npz
                        timestep_19999.npz
                        timestep_2000.npz
                        timestep_10000.npz
                    plots/
                        timestep_7000.png
                        timestep_15000.png
                        timestep_19000.png
                        timestep_5000.png
                        timestep_9000.png
                        timestep_17000.png
                        timestep_13000.png
                        timestep_1000.png
                        timestep_11000.png
                        timestep_3000.png
                        timestep_0.png
                        timestep_14000.png
                        timestep_18000.png
                        timestep_6000.png
                        timestep_16000.png
                        timestep_4000.png
                        timestep_8000.png
                        timestep_12000.png
                        timestep_19999.png
                        timestep_2000.png
                        timestep_10000.png
                11-38-55/
                    config.json
                    data/
                        timestep_7000.npz
                        timestep_15000.npz
                        timestep_19000.npz
                        timestep_5000.npz
                        timestep_9000.npz
                        timestep_17000.npz
                        timestep_13000.npz
                        timestep_1000.npz
                        timestep_11000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_14000.npz
                        timestep_18000.npz
                        timestep_6000.npz
                        timestep_16000.npz
                        timestep_4000.npz
                        timestep_8000.npz
                        timestep_12000.npz
                        timestep_19999.npz
                        timestep_2000.npz
                        timestep_10000.npz
                    plots/
                        timestep_7000.png
                        timestep_15000.png
                        timestep_19000.png
                        timestep_5000.png
                        timestep_9000.png
                        timestep_17000.png
                        timestep_13000.png
                        timestep_1000.png
                        timestep_11000.png
                        timestep_3000.png
                        timestep_0.png
                        timestep_14000.png
                        timestep_18000.png
                        timestep_6000.png
                        timestep_16000.png
                        timestep_4000.png
                        timestep_8000.png
                        timestep_12000.png
                        timestep_19999.png
                        timestep_2000.png
                        timestep_10000.png
                10-50-02/
                    config.json
                    data/
                        timestep_1000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_4000.npz
                        timestep_2000.npz
                11-24-17/
                    config.json
                    data/
                        timestep_7000.npz
                        timestep_15000.npz
                        timestep_19000.npz
                        timestep_5000.npz
                        timestep_9000.npz
                        timestep_17000.npz
                        timestep_13000.npz
                        timestep_1000.npz
                        timestep_11000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_14000.npz
                        timestep_18000.npz
                        timestep_6000.npz
                        timestep_16000.npz
                        timestep_20000.npz
                        timestep_4000.npz
                        timestep_8000.npz
                        timestep_12000.npz
                        timestep_2000.npz
                        timestep_10000.npz
                11-59-23/
                    config.json
                    data/
                13-12-53/
                    config.json
                    data/
                11-21-43/
                    config.json
                    data/
                        timestep_5000.npz
                        timestep_1000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_6000.npz
                        timestep_4000.npz
                        timestep_2000.npz
                11-35-29/
                    config.json
                    data/
                        timestep_7000.npz
                        timestep_15000.npz
                        timestep_19000.npz
                        timestep_5000.npz
                        timestep_9000.npz
                        timestep_17000.npz
                        timestep_13000.npz
                        timestep_1000.npz
                        timestep_11000.npz
                        timestep_3000.npz
                        timestep_0.npz
                        timestep_14000.npz
                        timestep_18000.npz
                        timestep_6000.npz
                        timestep_16000.npz
                        timestep_4000.npz
                        timestep_8000.npz
                        timestep_12000.npz
                        timestep_19999.npz
                        timestep_2000.npz
                        timestep_10000.npz
                    plots/
                        timestep_7000.png
                        timestep_15000.png
                        timestep_19000.png
                        timestep_5000.png
                        timestep_9000.png
                        timestep_17000.png
                        timestep_13000.png
                        timestep_1000.png
                        timestep_11000.png
                        timestep_3000.png
                        timestep_0.png
                        timestep_14000.png
                        timestep_18000.png
                        timestep_6000.png
                        timestep_16000.png
                        timestep_4000.png
                        timestep_8000.png
                        timestep_12000.png
                        timestep_19999.png
                        timestep_2000.png
                        timestep_10000.png
                11-43-38/
                    config.json
                    data/
                        timestep_0.npz
            2025-07-10/
                14-28-58/
                    config.json
                    data/
                        timestep_120000.npz
                        timestep_397000.npz
                        timestep_297000.npz
                        timestep_31000.npz
                        timestep_52000.npz
                        timestep_143000.npz
                        timestep_389000.npz
                        timestep_289000.npz
                        timestep_285000.npz
                        timestep_385000.npz
                        timestep_132000.npz
                        timestep_7000.npz
                        timestep_23000.npz
                        timestep_40000.npz
                        timestep_151000.npz
                        timestep_68000.npz
                        timestep_179000.npz
                        timestep_15000.npz
                        timestep_104000.npz
                        timestep_481000.npz
                        timestep_167000.npz
                        timestep_76000.npz
                        timestep_116000.npz
                        timestep_175000.npz
                        timestep_493000.npz
                        timestep_64000.npz
                        timestep_108000.npz
                        timestep_19000.npz
                        timestep_439000.npz
                        timestep_368000.npz
                        timestep_268000.npz
                        timestep_444000.npz
                        timestep_315000.npz
                        timestep_215000.npz
                        timestep_427000.npz
                        timestep_376000.npz
                        timestep_276000.npz
                        timestep_207000.npz
                        timestep_307000.npz
                        timestep_456000.npz
                        timestep_264000.npz
                        timestep_364000.npz
                        timestep_435000.npz
                        timestep_219000.npz
                        timestep_319000.npz
                        timestep_448000.npz
                        timestep_97000.npz
                        timestep_231000.npz
                        timestep_460000.npz
                        timestep_331000.npz
                        timestep_186000.npz
                        timestep_252000.npz
                        timestep_403000.npz
                        timestep_352000.npz
                        timestep_198000.npz
                        timestep_89000.npz
                        timestep_85000.npz
                        timestep_194000.npz
                        timestep_323000.npz
                        timestep_472000.npz
                        timestep_223000.npz
                        timestep_340000.npz
                        timestep_411000.npz
                        timestep_240000.npz
                        timestep_266000.npz
                        timestep_366000.npz
                        timestep_437000.npz
                        timestep_278000.npz
                        timestep_378000.npz
                        timestep_429000.npz
                        timestep_205000.npz
                        timestep_305000.npz
                        timestep_454000.npz
                        timestep_425000.npz
                        timestep_374000.npz
                        timestep_274000.npz
                        timestep_458000.npz
                        timestep_309000.npz
                        timestep_209000.npz
                        timestep_446000.npz
                        timestep_317000.npz
                        timestep_217000.npz
                        timestep_342000.npz
                        timestep_413000.npz
                        timestep_242000.npz
                        timestep_99000.npz
                        timestep_188000.npz
                        timestep_196000.npz
                        timestep_321000.npz
                        timestep_470000.npz
                        timestep_221000.npz
                        timestep_87000.npz
                        timestep_250000.npz
                        timestep_401000.npz
                        timestep_350000.npz
                        timestep_233000.npz
                        timestep_462000.npz
                        timestep_333000.npz
                        timestep_184000.npz
                        timestep_95000.npz
                        timestep_153000.npz
                        timestep_42000.npz
                        timestep_299000.npz
                        timestep_399000.npz
                        timestep_5000.npz
                        timestep_21000.npz
                        timestep_287000.npz
                        timestep_387000.npz
                        timestep_130000.npz
                        timestep_141000.npz
                        timestep_50000.npz
                        timestep_9000.npz
                        timestep_33000.npz
                        timestep_122000.npz
                        timestep_395000.npz
                        timestep_295000.npz
                        timestep_66000.npz
                        timestep_177000.npz
                        timestep_491000.npz
                        timestep_169000.npz
                        timestep_78000.npz
                        timestep_114000.npz
                        timestep_74000.npz
                        timestep_483000.npz
                        timestep_165000.npz
                        timestep_118000.npz
                        timestep_106000.npz
                        timestep_17000.npz
                        timestep_229000.npz
                        timestep_329000.npz
                        timestep_478000.npz
                        timestep_254000.npz
                        timestep_354000.npz
                        timestep_405000.npz
                        timestep_237000.npz
                        timestep_337000.npz
                        timestep_466000.npz
                        timestep_180000.npz
                        timestep_91000.npz
                        timestep_417000.npz
                        timestep_346000.npz
                        timestep_246000.npz
                        timestep_192000.npz
                        timestep_474000.npz
                        timestep_325000.npz
                        timestep_225000.npz
                        timestep_83000.npz
                        timestep_409000.npz
                        timestep_358000.npz
                        timestep_258000.npz
                        timestep_370000.npz
                        timestep_421000.npz
                        timestep_270000.npz
                        timestep_313000.npz
                        timestep_442000.npz
                        timestep_213000.npz
                        timestep_262000.npz
                        timestep_433000.npz
                        timestep_362000.npz
                        timestep_201000.npz
                        timestep_450000.npz
                        timestep_301000.npz
                        timestep_70000.npz
                        timestep_487000.npz
                        timestep_161000.npz
                        timestep_102000.npz
                        timestep_13000.npz
                        timestep_499000.npz
                        timestep_62000.npz
                        timestep_173000.npz
                        timestep_495000.npz
                        timestep_110000.npz
                        timestep_138000.npz
                        timestep_29000.npz
                        timestep_145000.npz
                        timestep_54000.npz
                        timestep_37000.npz
                        timestep_126000.npz
                        timestep_391000.npz
                        timestep_291000.npz
                        timestep_157000.npz
                        timestep_46000.npz
                        timestep_1000.npz
                        timestep_25000.npz
                        timestep_283000.npz
                        timestep_383000.npz
                        timestep_134000.npz
                        timestep_58000.npz
                        timestep_149000.npz
                        timestep_112000.npz
                        timestep_489000.npz
                        timestep_171000.npz
                        timestep_497000.npz
                        timestep_60000.npz
                        timestep_11000.npz
                        timestep_100000.npz
                        timestep_485000.npz
                        timestep_163000.npz
                        timestep_72000.npz
                        timestep_281000.npz
                        timestep_381000.npz
                        timestep_136000.npz
                        timestep_3000.npz
                        timestep_27000.npz
                        timestep_39000.npz
                        timestep_128000.npz
                        timestep_44000.npz
                        timestep_155000.npz
                        timestep_124000.npz
                        timestep_393000.npz
                        timestep_293000.npz
                        timestep_35000.npz
                        timestep_159000.npz
                        timestep_48000.npz
                        timestep_56000.npz
                        timestep_147000.npz
                        timestep_81000.npz
                        timestep_190000.npz
                        timestep_476000.npz
                        timestep_327000.npz
                        timestep_227000.npz
                        timestep_468000.npz
                        timestep_339000.npz
                        timestep_239000.npz
                        timestep_415000.npz
                        timestep_344000.npz
                        timestep_244000.npz
                        timestep_93000.npz
                        timestep_235000.npz
                        timestep_335000.npz
                        timestep_464000.npz
                        timestep_182000.npz
                        timestep_248000.npz
                        timestep_348000.npz
                        timestep_419000.npz
                        timestep_256000.npz
                        timestep_356000.npz
                        timestep_407000.npz
                        timestep_203000.npz
                        timestep_452000.npz
                        timestep_303000.npz
                        timestep_260000.npz
                        timestep_431000.npz
                        timestep_360000.npz
                        timestep_311000.npz
                        timestep_440000.npz
                        timestep_211000.npz
                        timestep_372000.npz
                        timestep_423000.npz
                        timestep_272000.npz
                        timestep_199000.npz
                        timestep_88000.npz
                        timestep_402000.npz
                        timestep_353000.npz
                        timestep_253000.npz
                        timestep_96000.npz
                        timestep_461000.npz
                        timestep_330000.npz
                        timestep_187000.npz
                        timestep_230000.npz
                        timestep_241000.npz
                        timestep_341000.npz
                        timestep_410000.npz
                        timestep_84000.npz
                        timestep_0.npz
                        timestep_222000.npz
                        timestep_195000.npz
                        timestep_322000.npz
                        timestep_473000.npz
                        timestep_277000.npz
                        timestep_426000.npz
                        timestep_377000.npz
                        timestep_214000.npz
                        timestep_445000.npz
                        timestep_314000.npz
                        timestep_269000.npz
                        timestep_438000.npz
                        timestep_369000.npz
                        timestep_318000.npz
                        timestep_449000.npz
                        timestep_218000.npz
                        timestep_365000.npz
                        timestep_434000.npz
                        timestep_265000.npz
                        timestep_306000.npz
                        timestep_457000.npz
                        timestep_206000.npz
                        timestep_480000.npz
                        timestep_166000.npz
                        timestep_77000.npz
                        timestep_14000.npz
                        timestep_105000.npz
                        timestep_69000.npz
                        timestep_178000.npz
                        timestep_109000.npz
                        timestep_18000.npz
                        timestep_174000.npz
                        timestep_492000.npz
                        timestep_65000.npz
                        timestep_117000.npz
                        timestep_288000.npz
                        timestep_388000.npz
                        timestep_53000.npz
                        timestep_142000.npz
                        timestep_296000.npz
                        timestep_121000.npz
                        timestep_396000.npz
                        timestep_30000.npz
                        timestep_41000.npz
                        timestep_150000.npz
                        timestep_384000.npz
                        timestep_133000.npz
                        timestep_284000.npz
                        timestep_22000.npz
                        timestep_6000.npz
                        timestep_115000.npz
                        timestep_168000.npz
                        timestep_79000.npz
                        timestep_67000.npz
                        timestep_176000.npz
                        timestep_490000.npz
                        timestep_107000.npz
                        timestep_16000.npz
                        timestep_119000.npz
                        timestep_75000.npz
                        timestep_482000.npz
                        timestep_164000.npz
                        timestep_20000.npz
                        timestep_4000.npz
                        timestep_386000.npz
                        timestep_131000.npz
                        timestep_286000.npz
                        timestep_398000.npz
                        timestep_298000.npz
                        timestep_152000.npz
                        timestep_43000.npz
                        timestep_32000.npz
                        timestep_294000.npz
                        timestep_123000.npz
                        timestep_394000.npz
                        timestep_8000.npz
                        timestep_140000.npz
                        timestep_51000.npz
                        timestep_220000.npz
                        timestep_197000.npz
                        timestep_320000.npz
                        timestep_471000.npz
                        timestep_86000.npz
                        timestep_98000.npz
                        timestep_189000.npz
                        timestep_243000.npz
                        timestep_499999.npz
                        timestep_343000.npz
                        timestep_412000.npz
                        timestep_463000.npz
                        timestep_332000.npz
                        timestep_185000.npz
                        timestep_232000.npz
                        timestep_94000.npz
                        timestep_400000.npz
                        timestep_351000.npz
                        timestep_251000.npz
                        timestep_304000.npz
                        timestep_455000.npz
                        timestep_204000.npz
                        timestep_379000.npz
                        timestep_428000.npz
                        timestep_279000.npz
                        timestep_367000.npz
                        timestep_436000.npz
                        timestep_267000.npz
                        timestep_216000.npz
                        timestep_447000.npz
                        timestep_316000.npz
                        timestep_208000.npz
                        timestep_459000.npz
                        timestep_308000.npz
                        timestep_275000.npz
                        timestep_424000.npz
                        timestep_375000.npz
                        timestep_36000.npz
                        timestep_290000.npz
                        timestep_127000.npz
                        timestep_390000.npz
                        timestep_144000.npz
                        timestep_55000.npz
                        timestep_139000.npz
                        timestep_28000.npz
                        timestep_59000.npz
                        timestep_148000.npz
                        timestep_24000.npz
                        timestep_382000.npz
                        timestep_135000.npz
                        timestep_282000.npz
                        timestep_156000.npz
                        timestep_47000.npz
                        timestep_498000.npz
                        timestep_103000.npz
                        timestep_12000.npz
                        timestep_71000.npz
                        timestep_486000.npz
                        timestep_160000.npz
                        timestep_111000.npz
                        timestep_63000.npz
                        timestep_172000.npz
                        timestep_494000.npz
                        timestep_212000.npz
                        timestep_312000.npz
                        timestep_443000.npz
                        timestep_271000.npz
                        timestep_371000.npz
                        timestep_420000.npz
                        timestep_451000.npz
                        timestep_300000.npz
                        timestep_200000.npz
                        timestep_432000.npz
                        timestep_363000.npz
                        timestep_263000.npz
                        timestep_336000.npz
                        timestep_467000.npz
                        timestep_181000.npz
                        timestep_236000.npz
                        timestep_90000.npz
                        timestep_355000.npz
                        timestep_404000.npz
                        timestep_255000.npz
                        timestep_328000.npz
                        timestep_479000.npz
                        timestep_228000.npz
                        timestep_259000.npz
                        timestep_408000.npz
                        timestep_359000.npz
                        timestep_224000.npz
                        timestep_193000.npz
                        timestep_475000.npz
                        timestep_324000.npz
                        timestep_82000.npz
                        timestep_247000.npz
                        timestep_416000.npz
                        timestep_347000.npz
                        timestep_430000.npz
                        timestep_361000.npz
                        timestep_261000.npz
                        timestep_453000.npz
                        timestep_302000.npz
                        timestep_202000.npz
                        timestep_273000.npz
                        timestep_373000.npz
                        timestep_422000.npz
                        timestep_210000.npz
                        timestep_310000.npz
                        timestep_441000.npz
                        timestep_245000.npz
                        timestep_414000.npz
                        timestep_345000.npz
                        timestep_238000.npz
                        timestep_469000.npz
                        timestep_338000.npz
                        timestep_80000.npz
                        timestep_226000.npz
                        timestep_191000.npz
                        timestep_477000.npz
                        timestep_326000.npz
                        timestep_357000.npz
                        timestep_406000.npz
                        timestep_257000.npz
                        timestep_349000.npz
                        timestep_418000.npz
                        timestep_249000.npz
                        timestep_92000.npz
                        timestep_334000.npz
                        timestep_465000.npz
                        timestep_183000.npz
                        timestep_234000.npz
                        timestep_45000.npz
                        timestep_154000.npz
                        timestep_38000.npz
                        timestep_129000.npz
                        timestep_380000.npz
                        timestep_137000.npz
                        timestep_280000.npz
                        timestep_26000.npz
                        timestep_2000.npz
                        timestep_57000.npz
                        timestep_146000.npz
                        timestep_158000.npz
                        timestep_49000.npz
                        timestep_292000.npz
                        timestep_125000.npz
                        timestep_392000.npz
                        timestep_34000.npz
                        timestep_170000.npz
                        timestep_496000.npz
                        timestep_61000.npz
                        timestep_488000.npz
                        timestep_113000.npz
                        timestep_484000.npz
                        timestep_162000.npz
                        timestep_73000.npz
                        timestep_10000.npz
                        timestep_101000.npz
                    plots/
                        timestep_389000.png
                        timestep_289000.png
                        timestep_52000.png
                        timestep_143000.png
                        timestep_397000.png
                        timestep_120000.png
                        timestep_297000.png
                        timestep_31000.png
                        timestep_40000.png
                        timestep_151000.png
                        timestep_285000.png
                        timestep_132000.png
                        timestep_385000.png
                        timestep_7000.png
                        timestep_23000.png
                        timestep_167000.png
                        timestep_481000.png
                        timestep_76000.png
                        timestep_15000.png
                        timestep_104000.png
                        timestep_68000.png
                        timestep_179000.png
                        timestep_108000.png
                        timestep_19000.png
                        timestep_493000.png
                        timestep_175000.png
                        timestep_64000.png
                        timestep_116000.png
                        timestep_376000.png
                        timestep_427000.png
                        timestep_276000.png
                        timestep_315000.png
                        timestep_444000.png
                        timestep_215000.png
                        timestep_368000.png
                        timestep_439000.png
                        timestep_268000.png
                        timestep_219000.png
                        timestep_448000.png
                        timestep_319000.png
                        timestep_264000.png
                        timestep_435000.png
                        timestep_364000.png
                        timestep_207000.png
                        timestep_456000.png
                        timestep_307000.png
                        timestep_198000.png
                        timestep_89000.png
                        timestep_252000.png
                        timestep_352000.png
                        timestep_403000.png
                        timestep_97000.png
                        timestep_231000.png
                        timestep_186000.png
                        timestep_331000.png
                        timestep_460000.png
                        timestep_411000.png
                        timestep_340000.png
                        timestep_240000.png
                        timestep_85000.png
                        timestep_472000.png
                        timestep_323000.png
                        timestep_194000.png
                        timestep_223000.png
                        timestep_205000.png
                        timestep_454000.png
                        timestep_305000.png
                        timestep_278000.png
                        timestep_429000.png
                        timestep_378000.png
                        timestep_266000.png
                        timestep_437000.png
                        timestep_366000.png
                        timestep_317000.png
                        timestep_446000.png
                        timestep_217000.png
                        timestep_309000.png
                        timestep_458000.png
                        timestep_209000.png
                        timestep_374000.png
                        timestep_425000.png
                        timestep_274000.png
                        timestep_470000.png
                        timestep_321000.png
                        timestep_196000.png
                        timestep_221000.png
                        timestep_87000.png
                        timestep_99000.png
                        timestep_188000.png
                        timestep_413000.png
                        timestep_342000.png
                        timestep_242000.png
                        timestep_233000.png
                        timestep_184000.png
                        timestep_333000.png
                        timestep_462000.png
                        timestep_95000.png
                        timestep_250000.png
                        timestep_350000.png
                        timestep_401000.png
                        timestep_5000.png
                        timestep_21000.png
                        timestep_287000.png
                        timestep_130000.png
                        timestep_387000.png
                        timestep_299000.png
                        timestep_399000.png
                        timestep_153000.png
                        timestep_42000.png
                        timestep_33000.png
                        timestep_395000.png
                        timestep_122000.png
                        timestep_295000.png
                        timestep_9000.png
                        timestep_141000.png
                        timestep_50000.png
                        timestep_114000.png
                        timestep_169000.png
                        timestep_78000.png
                        timestep_66000.png
                        timestep_491000.png
                        timestep_177000.png
                        timestep_106000.png
                        timestep_17000.png
                        timestep_118000.png
                        timestep_74000.png
                        timestep_165000.png
                        timestep_483000.png
                        timestep_237000.png
                        timestep_180000.png
                        timestep_466000.png
                        timestep_337000.png
                        timestep_91000.png
                        timestep_254000.png
                        timestep_405000.png
                        timestep_354000.png
                        timestep_229000.png
                        timestep_478000.png
                        timestep_329000.png
                        timestep_358000.png
                        timestep_409000.png
                        timestep_258000.png
                        timestep_325000.png
                        timestep_474000.png
                        timestep_192000.png
                        timestep_225000.png
                        timestep_83000.png
                        timestep_346000.png
                        timestep_417000.png
                        timestep_246000.png
                        timestep_442000.png
                        timestep_313000.png
                        timestep_213000.png
                        timestep_421000.png
                        timestep_370000.png
                        timestep_270000.png
                        timestep_201000.png
                        timestep_301000.png
                        timestep_450000.png
                        timestep_262000.png
                        timestep_362000.png
                        timestep_433000.png
                        timestep_499000.png
                        timestep_102000.png
                        timestep_13000.png
                        timestep_70000.png
                        timestep_161000.png
                        timestep_487000.png
                        timestep_110000.png
                        timestep_62000.png
                        timestep_495000.png
                        timestep_173000.png
                        timestep_37000.png
                        timestep_391000.png
                        timestep_126000.png
                        timestep_291000.png
                        timestep_145000.png
                        timestep_54000.png
                        timestep_138000.png
                        timestep_29000.png
                        timestep_58000.png
                        timestep_149000.png
                        timestep_1000.png
                        timestep_25000.png
                        timestep_283000.png
                        timestep_134000.png
                        timestep_383000.png
                        timestep_157000.png
                        timestep_46000.png
                        timestep_497000.png
                        timestep_171000.png
                        timestep_60000.png
                        timestep_489000.png
                        timestep_112000.png
                        timestep_163000.png
                        timestep_485000.png
                        timestep_72000.png
                        timestep_11000.png
                        timestep_100000.png
                        timestep_44000.png
                        timestep_155000.png
                        timestep_39000.png
                        timestep_128000.png
                        timestep_281000.png
                        timestep_136000.png
                        timestep_381000.png
                        timestep_3000.png
                        timestep_27000.png
                        timestep_56000.png
                        timestep_147000.png
                        timestep_159000.png
                        timestep_48000.png
                        timestep_393000.png
                        timestep_124000.png
                        timestep_293000.png
                        timestep_35000.png
                        timestep_344000.png
                        timestep_415000.png
                        timestep_244000.png
                        timestep_339000.png
                        timestep_468000.png
                        timestep_239000.png
                        timestep_81000.png
                        timestep_327000.png
                        timestep_476000.png
                        timestep_190000.png
                        timestep_227000.png
                        timestep_256000.png
                        timestep_407000.png
                        timestep_356000.png
                        timestep_248000.png
                        timestep_419000.png
                        timestep_348000.png
                        timestep_93000.png
                        timestep_235000.png
                        timestep_182000.png
                        timestep_464000.png
                        timestep_335000.png
                        timestep_260000.png
                        timestep_360000.png
                        timestep_431000.png
                        timestep_203000.png
                        timestep_303000.png
                        timestep_452000.png
                        timestep_423000.png
                        timestep_372000.png
                        timestep_272000.png
                        timestep_440000.png
                        timestep_311000.png
                        timestep_211000.png
                        timestep_96000.png
                        timestep_187000.png
                        timestep_330000.png
                        timestep_461000.png
                        timestep_230000.png
                        timestep_353000.png
                        timestep_402000.png
                        timestep_253000.png
                        timestep_199000.png
                        timestep_88000.png
                        timestep_0.png
                        timestep_84000.png
                        timestep_222000.png
                        timestep_473000.png
                        timestep_322000.png
                        timestep_195000.png
                        timestep_241000.png
                        timestep_410000.png
                        timestep_341000.png
                        timestep_269000.png
                        timestep_369000.png
                        timestep_438000.png
                        timestep_214000.png
                        timestep_314000.png
                        timestep_445000.png
                        timestep_277000.png
                        timestep_377000.png
                        timestep_426000.png
                        timestep_457000.png
                        timestep_306000.png
                        timestep_206000.png
                        timestep_434000.png
                        timestep_365000.png
                        timestep_265000.png
                        timestep_449000.png
                        timestep_318000.png
                        timestep_218000.png
                        timestep_69000.png
                        timestep_178000.png
                        timestep_14000.png
                        timestep_105000.png
                        timestep_166000.png
                        timestep_480000.png
                        timestep_77000.png
                        timestep_117000.png
                        timestep_492000.png
                        timestep_174000.png
                        timestep_65000.png
                        timestep_109000.png
                        timestep_18000.png
                        timestep_296000.png
                        timestep_396000.png
                        timestep_121000.png
                        timestep_30000.png
                        timestep_53000.png
                        timestep_142000.png
                        timestep_288000.png
                        timestep_388000.png
                        timestep_133000.png
                        timestep_384000.png
                        timestep_284000.png
                        timestep_22000.png
                        timestep_6000.png
                        timestep_41000.png
                        timestep_150000.png
                        timestep_67000.png
                        timestep_490000.png
                        timestep_176000.png
                        timestep_168000.png
                        timestep_79000.png
                        timestep_115000.png
                        timestep_75000.png
                        timestep_164000.png
                        timestep_482000.png
                        timestep_119000.png
                        timestep_107000.png
                        timestep_16000.png
                        timestep_152000.png
                        timestep_43000.png
                        timestep_398000.png
                        timestep_298000.png
                        timestep_20000.png
                        timestep_4000.png
                        timestep_131000.png
                        timestep_386000.png
                        timestep_286000.png
                        timestep_140000.png
                        timestep_51000.png
                        timestep_8000.png
                        timestep_32000.png
                        timestep_294000.png
                        timestep_394000.png
                        timestep_123000.png
                        timestep_243000.png
                        timestep_499999.png
                        timestep_412000.png
                        timestep_343000.png
                        timestep_98000.png
                        timestep_189000.png
                        timestep_220000.png
                        timestep_471000.png
                        timestep_320000.png
                        timestep_197000.png
                        timestep_86000.png
                        timestep_351000.png
                        timestep_400000.png
                        timestep_251000.png
                        timestep_185000.png
                        timestep_332000.png
                        timestep_463000.png
                        timestep_232000.png
                        timestep_94000.png
                        timestep_436000.png
                        timestep_367000.png
                        timestep_267000.png
                        timestep_428000.png
                        timestep_379000.png
                        timestep_279000.png
                        timestep_455000.png
                        timestep_304000.png
                        timestep_204000.png
                        timestep_275000.png
                        timestep_375000.png
                        timestep_424000.png
                        timestep_208000.png
                        timestep_308000.png
                        timestep_459000.png
                        timestep_216000.png
                        timestep_316000.png
                        timestep_447000.png
                        timestep_139000.png
                        timestep_28000.png
                        timestep_144000.png
                        timestep_55000.png
                        timestep_36000.png
                        timestep_290000.png
                        timestep_390000.png
                        timestep_127000.png
                        timestep_156000.png
                        timestep_47000.png
                        timestep_24000.png
                        timestep_135000.png
                        timestep_382000.png
                        timestep_282000.png
                        timestep_59000.png
                        timestep_148000.png
                        timestep_71000.png
                        timestep_160000.png
                        timestep_486000.png
                        timestep_103000.png
                        timestep_12000.png
                        timestep_498000.png
                        timestep_63000.png
                        timestep_494000.png
                        timestep_172000.png
                        timestep_111000.png
                        timestep_271000.png
                        timestep_420000.png
                        timestep_371000.png
                        timestep_212000.png
                        timestep_443000.png
                        timestep_312000.png
                        timestep_363000.png
                        timestep_432000.png
                        timestep_263000.png
                        timestep_300000.png
                        timestep_451000.png
                        timestep_200000.png
                        timestep_479000.png
                        timestep_328000.png
                        timestep_228000.png
                        timestep_404000.png
                        timestep_355000.png
                        timestep_255000.png
                        timestep_181000.png
                        timestep_467000.png
                        timestep_336000.png
                        timestep_236000.png
                        timestep_90000.png
                        timestep_247000.png
                        timestep_347000.png
                        timestep_416000.png
                        timestep_224000.png
                        timestep_324000.png
                        timestep_475000.png
                        timestep_193000.png
                        timestep_82000.png
                        timestep_259000.png
                        timestep_359000.png
                        timestep_408000.png
                        timestep_302000.png
                        timestep_453000.png
                        timestep_202000.png
                        timestep_361000.png
                        timestep_430000.png
                        timestep_261000.png
                        timestep_210000.png
                        timestep_441000.png
                        timestep_310000.png
                        timestep_273000.png
                        timestep_422000.png
                        timestep_373000.png
                        timestep_80000.png
                        timestep_226000.png
                        timestep_326000.png
                        timestep_477000.png
                        timestep_191000.png
                        timestep_238000.png
                        timestep_338000.png
                        timestep_469000.png
                        timestep_245000.png
                        timestep_345000.png
                        timestep_414000.png
                        timestep_92000.png
                        timestep_183000.png
                        timestep_465000.png
                        timestep_334000.png
                        timestep_234000.png
                        timestep_418000.png
                        timestep_349000.png
                        timestep_249000.png
                        timestep_406000.png
                        timestep_357000.png
                        timestep_257000.png
                        timestep_137000.png
                        timestep_380000.png
                        timestep_280000.png
                        timestep_26000.png
                        timestep_2000.png
                        timestep_38000.png
                        timestep_129000.png
                        timestep_45000.png
                        timestep_154000.png
                        timestep_292000.png
                        timestep_392000.png
                        timestep_125000.png
                        timestep_34000.png
                        timestep_158000.png
                        timestep_49000.png
                        timestep_57000.png
                        timestep_146000.png
                        timestep_113000.png
                        timestep_488000.png
                        timestep_496000.png
                        timestep_170000.png
                        timestep_61000.png
                        timestep_10000.png
                        timestep_101000.png
                        timestep_162000.png
                        timestep_484000.png
                        timestep_73000.png
