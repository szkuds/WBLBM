/
    overview.py
    --- Code in overview.py ---
    import os
    
    
    def document_project(root_dir, output_file):
        with open(output_file, "w", encoding="utf-8") as doc:
            for dirpath, dirnames, filenames in os.walk(root_dir):
                # Remove hidden directories from dirnames in-place
                dirnames[:] = [d for d in dirnames if not d.startswith(".")]
                level = dirpath.replace(root_dir, "").count(os.sep)
                indent = "    " * level
                doc.write(f"{indent}{os.path.basename(dirpath)}/\n")
                subindent = "    " * (level + 1)
                for f in filenames:
                    if f.startswith("."):  # Skip hidden files as well (optional)
                        continue
                    file_path = os.path.join(dirpath, f)
                    doc.write(f"{subindent}{f}\n")
                    if f.endswith(".py"):
                        doc.write(f"{subindent}--- Code in {f} ---\n")
                        with open(file_path, "r", encoding="utf-8") as code_file:
                            for line in code_file:
                                doc.write(f"{subindent}{line}")
                        doc.write(f"{subindent}--- End of {f} ---\n\n")
    
    
    # Usage
    document_project("./", "./project_documentation.txt")
    --- End of overview.py ---

    project_documentation.txt
wblbm/
    __init__.py
    --- Code in __init__.py ---
    import wblbm.lattice
    import wblbm.grid    --- End of __init__.py ---

    operators/
        __init__.py
        --- Code in __init__.py ---
        --- End of __init__.py ---

        differential/
            gradient.py
            --- Code in gradient.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            
            
            class Gradient:
                """
                Callable class to calculate the gradient of a field using the provided stencil.
                """
            
                def __init__(self, lattice: Lattice):
                    self.w = lattice.w
                    self.c = lattice.c
            
                def __call__(self, grid):
                    """
                    Calculate the gradient using the provided stencil.
            
                    Args:
                        grid (jnp.ndarray): Input field, shape (nx, ny, 1, 1)
            
                    Returns:
                        jnp.ndarray: Gradient, shape (nx, ny, 1, 2)
                    """
                    # Extract 2D data from 4D input
                    if grid.ndim == 4:
                        grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    else:
                        grid_2d = grid
            
                    w = self.w
                    c = self.c
            
                    grad_ = jnp.zeros((2, grid_2d.shape[0], grid_2d.shape[1]))
                    grid_padded = jnp.pad(grid_2d, pad_width=1, mode='wrap')
            
                    # Side nodes
                    grid_ineg1_j0 = grid_padded[:-2, 1:-1]
                    grid_ipos1_j0 = grid_padded[2:, 1:-1]
                    grid_i0_jneg1 = grid_padded[1:-1, :-2]
                    grid_i0_jpos1 = grid_padded[1:-1, 2:]
            
                    # Corner nodes
                    grid_ipos1_jpos1 = grid_padded[2:, 2:]
                    grid_ineg1_jpos1 = grid_padded[:-2, 2:]
                    grid_ineg1_jneg1 = grid_padded[:-2, :-2]
                    grid_ipos1_jneg1 = grid_padded[2:, :-2]
            
                    grad_ = grad_.at[0, :, :].set(3 *
                                                  (w[1] * c[0, 1] * grid_ipos1_j0 +
                                                   w[3] * c[0, 3] * grid_ineg1_j0 +
                                                   w[5] * c[0, 5] * grid_ipos1_jpos1 +
                                                   w[6] * c[0, 6] * grid_ineg1_jpos1 +
                                                   w[7] * c[0, 7] * grid_ineg1_jneg1 +
                                                   w[8] * c[0, 8] * grid_ipos1_jneg1
                                                   )
                                                  )
            
                    grad_ = grad_.at[1, :, :].set(3 *
                                                  (w[2] * c[1, 2] * grid_i0_jpos1 +
                                                   w[4] * c[1, 4] * grid_i0_jneg1 +
                                                   w[5] * c[1, 5] * grid_ipos1_jpos1 +
                                                   w[6] * c[1, 6] * grid_ineg1_jpos1 +
                                                   w[7] * c[1, 7] * grid_ineg1_jneg1 +
                                                   w[8] * c[1, 8] * grid_ipos1_jneg1
                                                   )
                                                  )
            
                    # Convert to 4D format: (nx, ny, 1, 2)
                    grad_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 2))
                    grad_4d = grad_4d.at[:, :, 0, 0].set(grad_[0, :, :])
                    grad_4d = grad_4d.at[:, :, 0, 1].set(grad_[1, :, :])
            
                    return grad_4d
            --- End of gradient.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            laplacian.py
            --- Code in laplacian.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            
            
            class Laplacian:
                """
                Callable class to calculate the Laplacian of a 2D grid using the LBM stencil.
                """
            
                def __init__(self, lattice: Lattice):
                    self.w = lattice.w
            
                def __call__(self, grid):
                    """
                    Calculate the Laplacian of a 2D grid.
            
                    Args:
                        grid (jnp.ndarray): Input grid, shape (nx, ny, 1, 1)
            
                    Returns:
                        jnp.ndarray: Laplacian of the input grid, shape (nx, ny, 1, 1)
                    """
                    # Extract 2D data from 4D input
                    if grid.ndim == 4:
                        grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    else:
                        grid_2d = grid
            
                    w = self.w
            
                    laplacian_2d = jnp.zeros_like(grid_2d)
                    grid_padded = jnp.pad(grid_2d, pad_width=1, mode='wrap')
            
                    # Side nodes
                    grid_ineg1_j0 = grid_padded[:-2, 1:-1]
                    grid_ipos1_j0 = grid_padded[2:, 1:-1]
                    grid_i0_jneg1 = grid_padded[1:-1, :-2]
                    grid_i0_jpos1 = grid_padded[1:-1, 2:]
            
                    # Corner nodes
                    grid_ipos1_jpos1 = grid_padded[2:, 2:]
                    grid_ineg1_jpos1 = grid_padded[:-2, 2:]
                    grid_ineg1_jneg1 = grid_padded[:-2, :-2]
                    grid_ipos1_jneg1 = grid_padded[2:, :-2]
            
                    # Central node
                    grid_i0_j0 = grid_padded[1:-1, 1:-1]
            
                    laplacian_2d = laplacian_2d.at[:, :].set(6 *
                                                             (w[1] * (grid_ipos1_j0 - grid_i0_j0) +
                                                              w[2] * (grid_i0_jpos1 - grid_i0_j0) +
                                                              w[3] * (grid_ineg1_j0 - grid_i0_j0) +
                                                              w[4] * (grid_i0_jneg1 - grid_i0_j0) +
                                                              w[5] * (grid_ipos1_jpos1 - grid_i0_j0) +
                                                              w[6] * (grid_ineg1_jpos1 - grid_i0_j0) +
                                                              w[7] * (grid_ineg1_jneg1 - grid_i0_j0) +
                                                              w[8] * (grid_ipos1_jneg1 - grid_i0_j0)
                                                              )
                                                             )
            
                    # Convert to 4D format: (nx, ny, 1, 1)
                    laplacian_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 1))
                    laplacian_4d = laplacian_4d.at[:, :, 0, 0].set(laplacian_2d)
            
                    return laplacian_4d
            --- End of laplacian.py ---

            __pycache__/
                laplacian.cpython-312.pyc
                gradient.cpython-312.pyc
                __init__.cpython-312.pyc
        macroscopic/
            macroscopic.py
            --- Code in macroscopic.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from typing import Tuple
            from wblbm.operators.differential.gradient import Gradient
            
            
            class Macroscopic:
                """
                Calculates the macroscopic density and velocity fields from the population distribution.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice) -> None:
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.cx: jnp.ndarray = jnp.array(lattice.c[0])
                    self.cy: jnp.ndarray = jnp.array(lattice.c[1])
                    self.gradient = Gradient(lattice)
            
                def __call__(self, f: jnp.ndarray) -> Tuple[jnp.ndarray, jnp.ndarray]:
                    """
                    Args:
                        f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)
                    Returns:
                        tuple: (rho, u)
                            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                            u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                    """
                    gradient = self.gradient
                    if self.d == 2:
                        # Compute density
                        rho = jnp.sum(f, axis=2, keepdims=True)  # (nx, ny, 1, 1)
            
                        # Compute velocity
                        cx = self.cx.reshape((1, 1, self.q, 1))
                        cy = self.cy.reshape((1, 1, self.q, 1))
                        ux = jnp.sum(f * cx, axis=2, keepdims=True)
                        uy = jnp.sum(f * cy, axis=2, keepdims=True)
                        u = jnp.concatenate([ux, uy], axis=-1) / rho  # (nx, ny, 1, 2)
                        return rho, u
                    elif self.d == 3:
                        raise NotImplementedError("Dimension larger than 2 not supported.")            --- End of macroscopic.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            macroscopic_multiphase.py
            --- Code in macroscopic_multiphase.py ---
            import jax.numpy as jnp
            
            from wblbm.grid import Grid
            from wblbm.operators.macroscopic.macroscopic import Macroscopic
            from wblbm.operators.differential.gradient import Gradient
            from wblbm.operators.differential.laplacian import Laplacian
            from wblbm.lattice.lattice import Lattice
            
            
            class MacroscopicMultiphase(Macroscopic):
                """
                Calculates macroscopic variables for multiphase simulations.
                Inherits from Macroscopic and adds multiphase-specific methods.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, kappa: float, beta: float, rho_l: float, rho_v: float):
                    super().__init__(grid, lattice)
                    self.kappa = kappa
                    self.beta = beta
                    self.rho_l = rho_l
                    self.rho_v = rho_v
                    self.gradient = Gradient(lattice)
                    self.laplacian = Laplacian(lattice)
            
                def __call__(self, f: jnp.ndarray) -> tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
                    """
                    Calculate the macroscopic density and velocity fields from the population distribution.
            
                    Args:
                        f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)
            
                    Returns:
                        tuple: (rho, u, force_int)
                            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                            u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                            force_int (jnp.ndarray): Interaction force, shape (nx, ny, 1, 2)
                    """
                    rho, u = super().__call__(f)
                    force_int = self.force_int(rho)
                    u_updated = self.u_new(u, rho, force_int)
                    return rho, u_updated, force_int
            
                def eos(self, rho):
                    """Equation of state - extract 2D data for computation"""
                    rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    eos_2d = 2 * self.beta * (rho_2d - self.rho_l) * (rho_2d - self.rho_v) * (2 * rho_2d - self.rho_l - self.rho_v)
            
                    # Convert back to 4D format
                    eos_4d = jnp.zeros_like(rho)
                    eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)
                    return eos_4d
            
                def chem_pot(self, rho):
                    """
                    Calculate the chemical potential.
                    """
                    mu_0 = self.eos(rho)
                    chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)
                    return chem_pot__
            
                def force_int(self, rho):
                    """
                    Calculate the interaction force.
                    """
                    grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)
                    # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)
                    return -rho * grad_chem_pot
            
                def u_new(self, u, rho, force):
                    """
                    Update velocity with interaction force.
                    """
                    # Both u and force have shape (nx, ny, 1, 2)
                    return u + force / 2
            --- End of macroscopic_multiphase.py ---

            __pycache__/
                macroscopic_multiphase.cpython-312.pyc
                __init__.cpython-312.pyc
                macroscopic.cpython-312.pyc
        update/
            update.py
            --- Code in update.py ---
            import jax.numpy as jnp
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision import Collision, SourceTerm
            from wblbm.operators.equilibrium.equilibirum import Equilibrium
            from wblbm.operators.macroscopic.macroscopic import Macroscopic
            from wblbm.operators.stream import Streaming
            
            
            class Update(object):
                def __init__(
                        self,
                        grid: Grid,
                        lattice: Lattice,
                        tau: float
                ):
                    self.grid = grid
                    self.lattice = lattice
                    self.tau = tau
                    self.macroscopic = Macroscopic(grid, lattice)
                    self.equilibrium = Equilibrium(grid, lattice)
                    self.collision = Collision(grid, lattice, tau)
                    self.source_term = SourceTerm(grid, lattice)
                    self.streaming = Streaming(lattice)
            
                def __call__(self, f: jnp.ndarray):
                    rho, u = self.macroscopic(f)
                    feq = self.equilibrium(rho, u)
                    fcol = self.collision(f, feq)
                    fstream = self.streaming(fcol)
                    return fstream
            
            
            
            --- End of update.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            update_multiphase.py
            --- Code in update_multiphase.py ---
            import jax.numpy as jnp
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision.collision_multiphase import CollisionMultiphase
            from wblbm.operators.update.update import Update
            from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
            
            
            class UpdateMultiphase(Update):
                def __init__(
                        self,
                        grid: Grid,
                        lattice: Lattice,
                        tau: float,
                        kappa: float,
                        beta: float,
                        rho_l: float,
                        rho_v: float
                ):
                    super().__init__(grid, lattice, tau)
                    self.macroscopic = MacroscopicMultiphase(grid, lattice, kappa, beta, rho_l, rho_v)
                    self.collision = CollisionMultiphase(grid, lattice, tau)
            
                def __call__(self, f: jnp.array):
                    rho, u, force = self.macroscopic(f)
                    feq = self.equilibrium(rho, u)
                    source = self.source_term(rho, u, force)
                    fcol = self.collision(f, feq, source)
                    fstream = self.streaming(fcol)
                    return fstream
            
            --- End of update_multiphase.py ---

            __pycache__/
                update_multiphase.cpython-312.pyc
                update.cpython-312.pyc
                __init__.cpython-312.pyc
        stream/
            __init__.py
            --- Code in __init__.py ---
            from .stream import Streaming
            --- End of __init__.py ---

            stream.py
            --- Code in stream.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            
            
            class Streaming:
                """
                Callable class to perform the streaming step of the LBM.
                """
            
                def __init__(self, lattice: Lattice):
                    self.c = lattice.c  # Shape: (2, Q)
                    self.q = lattice.q
            
                def __call__(self, f):
                    """
                    Perform the streaming step of the LBM.
            
                    Args:
                        f (jnp.ndarray): Distribution function, shape (nx, ny, q, 1)
            
                    Returns:
                        jnp.ndarray: Post-streaming distribution function.
                    """
                    for i in range(self.q):
                        f = f.at[:, :, i, 0].set(
                            jnp.roll(
                                jnp.roll(f[:, :, i, 0], self.c[0, i], axis=0),
                                self.c[1, i], axis=1))
                    return f
            --- End of stream.py ---

            __pycache__/
                stream.cpython-312.pyc
                __init__.cpython-312.pyc
        initialise/
            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            init.py
            --- Code in init.py ---
            import jax.numpy as jnp
            import numpy as np
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.operators.equilibrium.equilibirum import Equilibrium
            
            
            class Initialise:
                """
                Handles the initialisation of the simulation for various scenarios.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice):
                    self.grid = grid
                    self.lattice = lattice
                    self.nx, self.ny = grid.nx, grid.ny
                    self.q = self.lattice.q
                    self.equilibrium = Equilibrium(self.grid, self.lattice)
            
                def initialise_standard(self, density: float = 1.0, velocity: np.ndarray = np.array([0.0, 0.0])):
                    """
                    Initialises a standard simulation with uniform density and velocity.
            
                    Args:
                        density (float): Initial uniform density.
                        velocity (np.ndarray): Initial uniform velocity [ux, uy].
            
                    Returns:
                        jnp.ndarray: Initialised population distribution f.
                    """
                    # Create density and velocity fields with the correct 4D shape
                    rho = jnp.full((self.nx, self.ny, 1, 1), density)
            
                    u = jnp.broadcast_to(
                        jnp.array(velocity).reshape(1, 1, 1, 2),
                        (self.nx, self.ny, 1, 2)
                    )
            
                    # Return the equilibrium distribution for this state
                    return self.equilibrium(rho, u)
            
                def initialise_multiphase_bubble(self, rho_l: float, rho_v: float):
                    """
                    Initialises a multiphase simulation with a low-density bubble in the center.
            
                    Args:
                        rho_l (float): Liquid phase density.
                        rho_v (float): Vapour phase (bubble) density.
            
                    Returns:
                        jnp.ndarray: Initialised population distribution f.
                    """
                    # Create a density field with a bubble in the center
                    x, y = jnp.meshgrid(jnp.arange(self.nx), jnp.arange(self.ny), indexing='ij')
                    center_x, center_y = self.nx // 2, self.ny // 2
                    radius = min(self.nx, self.ny) // 4
            
                    # Use tanh for a smooth, stable interface
                    interface_width = 2.0
                    distance = jnp.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
                    rho_field_2d = (rho_l + rho_v) / 2 - (rho_l - rho_v) / 2 * jnp.tanh((distance - radius) / interface_width)
            
                    # Reshape to 4D
                    rho = rho_field_2d.reshape((self.nx, self.ny, 1, 1))
            
                    # Initialise with zero velocity
                    u = jnp.zeros((self.nx, self.ny, 1, 2))
            
                    # Return the equilibrium distribution
                    return self.equilibrium(rho, u)
            --- End of init.py ---

            __pycache__/
                init.cpython-312.pyc
                __init__.cpython-312.pyc
        __pycache__/
            __init__.cpython-312.pyc
        boundary_condition/
            boundary_condition.py
            --- Code in boundary_condition.py ---
            --- End of boundary_condition.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

        equilibrium/
            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            equilibirum.py
            --- Code in equilibirum.py ---
            # wblbm/operators/equilibrium/equilibirum.py
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            
            
            class Equilibrium:
                """
                Callable class to calculate the equilibrium population distribution for LBM.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice) -> None:
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.w = lattice.w
                    self.cx = lattice.c[0]
                    self.cy = lattice.c[1]
            
                def __call__(self, rho_, u_):
                    """
                    Calculate the equilibrium distribution function.
            
                    Args:
                        rho_ (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                        u_ (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
            
                    Returns:
                        jnp.ndarray: Equilibrium distribution function, shape (nx, ny, q, 1)
                    """
                    nx, ny, q = self.nx, self.ny, self.q
                    w = self.w
                    cx, cy = self.cx, self.cy
            
                    # Extract velocity components
                    ux = u_[..., 0]  # Shape: (nx, ny, 1)
                    uy = u_[..., 1]  # Shape: (nx, ny, 1)
            
                    # Squeeze density to match velocity dimensions
                    rho = rho_.squeeze(axis=-1)  # Shape: (nx, ny, 1)
            
                    # Initialize equilibrium distribution - note the 4D shape
                    f_eq = jnp.zeros((nx, ny, q, 1))
            
                    # Calculate equilibrium for each velocity direction
                    for i in range(q):
                        cu = cx[i] * ux + cy[i] * uy
                        cu2 = cu * cu
                        u2 = ux * ux + uy * uy
            
                        f_eq = f_eq.at[:, :, i, :].set(
                            w[i] * rho * (3 * cu + 4.5 * cu2 - 1.5 * u2)
                        )
                    f_eq = f_eq.at[:, :, 0, :].set(rho[:, :, :] * (1 - w[0] * (1.5 * (ux * ux + uy * uy))))
            
                    return f_eq
            --- End of equilibirum.py ---

            __pycache__/
                equilibirum.cpython-312.pyc
                __init__.cpython-312.pyc
        run/
            run.py
            --- Code in run.py ---
            import jax.numpy as jnp
            import numpy as np
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.initialise.init import Initialise
            from wblbm.operators.update.update import Update
            from wblbm.operators.update.update_multiphase import UpdateMultiphase
            from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
            from wblbm.utils.io import SimulationIO
            
            
            class Run:
                """
                Main class to configure and run lattice Boltzmann simulations.
                """
            
                def __init__(
                        self,
                        grid_shape: tuple,
                        lattice_type: str = "D2Q9",
                        tau: float = 1.0,
                        nt: int = 1000,
                        multiphase: bool = False,
                        kappa: float = 0.1,
                        beta: float = 1.0,
                        rho_l: float = 1.0,
                        rho_v: float = 0.1,
                        save_interval: int = 100,
                        results_dir: str = "results"
                ):
                    self.grid_shape = grid_shape
                    self.nt = nt
                    self.multiphase = multiphase
                    self.save_interval = save_interval
            
                    # Store multiphase params
                    self.rho_l = rho_l
                    self.rho_v = rho_v
            
                    # Initialize core components
                    self.grid = Grid(grid_shape)
                    self.lattice = Lattice(lattice_type)
                    self.initialiser = Initialise(self.grid, self.lattice)
            
                    # Select the appropriate update and macroscopic operators
                    if multiphase:
                        self.update_op = UpdateMultiphase(
                            self.grid, self.lattice, tau, kappa, beta, rho_l, rho_v
                        )
                        self.macroscopic_op = self.update_op.macroscopic
                    else:
                        from wblbm.operators.macroscopic.macroscopic import Macroscopic
                        self.update_op = Update(self.grid, self.lattice, tau)
                        self.macroscopic_op = Macroscopic(self.grid, self.lattice)
            
                    # Prepare config dictionary for the IO handler
                    self.config = {
                        'grid_shape': grid_shape, 'lattice_type': lattice_type, 'tau': tau,
                        'nt': nt, 'multiphase': multiphase, 'save_interval': save_interval,
                        'kappa': kappa if multiphase else None, 'beta': beta if multiphase else None,
                        'rho_l': rho_l if multiphase else None, 'rho_v': rho_v if multiphase else None
                    }
                    self.io_handler = SimulationIO(base_dir=results_dir, config=self.config)
            
                def run(self, init_type: str = 'standard', verbose: bool = True):
                    """
                    Main function to run the LBM simulation.
            
                    Args:
                        init_type (str): Type of initialisation ('standard' or 'multiphase_bubble').
                        verbose (bool): Whether to print progress updates to the console.
                    """
                    # Initialize the population distribution based on the simulation type
                    if self.multiphase:
                        f_prev = self.initialiser.initialise_multiphase_bubble(self.rho_l, self.rho_v)
                    else:
                        f_prev = self.initialiser.initialise_standard()
            
                    if verbose:
                        print(f"Starting LBM simulation with {self.nt} time steps...")
                        print(f"Config -> Grid: {self.grid_shape}, Multiphase: {self.multiphase}")
            
                    # Main simulation loop
                    for it in range(self.nt):
                        f_next = self.update_op(f_prev)
                        f_prev = f_next
            
                        # Save data at the specified interval
                        if it % self.save_interval == 0 or it == self.nt - 1:
                            if self.multiphase:
                                rho, u, force = self.macroscopic_op(f_prev)
                                data_to_save = {
                                    'rho': np.array(rho), 'u': np.array(u), 'force': np.array(force)
                                }
                            else:
                                rho, u = self.macroscopic_op(f_prev)
                                data_to_save = {'rho': np.array(rho), 'u': np.array(u)}
            
                            self.io_handler.save_data_step(it, data_to_save)
            
                            if verbose:
                                avg_rho = np.mean(rho)
                                max_u = np.max(np.sqrt(u[..., 0] ** 2 + u[..., 1] ** 2))
                                print(f"Step {it}/{self.nt}: avg_rho={avg_rho:.4f}, max_u={max_u:.6f}")
            
                    if verbose:
                        print("Simulation completed!")
                        print(f"Results saved in: {self.io_handler.run_dir}")
            --- End of run.py ---

            __init__.py
            --- Code in __init__.py ---
            from .run import Run
            --- End of __init__.py ---

            __pycache__/
                run.cpython-312.pyc
                __init__.cpython-312.pyc
        collision/
            collision_multiphase.py
            --- Code in collision_multiphase.py ---
            import jax.numpy as jnp
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision import Collision
            from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
            
            
            class CollisionMultiphase(Collision):
                def __init__(self, grid: Grid, lattice: Lattice, tau: float) -> None:
                    super().__init__(grid, lattice, tau)
            
                def __call__(self, f: jnp.ndarray, feq: jnp.ndarray, source: jnp.ndarray = None) -> jnp.ndarray:
                    result = super().__call__(f, feq)
                    if source is not None:
                        result += (1 - (1 / (2 * self.tau))) * source
                    return result
            --- End of collision_multiphase.py ---

            __init__.py
            --- Code in __init__.py ---
            from .collision import Collision
            from .source import SourceTerm            --- End of __init__.py ---

            collision.py
            --- Code in collision.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            
            
            class Collision:
                """
                Callable class to perform the collision step of the LBM.
                Implements the BGK collision operators with source terms.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, tau: float) -> None:
                    """
                    Initialize the Collision operators.
            
                    Args:
                        grid (Grid): Grid object containing simulation domain information
                        lattice (Lattice): Lattice object containing lattice properties
                        tau (float): Relaxation time parameter
                    """
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.tau: float = tau
            
                def __call__(self, f: jnp.ndarray, feq: jnp.ndarray) -> jnp.ndarray:
                    """
                    Perform the collision step of the LBM.
            
                    Args:
                        f (jnp.ndarray): Distribution function.
                        feq (jnp.ndarray): Equilibrium distribution function.
            
                    Returns:
                        jnp.ndarray: Post-collision distribution function.
                    """
                    return (1 - (1 / self.tau)) * f + (1 / self.tau) * feq
            --- End of collision.py ---

            source.py
            --- Code in source.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.operators.differential.gradient import Gradient
            
            
            class SourceTerm:
                """
                Callable class to calculate the source term for the LBM equation.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice):
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.w = lattice.w
                    self.cx = lattice.c[0]
                    self.cy = lattice.c[1]
                    self.gradient = Gradient(lattice)
            
                def __call__(self, rho: jnp.ndarray, u: jnp.ndarray, force: jnp.ndarray) -> jnp.ndarray:
                    """
                    Calculate the source term for the LBM equation.
            
                    Args:
                        rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                        u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                        force (jnp.ndarray): Force field, shape (nx, ny, 1, 2)
            
                    Returns:
                        jnp.ndarray: Source term, shape (nx, ny, q, 1)
                    """
                    nx, ny, q = self.nx, self.ny, self.q
                    w = self.w
                    c = (self.cx, self.cy)
                    d = self.d
                    gradient = self.gradient
            
                    # Extract 2D data from 4D arrays
                    u_2d = u[:, :, 0, :]  # Shape: (nx, ny, 2)
                    force_2d = force[:, :, 0, :]  # Shape: (nx, ny, 2)
                    rho_2d = rho[:, :, 0, 0]  # Shape: (nx, ny)
            
                    # Calculate gradient of rho
                    grad_rho = gradient(rho)  # Shape: (nx, ny, 1, 2)
                    grad_rho_2d = grad_rho[:, :, 0, :]  # Shape: (nx, ny, 2)
            
                    def source_term(u_2d_, force_2d_, grad_rho_2d_):
                        cx, cy = c[0], c[1]
                        fx, fy = force_2d_[:, :, 0], force_2d_[:, :, 1]
                        ux, uy = u_2d_[:, :, 0], u_2d_[:, :, 1]
                        grad_rho_x, grad_rho_y = grad_rho_2d_[:, :, 0], grad_rho_2d_[:, :, 1]
            
                        fx_cor = fx + (grad_rho_x / 3)
                        fy_cor = fy + (grad_rho_y / 3)
                        source_ = jnp.zeros((nx, ny, q))
            
                        for i in range(q):
                            source_ = source_.at[:, :, i].set(w[i] * (
                                    3 * (cx[i] * fx + cy[i] * fy) +
                                    9 * (cx[i] * fx_cor + cy[i] * fy_cor) * (cx[i] * ux + cy[i] * uy) -
                                    3 * (ux * fx_cor + uy * fy_cor) +
                                    0.5 * (3 * (cx[i] * cx[i] + cy[i] * cy[i]) - d) * (
                                            ux * grad_rho_x + uy * grad_rho_y)
                            ))
            
                        return source_
            
                    source_2d = source_term(u_2d, force_2d, grad_rho_2d)
            
                    # Convert to 4D format: (nx, ny, q, 1)
                    source_4d = jnp.expand_dims(source_2d, axis=-1)
            
                    return source_4d
            --- End of source.py ---

            __pycache__/
                collision.cpython-312.pyc
                collision_multiphase.cpython-312.pyc
                source.cpython-312.pyc
                __init__.cpython-312.pyc
    utils/
        plotting.py
        --- Code in plotting.py ---
        import os
        import numpy as np
        import matplotlib.pyplot as plt
        
        
        def visualize_all_steps(sim_instance, title="LBM Simulation Results"):
            """
            Visualizes simulation results by loading and plotting every saved timestep.
        
            Args:
                sim_instance: The completed simulation instance from the Run class.
                title (str): The base title for the plots.
            """
            try:
                # Get the directory where data files are stored
                data_dir = sim_instance.io_handler.data_dir
        
                # Create a new directory within the run to store the plots
                plot_dir = os.path.join(sim_instance.io_handler.run_dir, "plots")
                os.makedirs(plot_dir, exist_ok=True)
                print(f"Saving plots to: {plot_dir}")
        
                # Get all data files and sort them by timestep
                files = [f for f in os.listdir(data_dir) if f.endswith('.npz')]
                if not files:
                    print("No data files found to visualize.")
                    return
        
                # Sort files based on the iteration number in the filename
                files.sort(key=lambda f: int(f.split('_')[-1].split('.')[0]))
        
                # Loop through each timestep file and generate a plot
                for filename in files:
                    file_path = os.path.join(data_dir, filename)
                    timestep = int(filename.split('_')[-1].split('.')[0])
        
                    data = np.load(file_path)
                    final_rho = data['rho']
                    final_u = data['u']
        
                    fig, axes = plt.subplots(1, 2, figsize=(12, 5))
        
                    # Plot density
                    im1 = axes[0].imshow(final_rho[:, :, 0, 0].T, origin='lower', cmap='viridis')
                    axes[0].set_title(f'Density (t={timestep})')
                    plt.colorbar(im1, ax=axes[0], label="Density")
        
                    # Plot velocity magnitude
                    vel_mag = np.sqrt(final_u[:, :, 0, 0] ** 2 + final_u[:, :, 0, 1] ** 2)
                    im2 = axes[1].imshow(vel_mag.T, origin='lower', cmap='plasma')
                    axes[1].set_title('Velocity Magnitude')
                    plt.colorbar(im2, ax=axes[1], label="Velocity")
        
                    for ax in axes:
                        ax.set_xlabel('x')
                        ax.set_ylabel('y')
        
                    plt.suptitle(f"{title} - Timestep {timestep}")
                    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        
                    # Save the figure to the plots directory
                    plot_filename = os.path.join(plot_dir, f"timestep_{timestep}.png")
                    plt.savefig(plot_filename)
                    plt.close(fig)  # Close the figure to free up memory
        
                print(f"Finished generating plots for all {len(files)} timesteps.")
        
            except ImportError:
                print("Matplotlib not found. Please install it to visualize results.")
            except Exception as e:
                print(f"An error occurred during visualization: {e}")
        
        --- End of plotting.py ---

        io.py
        --- Code in io.py ---
        import os
        import json
        import numpy as np
        from datetime import datetime
        from typing import Dict
        
        class SimulationIO:
            """
            Handles all I/O operations for the simulation, including logging and saving results.
            """
            def __init__(self, base_dir: str = "results", config: Dict = None):
                """
                Initializes the IO handler.
        
                Args:
                    base_dir (str): The base directory to store simulation results.
                    config (Dict, optional): A dictionary containing the simulation configuration to save.
                """
                self.base_dir = base_dir
                self.run_dir = self._create_timestamped_directory()
                self.data_dir = os.path.join(self.run_dir, "data")
                os.makedirs(self.data_dir, exist_ok=True)
        
                if config:
                    self.save_config(config)
        
            def _create_timestamped_directory(self) -> str:
                """Creates a unique, timestamped directory for a single simulation run."""
                timestamp = datetime.now().strftime("%Y-%m-%d/%H-%M-%S")
                run_dir = os.path.join(self.base_dir, timestamp)
                os.makedirs(run_dir, exist_ok=True)
                print(f"Created results directory: {run_dir}")
                return run_dir
        
            def save_config(self, config: Dict):
                """Saves the simulation configuration to a JSON file."""
                config_path = os.path.join(self.run_dir, "config.json")
                with open(config_path, 'w') as f:
                    json.dump(config, f, indent=4)
                print(f"Configuration saved to {config_path}")
        
            def save_data_step(self, iteration: int, data: Dict[str, np.ndarray]):
                """Saves the data for a single timestep to a compressed .npz file."""
                filename = os.path.join(self.data_dir, f"timestep_{iteration}.npz")
                np.savez(filename, **data)
        --- End of io.py ---

        __init__.py
        --- Code in __init__.py ---
        --- End of __init__.py ---

        __pycache__/
            io.cpython-312.pyc
            __init__.cpython-312.pyc
            plotting.cpython-312.pyc
    __pycache__/
        __init__.cpython-312.pyc
    lattice/
        __init__.py
        --- Code in __init__.py ---
        from .lattice import Lattice
        --- End of __init__.py ---

        lattice.py
        --- Code in lattice.py ---
        import numpy as np
        import re
        from numpy import ndarray
        from typing import Any
        
        
        class Lattice(object):
        
            def __init__(self, name: str) -> None:
                self.name: str = name
                dq = re.findall(r'\d+', name)
                self.d: int = int(dq[0])
                self.q: int = int(dq[1])
        
                # Construct the properties of a lattice
                self.c: ndarray = self.construct_lattice_velocities
                self.w: ndarray = self.construct_lattice_weigths
                self.opp_indices: ndarray = self.construct_opposite_indices
                self.main_indices: ndarray = self.construct_main_indices
                self.right_indices: ndarray = self.construct_right_indices
                self.left_indices: ndarray = self.construct_left_indices
                self.top_indices: ndarray = self.construct_top_indices
                self.bottom_indices: ndarray = self.construct_bottom_indices
                if self.d == 3:
                    self.front_indices: ndarray = self.construct_front_indices
                    self.back_indices: ndarray = self.construct_back_indices
        
            @property
            def construct_lattice_velocities(self) -> ndarray:
                if self.name == "D2Q9":
                    cx = [0, 1, 0, -1, 0, 1, -1, -1, 1]
                    cy = [0, 0, 1, 0, -1, 1, 1, -1, -1]
                    c = np.array(tuple(zip(cx, cy)))
                else:
                    raise ValueError("Lattice not supported, D2Q9 is currently the only supported lattice.")
        
                return c.T
        
            @property
            def construct_lattice_weigths(self) -> ndarray:
                if self.name == "D2Q9":
                    w = np.array([4 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 36, 1 / 36, 1 / 36, 1 / 36])
                elif self.name == "D3Q15":
                    raise NotImplementedError("Dimension larger than 2 not supported.")
                else:
                    raise ValueError("Lattice not supported, D2Q9 is currently the only supported lattice.")
        
                return w
        
            @property
            def construct_opposite_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.array([c.tolist().index((-c[i]).tolist()) for i in range(self.q)])
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_main_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_right_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 0] == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_left_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 0] == -1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_top_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 1] == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_bottom_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 1] == -1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_front_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    raise ValueError("Only have front indices in 3D.")
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_back_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    raise ValueError("Only have front indices in 3D.")
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        --- End of lattice.py ---

        __pycache__/
            lattice.cpython-312.pyc
            __init__.cpython-312.pyc
    grid/
        grid.py
        --- Code in grid.py ---
        from typing import Tuple
        
        import numpy as np
        
        
        class Grid(object):
            def __init__(self, shape: Tuple[int, ...]):
                self.shape = shape
                self.dim = len(self.shape)
                if self.dim == 2:
                    self.nx, self.ny = self.shape
                if self.dim == 3:
                    self.nx, self.ny, self.nz = self.shape
        
            def get_edges(self):
                grid = np.indices(self.shape)
                if self.dim == 2:
                    edges = {
                        "left": (grid[0][0, :], grid[1][0, :]),
                        "right": (grid[0][-1, :], grid[1][-1, :]),
                        "bottom": (grid[0][:, 0], grid[1][:, 0]),
                        "top": (grid[0][:, -1], grid[1][:, -1])
                    }
                    return edges
                elif self.dim == 3:
                    edges = {
                        "left": (grid[0][0, :, :], grid[1][0, :, :], grid[2][0, :, :]),
                        "right": (grid[0][-1, :, :], grid[1][-1, :, :], grid[2][-1, :, :]),
                        "bottom": (grid[0][:, 0, :], grid[1][:, 0, :], grid[2][:, 0, :]),
                        "top": (grid[0][:, -1, :], grid[1][:, -1, :], grid[2][:, -1, :]),
                        "front": (grid[0][:, :, 0], grid[1][:, :, 0], grid[2][:, :, 0]),
                        "back": (grid[0][:, :, -1], grid[1][:, :, -1], grid[2][:, :, -1]),
                    }
                    return edges
                else:
                    raise NotImplementedError("Edge extraction for grids with dim != 2 or 3 is not implemented.")
        --- End of grid.py ---

        __init__.py
        --- Code in __init__.py ---
        from .grid import Grid        --- End of __init__.py ---

        __pycache__/
            grid.cpython-312.pyc
            __init__.cpython-312.pyc
example/
    test.py
    --- Code in test.py ---
    import numpy as np
    from wblbm.operators.run.run import Run
    from wblbm.utils.plotting import visualize_all_steps # Import the new function
    
    def test_basic_simulation():
        """Test a basic single-phase LBM simulation."""
        print("\n=== Basic LBM Simulation Test ===")
        sim = Run(
            grid_shape=(100, 50),
            lattice_type="D2Q9",
            tau=1.0,
            nt=500,
            save_interval=100,
            multiphase=False
        )
        sim.run(init_type='standard', verbose=True)
        return sim
    
    def test_multiphase_simulation():
        """Test a multiphase LBM simulation with a central bubble."""
        print("\n=== Multiphase LBM Simulation Test ===")
        sim = Run(
            grid_shape=(80, 80),
            lattice_type="D2Q9",
            tau=0.9,
            nt=300,
            save_interval=50,
            multiphase=True,
            kappa=0.05,
            rho_l=1.0,
            rho_v=0.1
        )
        sim.run(init_type='multiphase_bubble', verbose=True)
        return sim
    
    if __name__ == "__main__":
        print("Testing LBM Codebase with Refactored IO and Initialization")
        print("=" * 60)
    
        # Run simulations
        sim_basic = test_basic_simulation()
        sim_multiphase = test_multiphase_simulation()
    
        # Visualize results using the new, centralized function
        print("\n=== Visualizing Results ===")
        visualize_all_steps(sim_basic, "Basic LBM Simulation")
        visualize_all_steps(sim_multiphase, "Multiphase LBM Simulation")
    
        print("\nAll tests completed!")
    
    --- End of test.py ---

    results/
