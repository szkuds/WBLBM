/
    overview.py
    --- Code in overview.py ---
    import os
    
    
    def document_project(root_dir, output_file):
        with open(output_file, "w", encoding="utf-8") as doc:
            for dirpath, dirnames, filenames in os.walk(root_dir):
                # Remove hidden directories from dirnames in-place
                dirnames[:] = [d for d in dirnames if not d.startswith(".")]
                level = dirpath.replace(root_dir, "").count(os.sep)
                indent = "    " * level
                doc.write(f"{indent}{os.path.basename(dirpath)}/\n")
                subindent = "    " * (level + 1)
                for f in filenames:
                    if f.startswith("."):  # Skip hidden files as well (optional)
                        continue
                    file_path = os.path.join(dirpath, f)
                    doc.write(f"{subindent}{f}\n")
                    if f.endswith(".py"):
                        doc.write(f"{subindent}--- Code in {f} ---\n")
                        with open(file_path, "r", encoding="utf-8") as code_file:
                            for line in code_file:
                                doc.write(f"{subindent}{line}")
                        doc.write(f"{subindent}--- End of {f} ---\n\n")
    
    
    # Usage
    document_project("./", "./project_documentation.txt")
    --- End of overview.py ---

    project_documentation.txt
wblbm/
    __init__.py
    --- Code in __init__.py ---
    import wblbm.lattice
    import wblbm.grid    --- End of __init__.py ---

    operators/
        __init__.py
        --- Code in __init__.py ---
        --- End of __init__.py ---

        differential/
            gradient.py
            --- Code in gradient.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            
            
            class Gradient:
                """
                Callable class to calculate the gradient of a field using the provided stencil.
                """
            
                def __init__(self, lattice: Lattice):
                    self.w = lattice.w
                    self.c = lattice.c
            
                def __call__(self, grid):
                    """
                    Calculate the gradient using the provided stencil.
            
                    Args:
                        grid (jnp.ndarray): Input field, shape (nx, ny)
            
                    Returns:
                        jnp.ndarray: Gradient, shape (2, nx, ny)
                    """
                    w = self.w
                    c = self.c
            
                    grad_ = jnp.zeros((2, grid.shape[0], grid.shape[1]))
                    grid_padded = jnp.pad(grid, pad_width=1, mode='wrap')
            
                    # Side nodes
                    grid_ineg1_j0 = grid_padded[:-2, 1:-1]
                    grid_ipos1_j0 = grid_padded[2:, 1:-1]
                    grid_i0_jneg1 = grid_padded[1:-1, :-2]
                    grid_i0_jpos1 = grid_padded[1:-1, 2:]
            
                    # Corner nodes
                    grid_ipos1_jpos1 = grid_padded[2:, 2:]
                    grid_ineg1_jpos1 = grid_padded[:-2, 2:]
                    grid_ineg1_jneg1 = grid_padded[:-2, :-2]
                    grid_ipos1_jneg1 = grid_padded[2:, :-2]
            
                    grad_ = grad_.at[0, :, :].set(3 *
                                                  (w[1] * c[0, 1] * grid_ipos1_j0 +
                                                   w[3] * c[0, 3] * grid_ineg1_j0 +
                                                   w[5] * c[0, 5] * grid_ipos1_jpos1 +
                                                   w[6] * c[0, 6] * grid_ineg1_jpos1 +
                                                   w[7] * c[0, 7] * grid_ineg1_jneg1 +
                                                   w[8] * c[0, 8] * grid_ipos1_jneg1
                                                   )
                                                  )
            
                    grad_ = grad_.at[1, :, :].set(3 *
                                                  (w[2] * c[1, 2] * grid_i0_jpos1 +
                                                   w[4] * c[1, 4] * grid_i0_jneg1 +
                                                   w[5] * c[1, 5] * grid_ipos1_jpos1 +
                                                   w[6] * c[1, 6] * grid_ineg1_jpos1 +
                                                   w[7] * c[1, 7] * grid_ineg1_jneg1 +
                                                   w[8] * c[1, 8] * grid_ipos1_jneg1
                                                   )
                                                  )
            
                    return grad_
            --- End of gradient.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            laplacian.py
            --- Code in laplacian.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            
            class Laplacian:
                """
                Callable class to calculate the Laplacian of a 2D grid using the LBM stencil.
                """
            
                def __init__(self, lattice: Lattice):
                    self.w = lattice.w
            
                def __call__(self, grid):
                    """
                    Calculate the Laplacian of a 2D grid.
            
                    Args:
                        grid (jnp.ndarray): Input 2D grid.
            
                    Returns:
                        jnp.ndarray: Laplacian of the input grid.
                    """
                    w = self.w
            
                    laplacian_ = jnp.zeros_like(grid)
                    grid_padded = jnp.pad(grid, pad_width=1, mode='wrap')
            
                    # Side nodes
                    grid_ineg1_j0 = grid_padded[:-2, 1:-1]
                    grid_ipos1_j0 = grid_padded[2:, 1:-1]
                    grid_i0_jneg1 = grid_padded[1:-1, :-2]
                    grid_i0_jpos1 = grid_padded[1:-1, 2:]
            
                    # Corner nodes
                    grid_ipos1_jpos1 = grid_padded[2:, 2:]
                    grid_ineg1_jpos1 = grid_padded[:-2, 2:]
                    grid_ineg1_jneg1 = grid_padded[:-2, :-2]
                    grid_ipos1_jneg1 = grid_padded[2:, :-2]
            
                    # Central node
                    grid_i0_j0 = grid_padded[1:-1, 1:-1]
            
                    laplacian_ = laplacian_.at[:, :].set(6 *
                        (w[1] * (grid_ipos1_j0 - grid_i0_j0) +
                         w[2] * (grid_i0_jpos1 - grid_i0_j0) +
                         w[3] * (grid_ineg1_j0 - grid_i0_j0) +
                         w[4] * (grid_i0_jneg1 - grid_i0_j0) +
                         w[5] * (grid_ipos1_jpos1 - grid_i0_j0) +
                         w[6] * (grid_ineg1_jpos1 - grid_i0_j0) +
                         w[7] * (grid_ineg1_jneg1 - grid_i0_j0) +
                         w[8] * (grid_ipos1_jneg1 - grid_i0_j0)
                        )
                    )
            
                    return laplacian_
            
            --- End of laplacian.py ---

            __pycache__/
                gradient.cpython-312.pyc
                __init__.cpython-312.pyc
        macroscopic/
            macroscopic.py
            --- Code in macroscopic.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from typing import Tuple
            from wblbm.operators.differential.gradient import Gradient
            
            
            class Macroscopic:
                """
                Calculates the macroscopic density and velocity fields from the population distribution.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice) -> None:
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.cx: jnp.ndarray = jnp.array(lattice.c[0])
                    self.cy: jnp.ndarray = jnp.array(lattice.c[1])
                    self.gradient = Gradient(lattice)
            
                def __call__(self, f: jnp.ndarray) -> Tuple[jnp.ndarray, jnp.ndarray]:
                    """
                    Args:
                        f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)
                    Returns:
                        tuple: (rho, u)
                            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                            u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                    """
                    gradient = self.gradient
                    if self.d == 2:
                        # Compute density
                        rho = jnp.sum(f, axis=2, keepdims=True)  # (nx, ny, 1, 1)
            
                        # Compute velocity
                        cx = self.cx.reshape((1, 1, self.q, 1))
                        cy = self.cy.reshape((1, 1, self.q, 1))
                        ux = jnp.sum(f * cx, axis=2, keepdims=True)
                        uy = jnp.sum(f * cy, axis=2, keepdims=True)
                        u = jnp.concatenate([ux, uy], axis=-1) / rho  # (nx, ny, 1, 2)
                        return rho, u
                    elif self.d == 3:
                        raise NotImplementedError("Dimension larger than 2 not supported.")            --- End of macroscopic.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            macroscopic_multiphase.py
            --- Code in macroscopic_multiphase.py ---
            import jax.numpy as jnp
            
            from wblbm.grid import Grid
            from wblbm.operators.macroscopic.macroscopic import Macroscopic
            from wblbm.operators.differential.gradient import Gradient
            from wblbm.operators.differential.laplacian import Laplacian
            from wblbm.lattice.lattice import Lattice
            
            
            class MacroscopicMultiphase(Macroscopic):
                """
                Calculates macroscopic variables for multiphase simulations.
                Inherits from Macroscopic and adds multiphase-specific methods.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, kappa: float, beta: float, rho_l: float, rho_v: float):
                    super().__init__(grid, lattice)
                    self.kappa = kappa
                    self.beta = beta
                    self.rho_l = rho_l
                    self.rho_v = rho_v
                    self.gradient = Gradient(lattice)
                    self.laplacian = Laplacian(lattice)
            
                def __call__(self, f: jnp.ndarray) -> tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
                    """
                    Calculate the macroscopic density and velocity fields from the population distribution.
            
                    Args:
                        f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)
            
                    Returns:
                        tuple: (rho, u)
                            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                            u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                    """
                    rho, u = super().__call__(f)
                    force_int = self.force_int(rho)
                    u_updated = self.u_new(u, rho)
                    return rho, u_updated, force_int
            
                def eos(self, rho):
                    return 2 * self.beta * (rho - self.rho_l) * (rho - self.rho_v) * (2 * rho - self.rho_l - self.rho_v)
            
                def chem_pot(self, rho):
                    """
                    Calculate the chemical potential.
                    """
                    mu_0 = self.eos(rho)
                    chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)
                    return chem_pot__
            
                def force_int(self, rho):
                    """
                    Calculate the interaction force.
                    """
                    grad_chem_pot = self.gradient(self.chem_pot(rho))
                    # Return -rho * grad_chem_pot, shape (2, nx, ny)
                    return -rho * grad_chem_pot
            
                def u_new(self, u, rho):
                    """
                    Update velocity with interaction force.
                    """
                    force = self.force_int(rho)
                    # u: shape (nx, ny, 1, d), force: (2, nx, ny)
                    # Need to broadcast force to shape (nx, ny, 1, d)
                    force_broadcast = jnp.moveaxis(force, 0, -1)[..., jnp.newaxis, :]  # (nx, ny, 1, d)
                    return u + force_broadcast / 2
            --- End of macroscopic_multiphase.py ---

        update/
            update.py
            --- Code in update.py ---
            import jax.numpy as jnp
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision import Collision, SourceTerm
            from wblbm.operators.equilibrium.equilibirum import Equilibrium
            from wblbm.operators.macroscopic.macroscopic import Macroscopic
            from wblbm.operators.stream import Streaming
            
            
            class Update(object):
                def __init__(
                        self,
                        grid: Grid,
                        lattice: Lattice,
                        tau: float
                ):
                    self.grid = grid
                    self.lattice = lattice
                    self.tau = tau
                    self.macroscopic = Macroscopic(grid, lattice)
                    self.equilibrium = Equilibrium(grid, lattice)
                    self.collision = Collision(grid, lattice, tau)
                    self.source_term = SourceTerm(grid, lattice)
                    self.streaming = Streaming(lattice)
            
                def __call__(self, f: jnp.ndarray):
                    rho, u = self.macroscopic(f)
                    feq = self.equilibrium(rho, u)
                    fcol = self.collision(f, feq)
                    fstream = self.streaming(fcol)
                    return fstream
            
            
            
            --- End of update.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            update_multiphase.py
            --- Code in update_multiphase.py ---
            import jax.numpy as jnp
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision.collision_multiphase import CollisionMultiphase
            from wblbm.operators.update.update import Update
            from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
            
            
            class UpdateMultiphase(Update):
                def __init__(
                        self,
                        grid: Grid,
                        lattice: Lattice,
                        tau: float,
                        kappa: float,
                        beta: float,
                        rho_l: float,
                        rho_v: float
                ):
                    super().__init__(grid, lattice, tau)
                    self.macroscopic = MacroscopicMultiphase(grid, lattice, kappa, beta, rho_l, rho_v)
                    self.collision = CollisionMultiphase(grid, lattice, tau)
            
                def __call__(self, f: jnp.array):
                    rho, u, force = self.macroscopic(f)
                    feq = self.equilibrium(rho, u)
                    source = self.source_term(rho, u, force)
                    fcol = self.collision(f, feq, source)
                    fstream = self.streaming(fcol)
                    return fstream
            
            --- End of update_multiphase.py ---

        stream/
            __init__.py
            --- Code in __init__.py ---
            from .stream import Streaming
            --- End of __init__.py ---

            stream.py
            --- Code in stream.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            
            
            class Streaming:
                """
                Callable class to perform the streaming step of the LBM.
                """
            
                def __init__(self, lattice: Lattice):
                    self.c = lattice.c  # Shape: (2, Q)
                    self.q = lattice.q
            
                def __call__(self, f):
                    """
                    Perform the streaming step of the LBM.
            
                    Args:
                        f (jnp.ndarray): Distribution function, shape (nx, ny, q, 1)
            
                    Returns:
                        jnp.ndarray: Post-streaming distribution function.
                    """
                    for i in range(self.q):
                        f = f.at[:, :, i, 0].set(
                            jnp.roll(
                                jnp.roll(f[:, :, i, 0], self.c[0, i], axis=0),
                                self.c[1, i], axis=1))
                    return f
            --- End of stream.py ---

        initialise/
            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            init.py
            --- Code in init.py ---
            import numpy as np
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            
            
            class Initialise:
                """
                Base class for initialisation of the simulation.
                """
            
                def __init__(self, grid_shape, lattice_type):
                    self.grid = Grid(grid_shape)
                    self.lattice = Lattice(lattice_type)
                    self.nx, self.ny = grid_shape
                    self.q = self.lattice.q  # Number of discrete velocities
            
                def initialise_population(self, initial_value=1.0):
                    """
                    Initialise the population distribution f with shape (nx, ny, q, 1).
                    """
                    f = np.full((self.nx, self.ny, self.q, 1), initial_value, dtype=np.float64)
                    return f
            
                def set_boundary_conditions(self):
                    """
                    Set the boundary conditions for the simulation.
                    This method should be overridden by subclasses.
                    """
                    raise NotImplementedError("This method should be overridden by subclasses.")
            --- End of init.py ---

        __pycache__/
            __init__.cpython-312.pyc
        boundary_condition/
            boundary_condition.py
            --- Code in boundary_condition.py ---
            --- End of boundary_condition.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

        equilibrium/
            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            equilibirum.py
            --- Code in equilibirum.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            
            
            class Equilibrium:
                """
                Callable class to calculate the equilibrium population distribution for LBM.
                Uses the provided feq implementation directly.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice) -> None:
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.w = lattice.w
                    self.cx = lattice.c[0]
                    self.cy = lattice.c[1]
            
                def __call__(self, rho_, u_):
                    """
                    Calculate the equilibrium distribution function.
            
                    Args:
                        rho_ (jnp.ndarray): Density field.
                        u_ (jnp.ndarray): Velocity field.
            
                    Returns:
                        jnp.ndarray: Equilibrium distribution function.
                    """
                    nx, ny, q = self.nx, self.ny, self.q
                    w = self.w
                    c = (self.cx, self.cy)
                    f_eq = jnp.zeros((nx, ny, q))
                    w, cx, cy, ux, uy = w, c[0], c[1], u_[0], u_[1]
                    f_eq = f_eq.at[:, :, 1].set(w[1] * rho_ * (
                            3 * (cx[1] * ux + cy[1] * uy) + 4.5 * (cx[1] * ux + cy[1] * uy) ** 2 - 3 / 2 * (ux * ux + uy * uy)))
                    f_eq = f_eq.at[:, :, 2].set(w[2] * rho_ * (
                            3 * (cx[2] * ux + cy[2] * uy) + 4.5 * (cx[2] * ux + cy[2] * uy) ** 2 - 3 / 2 * (ux * ux + uy * uy)))
                    f_eq = f_eq.at[:, :, 3].set(w[3] * rho_ * (
                            3 * (cx[3] * ux + cy[3] * uy) + 4.5 * (cx[3] * ux + cy[3] * uy) ** 2 - 3 / 2 * (ux * ux + uy * uy)))
                    f_eq = f_eq.at[:, :, 4].set(w[4] * rho_ * (
                            3 * (cx[4] * ux + cy[4] * uy) + 4.5 * (cx[4] * ux + cy[4] * uy) ** 2 - 3 / 2 * (ux * ux + uy * uy)))
                    f_eq = f_eq.at[:, :, 5].set(w[5] * rho_ * (
                            3 * (cx[5] * ux + cy[5] * uy) + 4.5 * (cx[5] * ux + cy[5] * uy) ** 2 - 3 / 2 * (ux * ux + uy * uy)))
                    f_eq = f_eq.at[:, :, 6].set(w[6] * rho_ * (
                            3 * (cx[6] * ux + cy[6] * uy) + 4.5 * (cx[6] * ux + cy[6] * uy) ** 2 - 3 / 2 * (ux * ux + uy * uy)))
                    f_eq = f_eq.at[:, :, 7].set(w[7] * rho_ * (
                            3 * (cx[7] * ux + cy[7] * uy) + 4.5 * (cx[7] * ux + cy[7] * uy) ** 2 - 3 / 2 * (ux * ux + uy * uy)))
                    f_eq = f_eq.at[:, :, 8].set(w[8] * rho_ * (
                            3 * (cx[8] * ux + cy[8] * uy) + 4.5 * (cx[8] * ux + cy[8] * uy) ** 2 - 3 / 2 * (ux * ux + uy * uy)))
                    f_eq = f_eq.at[:, :, 0].set(rho_ * (1 - w[0] * (3 / 2 * (ux * ux + uy * uy))))
                    return f_eq
            --- End of equilibirum.py ---

        run/
            run.py
            --- Code in run.py ---
            --- End of run.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

        collision/
            collision_multiphase.py
            --- Code in collision_multiphase.py ---
            import jax.numpy as jnp
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision import Collision
            from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
            
            
            class CollisionMultiphase(Collision):
                def __init__(self, grid: Grid, lattice: Lattice, tau: float) -> None:
                    super().__init__(grid, lattice, tau)
            
                def __call__(self, f: jnp.ndarray, feq: jnp.ndarray, source: jnp.ndarray = None) -> jnp.ndarray:
                    result = super().__call__(f, feq)
                    if source is not None:
                        result += (1 - (1 / (2 * self.tau))) * source
                    return result
            --- End of collision_multiphase.py ---

            __init__.py
            --- Code in __init__.py ---
            from .collision import Collision
            from .source import SourceTerm            --- End of __init__.py ---

            collision.py
            --- Code in collision.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            
            
            class Collision:
                """
                Callable class to perform the collision step of the LBM.
                Implements the BGK collision operators with source terms.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, tau: float) -> None:
                    """
                    Initialize the Collision operators.
            
                    Args:
                        grid (Grid): Grid object containing simulation domain information
                        lattice (Lattice): Lattice object containing lattice properties
                        tau (float): Relaxation time parameter
                    """
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.tau: float = tau
            
                def __call__(self, f: jnp.ndarray, feq: jnp.ndarray) -> jnp.ndarray:
                    """
                    Perform the collision step of the LBM.
            
                    Args:
                        f (jnp.ndarray): Distribution function.
                        feq (jnp.ndarray): Equilibrium distribution function.
            
                    Returns:
                        jnp.ndarray: Post-collision distribution function.
                    """
                    return (1 - (1 / self.tau)) * f + (1 / self.tau) * feq
            --- End of collision.py ---

            source.py
            --- Code in source.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.operators.differential.gradient import Gradient
            class SourceTerm:
                """
                Callable class to calculate the source term for the LBM equation.
                Uses the provided source_term implementation directly.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice):
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.w = lattice.w
                    self.cx = lattice.c[0]
                    self.cy = lattice.c[1]
                    self.gradient = Gradient(lattice)
            
                def __call__(self, rho: jnp.ndarray, u: jnp.ndarray, force: jnp.ndarray) -> jnp.ndarray:
                    """
                    Calculate the source term for the LBM equation.
            
                    Args:
                        u (jnp.ndarray): Velocity field.
                        force (jnp.ndarray): Force field.
                        rho (jnp.ndarray): Density field.
            
                    Returns:
                        jnp.ndarray: Source term.
                    """
                    nx, ny, q = self.nx, self.ny, self.q
                    w = self.w
                    c = (self.cx, self.cy)
                    d = self.d
                    gradient = self.gradient
            
                    def source_term(u_, force_, rho_):
                        """
                        Calculate the source term for the LBM equation.
            
                        Args:
                            u_ (jnp.ndarray): Velocity field.
                            force_ (jnp.ndarray): Force field.
                            rho_ (jnp.ndarray): Density field.
            
                        Returns:
                            jnp.ndarray: Source term.
                        """
                        cx, cy, fx, fy, ux, uy, grad_rho_x, grad_rho_y = (
                            c[0],
                            c[1],
                            force_[0],
                            force_[1],
                            u_[0],
                            u_[1],
                            gradient(rho_)[0],
                            gradient(rho_)[1]
                        )
                        fx_cor = fx + (grad_rho_x / 3)
                        fy_cor = fy + (grad_rho_y / 3)
                        source_ = jnp.zeros((nx, ny, q))
                        source_ = source_.at[:, :, 0].set(w[0] * (3 * (cx[0] * fx + cy[0] * fy) +
                                                                  9 * (cx[0] * fx_cor + cy[0] * fy_cor) * (cx[0] * ux + cy[0] * uy) -
                                                                  3 * (ux * fx_cor + uy * fy_cor) +
                                                                  .5 * (3 * (cx[0] * cx[0] + cy[0] * cy[0]) - d) * (
                                                                          ux * grad_rho_x + uy * grad_rho_y)
                                                                  ))
                        source_ = source_.at[:, :, 1].set(w[1] * (3 * (cx[1] * fx + cy[1] * fy) +
                                                                  9 * (cx[1] * fx_cor + cy[1] * fy_cor) * (cx[1] * ux + cy[1] * uy) -
                                                                  3 * (ux * fx_cor + uy * fy_cor) +
                                                                  .5 * (3 * (cx[1] * cx[1] + cy[1] * cy[1]) - d) * (
                                                                          ux * grad_rho_x + uy * grad_rho_y)
                                                                  ))
                        source_ = source_.at[:, :, 2].set(w[2] * (3 * (cx[2] * fx + cy[2] * fy) +
                                                                  9 * (cx[2] * fx_cor + cy[2] * fy_cor) * (cx[2] * ux + cy[2] * uy) -
                                                                  3 * (ux * fx_cor + uy * fy_cor) +
                                                                  .5 * (3 * (cx[2] * cx[2] + cy[2] * cy[2]) - d) * (
                                                                          ux * grad_rho_x + uy * grad_rho_y)
                                                                  ))
                        source_ = source_.at[:, :, 3].set(w[3] * (3 * (cx[3] * fx + cy[3] * fy) +
                                                                  9 * (cx[3] * fx_cor + cy[3] * fy_cor) * (cx[3] * ux + cy[3] * uy) -
                                                                  3 * (ux * fx_cor + uy * fy_cor) +
                                                                  .5 * (3 * (cx[3] * cx[3] + cy[3] * cy[3]) - d) * (
                                                                          ux * grad_rho_x + uy * grad_rho_y)
                                                                  ))
                        source_ = source_.at[:, :, 4].set(w[4] * (3 * (cx[4] * fx + cy[4] * fy) +
                                                                  9 * (cx[4] * fx_cor + cy[4] * fy_cor) * (cx[4] * ux + cy[4] * uy) -
                                                                  3 * (ux * fx_cor + uy * fy_cor) +
                                                                  .5 * (3 * (cx[4] * cx[4] + cy[4] * cy[4]) - d) * (
                                                                          ux * grad_rho_x + uy * grad_rho_y)
                                                                  ))
                        source_ = source_.at[:, :, 5].set(w[5] * (3 * (cx[5] * fx + cy[5] * fy) +
                                                                  9 * (cx[5] * fx_cor + cy[5] * fy_cor) * (cx[5] * ux + cy[5] * uy) -
                                                                  3 * (ux * fx_cor + uy * fy_cor) +
                                                                  .5 * (3 * (cx[5] * cx[5] + cy[5] * cy[5]) - d) * (
                                                                          ux * grad_rho_x + uy * grad_rho_y)
                                                                  ))
                        source_ = source_.at[:, :, 6].set(w[6] * (3 * (cx[6] * fx + cy[6] * fy) +
                                                                  9 * (cx[6] * fx_cor + cy[6] * fy_cor) * (cx[6] * ux + cy[6] * uy) -
                                                                  3 * (ux * fx_cor + uy * fy_cor) +
                                                                  .5 * (3 * (cx[6] * cx[6] + cy[6] * cy[6]) - d) * (
                                                                          ux * grad_rho_x + uy * grad_rho_y)
                                                                  ))
                        source_ = source_.at[:, :, 7].set(w[7] * (3 * (cx[7] * fx + cy[7] * fy) +
                                                                  9 * (cx[7] * fx_cor + cy[7] * fy_cor) * (cx[7] * ux + cy[7] * uy) -
                                                                  3 * (ux * fx_cor + uy * fy_cor) +
                                                                  .5 * (3 * (cx[7] * cx[7] + cy[7] * cy[7]) - d) * (
                                                                          ux * grad_rho_x + uy * grad_rho_y)
                                                                  ))
                        source_ = source_.at[:, :, 8].set(w[8] * (3 * (cx[8] * fx + cy[8] * fy) +
                                                                  9 * (cx[8] * fx_cor + cy[8] * fy_cor) * (cx[8] * ux + cy[8] * uy) -
                                                                  3 * (ux * fx_cor + uy * fy_cor) +
                                                                  .5 * (3 * (cx[8] * cx[8] + cy[8] * cy[8]) - d) * (
                                                                          ux * grad_rho_x + uy * grad_rho_y)
                                                                  ))
                        return source_
            
                    return source_term(u, force, rho)
            --- End of source.py ---

    utils/
        __init__.py
        --- Code in __init__.py ---
        --- End of __init__.py ---

    __pycache__/
        __init__.cpython-312.pyc
    lattice/
        __init__.py
        --- Code in __init__.py ---
        from .lattice import Lattice
        --- End of __init__.py ---

        lattice.py
        --- Code in lattice.py ---
        import numpy as np
        import re
        from numpy import ndarray
        from typing import Any
        
        
        class Lattice(object):
        
            def __init__(self, name: str) -> None:
                self.name: str = name
                dq = re.findall(r'\d+', name)
                self.d: int = int(dq[0])
                self.q: int = int(dq[1])
        
                # Construct the properties of a lattice
                self.c: ndarray = self.construct_lattice_velocities
                self.w: ndarray = self.construct_lattice_weigths
                self.opp_indices: ndarray = self.construct_opposite_indices
                self.main_indices: ndarray = self.construct_main_indices
                self.right_indices: ndarray = self.construct_right_indices
                self.left_indices: ndarray = self.construct_left_indices
                self.top_indices: ndarray = self.construct_top_indices
                self.bottom_indices: ndarray = self.construct_bottom_indices
                if self.d == 3:
                    self.front_indices: ndarray = self.construct_front_indices
                    self.back_indices: ndarray = self.construct_back_indices
        
            @property
            def construct_lattice_velocities(self) -> ndarray:
                if self.name == "D2Q9":
                    cx = [0, 1, 0, -1, 0, 1, -1, -1, 1]
                    cy = [0, 0, 1, 0, -1, 1, 1, -1, -1]
                    c = np.array(tuple(zip(cx, cy)))
                else:
                    raise ValueError("Lattice not supported, D2Q9 is currently the only supported lattice.")
        
                return c.T
        
            @property
            def construct_lattice_weigths(self) -> ndarray:
                if self.name == "D2Q9":
                    w = np.array([4 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 36, 1 / 36, 1 / 36, 1 / 36])
                elif self.name == "D3Q15":
                    raise NotImplementedError("Dimension larger than 2 not supported.")
                else:
                    raise ValueError("Lattice not supported, D2Q9 is currently the only supported lattice.")
        
                return w
        
            @property
            def construct_opposite_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.array([c.tolist().index((-c[i]).tolist()) for i in range(self.q)])
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_main_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_right_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 0] == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_left_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 0] == -1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_top_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 1] == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_bottom_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 1] == -1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_front_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    raise ValueError("Only have front indices in 3D.")
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_back_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    raise ValueError("Only have front indices in 3D.")
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        --- End of lattice.py ---

        __pycache__/
            lattice.cpython-312.pyc
            __init__.cpython-312.pyc
    grid/
        grid.py
        --- Code in grid.py ---
        from typing import Tuple
        
        import numpy as np
        
        
        class Grid(object):
            def __init__(self, shape: Tuple[int, ...]):
                self.shape = shape
                self.dim = len(self.shape)
                if self.dim == 2:
                    self.nx, self.ny = self.shape
                if self.dim == 3:
                    self.nx, self.ny, self.nz = self.shape
        
            def get_edges(self):
                grid = np.indices(self.shape)
                if self.dim == 2:
                    edges = {
                        "left": (grid[0][0, :], grid[1][0, :]),
                        "right": (grid[0][-1, :], grid[1][-1, :]),
                        "bottom": (grid[0][:, 0], grid[1][:, 0]),
                        "top": (grid[0][:, -1], grid[1][:, -1])
                    }
                    return edges
                elif self.dim == 3:
                    edges = {
                        "left": (grid[0][0, :, :], grid[1][0, :, :], grid[2][0, :, :]),
                        "right": (grid[0][-1, :, :], grid[1][-1, :, :], grid[2][-1, :, :]),
                        "bottom": (grid[0][:, 0, :], grid[1][:, 0, :], grid[2][:, 0, :]),
                        "top": (grid[0][:, -1, :], grid[1][:, -1, :], grid[2][:, -1, :]),
                        "front": (grid[0][:, :, 0], grid[1][:, :, 0], grid[2][:, :, 0]),
                        "back": (grid[0][:, :, -1], grid[1][:, :, -1], grid[2][:, :, -1]),
                    }
                    return edges
                else:
                    raise NotImplementedError("Edge extraction for grids with dim != 2 or 3 is not implemented.")
        --- End of grid.py ---

        __init__.py
        --- Code in __init__.py ---
        from .grid import Grid        --- End of __init__.py ---

        __pycache__/
            grid.cpython-312.pyc
            __init__.cpython-312.pyc
example/
    test.py
    --- Code in test.py ---
    from wblbm.grid.grid import Grid
    from wblbm.lattice import Lattice
    import numpy as np
    
    lattice = Lattice("D2Q9")
    grid = Grid((200, 100))
    
    c: np.array = lattice.c
    bot = lattice.construct_bottom_indices
    edges = grid.get_edges()
    nx, ny = grid.nx, grid.ny
    
    print(c[0])
    --- End of test.py ---

