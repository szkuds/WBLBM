/
    overview.py
    --- Code in overview.py ---
    import os
    
    
    def document_project(root_dir, output_file):
        with open(output_file, "w", encoding="utf-8") as doc:
            for dirpath, dirnames, filenames in os.walk(root_dir):
                # Remove hidden directories from dirnames in-place
                dirnames[:] = [d for d in dirnames if not d.startswith(".")]
                level = dirpath.replace(root_dir, "").count(os.sep)
                indent = "    " * level
                doc.write(f"{indent}{os.path.basename(dirpath)}/\n")
                subindent = "    " * (level + 1)
                for f in filenames:
                    if f.startswith("."):  # Skip hidden files as well (optional)
                        continue
                    file_path = os.path.join(dirpath, f)
                    doc.write(f"{subindent}{f}\n")
                    if f.endswith(".py"):
                        doc.write(f"{subindent}--- Code in {f} ---\n")
                        with open(file_path, "r", encoding="utf-8") as code_file:
                            for line in code_file:
                                doc.write(f"{subindent}{line}")
                        doc.write(f"{subindent}--- End of {f} ---\n\n")
    
    
    # Usage
    document_project("./", "./project_documentation.txt")
    --- End of overview.py ---

    project_documentation.txt
wblbm/
    __init__.py
    --- Code in __init__.py ---
    import wblbm.lattice
    import wblbm.grid    --- End of __init__.py ---

    operators/
        __init__.py
        --- Code in __init__.py ---
        --- End of __init__.py ---

        differential/
            gradient.py
            --- Code in gradient.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.lattice.lattice import Lattice
            
            
            class Gradient:
                """
                Callable class to calculate the gradient of a field using the provided stencil.
                """
            
                def __init__(self, lattice: Lattice):
                    self.w = lattice.w
                    self.c = lattice.c
            
                @partial(jit, static_argnums=(0,))
                def __call__(self, grid):
                    """
                    Calculate the gradient using the provided stencil.
            
                    Args:
                        grid (jnp.ndarray): Input field, shape (nx, ny, 1, 1)
            
                    Returns:
                        jnp.ndarray: Gradient, shape (nx, ny, 1, 2)
                    """
                    # Extract 2D data from 4D input
                    if grid.ndim == 4:
                        grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    else:
                        grid_2d = grid
            
                    w = self.w
                    c = self.c
            
                    grad_ = jnp.zeros((2, grid_2d.shape[0], grid_2d.shape[1]))
                    grid_padded = jnp.pad(grid_2d, pad_width=1, mode='wrap')
            
                    # Side nodes
                    grid_ineg1_j0 = grid_padded[:-2, 1:-1]
                    grid_ipos1_j0 = grid_padded[2:, 1:-1]
                    grid_i0_jneg1 = grid_padded[1:-1, :-2]
                    grid_i0_jpos1 = grid_padded[1:-1, 2:]
            
                    # Corner nodes
                    grid_ipos1_jpos1 = grid_padded[2:, 2:]
                    grid_ineg1_jpos1 = grid_padded[:-2, 2:]
                    grid_ineg1_jneg1 = grid_padded[:-2, :-2]
                    grid_ipos1_jneg1 = grid_padded[2:, :-2]
            
                    grad_ = grad_.at[0, :, :].set(3 *
                                                  (w[1] * c[0, 1] * grid_ipos1_j0 +
                                                   w[3] * c[0, 3] * grid_ineg1_j0 +
                                                   w[5] * c[0, 5] * grid_ipos1_jpos1 +
                                                   w[6] * c[0, 6] * grid_ineg1_jpos1 +
                                                   w[7] * c[0, 7] * grid_ineg1_jneg1 +
                                                   w[8] * c[0, 8] * grid_ipos1_jneg1
                                                   )
                                                  )
            
                    grad_ = grad_.at[1, :, :].set(3 *
                                                  (w[2] * c[1, 2] * grid_i0_jpos1 +
                                                   w[4] * c[1, 4] * grid_i0_jneg1 +
                                                   w[5] * c[1, 5] * grid_ipos1_jpos1 +
                                                   w[6] * c[1, 6] * grid_ineg1_jpos1 +
                                                   w[7] * c[1, 7] * grid_ineg1_jneg1 +
                                                   w[8] * c[1, 8] * grid_ipos1_jneg1
                                                   )
                                                  )
            
                    # Convert to 4D format: (nx, ny, 1, 2)
                    grad_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 2))
                    grad_4d = grad_4d.at[:, :, 0, 0].set(grad_[0, :, :])
                    grad_4d = grad_4d.at[:, :, 0, 1].set(grad_[1, :, :])
            
                    return grad_4d
            --- End of gradient.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            laplacian.py
            --- Code in laplacian.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.lattice.lattice import Lattice
            
            
            class Laplacian:
                """
                Callable class to calculate the Laplacian of a 2D grid using the LBM stencil.
                """
            
                def __init__(self, lattice: Lattice):
                    self.w = lattice.w
            
                @partial(jit, static_argnums=(0,))
                def __call__(self, grid):
                    """
                    Calculate the Laplacian of a 2D grid.
            
                    Args:
                        grid (jnp.ndarray): Input grid, shape (nx, ny, 1, 1)
            
                    Returns:
                        jnp.ndarray: Laplacian of the input grid, shape (nx, ny, 1, 1)
                    """
                    # Extract 2D data from 4D input
                    if grid.ndim == 4:
                        grid_2d = grid[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    else:
                        grid_2d = grid
            
                    w = self.w
            
                    laplacian_2d = jnp.zeros_like(grid_2d)
                    grid_padded = jnp.pad(grid_2d, pad_width=1, mode='wrap')
            
                    # Side nodes
                    grid_ineg1_j0 = grid_padded[:-2, 1:-1]
                    grid_ipos1_j0 = grid_padded[2:, 1:-1]
                    grid_i0_jneg1 = grid_padded[1:-1, :-2]
                    grid_i0_jpos1 = grid_padded[1:-1, 2:]
            
                    # Corner nodes
                    grid_ipos1_jpos1 = grid_padded[2:, 2:]
                    grid_ineg1_jpos1 = grid_padded[:-2, 2:]
                    grid_ineg1_jneg1 = grid_padded[:-2, :-2]
                    grid_ipos1_jneg1 = grid_padded[2:, :-2]
            
                    # Central node
                    grid_i0_j0 = grid_padded[1:-1, 1:-1]
            
                    laplacian_2d = laplacian_2d.at[:, :].set(6 *
                                                             (w[1] * (grid_ipos1_j0 - grid_i0_j0) +
                                                              w[2] * (grid_i0_jpos1 - grid_i0_j0) +
                                                              w[3] * (grid_ineg1_j0 - grid_i0_j0) +
                                                              w[4] * (grid_i0_jneg1 - grid_i0_j0) +
                                                              w[5] * (grid_ipos1_jpos1 - grid_i0_j0) +
                                                              w[6] * (grid_ineg1_jpos1 - grid_i0_j0) +
                                                              w[7] * (grid_ineg1_jneg1 - grid_i0_j0) +
                                                              w[8] * (grid_ipos1_jneg1 - grid_i0_j0)
                                                              )
                                                             )
            
                    # Convert to 4D format: (nx, ny, 1, 1)
                    laplacian_4d = jnp.zeros((grid_2d.shape[0], grid_2d.shape[1], 1, 1))
                    laplacian_4d = laplacian_4d.at[:, :, 0, 0].set(laplacian_2d)
            
                    return laplacian_4d
            --- End of laplacian.py ---

            __pycache__/
                laplacian.cpython-312.pyc
                gradient.cpython-312.pyc
                __init__.cpython-312.pyc
        macroscopic/
            macroscopic.py
            --- Code in macroscopic.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from typing import Tuple
            from wblbm.operators.differential.gradient import Gradient
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            
            class Macroscopic:
                """
                Calculates the macroscopic density and velocity fields from the population distribution.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, force_enabled: bool = False) -> None:
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.cx: jnp.ndarray = jnp.array(lattice.c[0])
                    self.cy: jnp.ndarray = jnp.array(lattice.c[1])
                    self.gradient = Gradient(lattice)
                    self.force_enabled = force_enabled
            
                @time_function(enable_timing=TIMING_ENABLED)
                @partial(jit, static_argnums=(0,))
                def __call__(self, f: jnp.ndarray, force: jnp.ndarray = None) -> Tuple[jnp.ndarray, jnp.ndarray]:
                    """
                    Args:
                        f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)
                        force (jnp.ndarray, optional): Force field, shape (nx, ny, 1, 2). Required if force_enabled is True.
            
                    Returns:
                        tuple: (rho, u)
                            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                            u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                    """
                    if self.d == 2:
                        # Compute density
                        rho = jnp.sum(f, axis=2, keepdims=True)  # (nx, ny, 1, 1)
            
                        # Compute velocity
                        cx = self.cx.reshape((1, 1, self.q, 1))
                        cy = self.cy.reshape((1, 1, self.q, 1))
                        ux = jnp.sum(f * cx, axis=2, keepdims=True)
                        uy = jnp.sum(f * cy, axis=2, keepdims=True)
                        u = jnp.concatenate([ux, uy], axis=-1) / rho  # (nx, ny, 1, 2)
            
                        # New: Optional force update, similar to MacroscopicMultiphase
                        if self.force_enabled:
                            if force is None:
                                # Default to zero force if not provided (or raise error if strict enforcement needed)
                                force = jnp.zeros_like(u)
                            u = u + force / 2  # Update velocity as in multiphase class
            
                        return rho, u
                    elif self.d == 3:
                        raise NotImplementedError("Dimension larger than 2 not supported.")            --- End of macroscopic.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            macroscopic_multiphase.py
            --- Code in macroscopic_multiphase.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid import Grid
            from wblbm.operators.macroscopic.macroscopic import Macroscopic
            from wblbm.operators.differential.gradient import Gradient
            from wblbm.operators.differential.laplacian import Laplacian
            from wblbm.lattice.lattice import Lattice
            
            
            class MacroscopicMultiphase(Macroscopic):
                """
                Calculates macroscopic variables for multiphase simulations.
                Inherits from Macroscopic and adds multiphase-specific methods.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, kappa: float, interface_width: int, rho_l: float, rho_v: float):
                    super().__init__(grid, lattice)
                    self.kappa = kappa
                    self.rho_l = rho_l
                    self.rho_v = rho_v
                    self.gradient = Gradient(lattice)
                    self.laplacian = Laplacian(lattice)
                    self.beta = 8 * kappa / (float(interface_width) ** 2 * (rho_l - rho_v) ** 2)
            
                @partial(jit, static_argnums=(0,))
                def __call__(self, f: jnp.ndarray) -> tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray]:
                    """
                    Calculate the macroscopic density and velocity fields from the population distribution.
            
                    Args:
                        f (jnp.ndarray): Population distribution, shape (nx, ny, q, 1)
            
                    Returns:
                        tuple: (rho, u, force_int)
                            rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                            u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                            force_int (jnp.ndarray): Interaction force, shape (nx, ny, 1, 2)
                    """
                    rho, u = super().__call__(f)
                    force_int = self.force_int(rho)
                    u_updated = self.u_new(u, force_int)
                    return rho, u_updated, force_int
            
                @partial(jit, static_argnums=(0,))
                def eos(self, rho):
                    """Equation of state - extract 2D data for computation"""
                    rho_2d = rho[:, :, 0, 0]  # Extract (nx, ny) from (nx, ny, 1, 1)
                    eos_2d = 2 * self.beta * (rho_2d - self.rho_l) * (rho_2d - self.rho_v) * (2 * rho_2d - self.rho_l - self.rho_v)
            
                    # Convert back to 4D format
                    eos_4d = jnp.zeros_like(rho)
                    eos_4d = eos_4d.at[:, :, 0, 0].set(eos_2d)
                    return eos_4d
            
                @partial(jit, static_argnums=(0,))
                def chem_pot(self, rho):
                    """
                    Calculate the chemical potential.
                    """
                    mu_0 = self.eos(rho)
                    chem_pot__ = mu_0 - self.kappa * self.laplacian(rho)
                    return chem_pot__
            
                @partial(jit, static_argnums=(0,))
                def force_int(self, rho):
                    """
                    Calculate the interaction force.
                    """
                    grad_chem_pot = self.gradient(self.chem_pot(rho))  # Shape: (nx, ny, 1, 2)
                    # Return -rho * grad_chem_pot, shape (nx, ny, 1, 2)
                    return -rho * grad_chem_pot
            
                @partial(jit, static_argnums=(0,))
                def u_new(self, u, force):
                    """
                    Update velocity with interaction force.
                    """
                    # Both u and force have shape (nx, ny, 1, 2)
                    return u + force / 2
            --- End of macroscopic_multiphase.py ---

            __pycache__/
                macroscopic_multiphase.cpython-312.pyc
                __init__.cpython-312.pyc
                macroscopic.cpython-312.pyc
        update/
            update.py
            --- Code in update.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.boundary_condition.boundary_condition import BoundaryCondition
            from wblbm.operators.collision import Collision, SourceTerm
            from wblbm.operators.equilibrium.equilibirum import Equilibrium
            from wblbm.operators.macroscopic.macroscopic import Macroscopic
            from wblbm.operators.stream import Streaming
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            
            class Update(object):
                def __init__(
                        self,
                        grid: Grid,
                        lattice: Lattice,
                        tau: float,
                        bc_config: dict = None,
                        force_enabled: bool = False
                ):
                    self.grid = grid
                    self.lattice = lattice
                    self.tau = tau
                    self.macroscopic = Macroscopic(grid, lattice, force_enabled=force_enabled)
                    self.equilibrium = Equilibrium(grid, lattice)
                    self.collision = Collision(grid, lattice, tau)
                    self.source_term = SourceTerm(grid, lattice)
                    self.streaming = Streaming(lattice)
                    if bc_config is not None:
                        self.boundary_condition = BoundaryCondition(grid, lattice, bc_config)
                    else:
                        self.boundary_condition = None
                    self.force_enabled = force_enabled
            
                @partial(jit, static_argnums=(0,))
                @time_function(enable_timing=TIMING_ENABLED)
                def __call__(self, f: jnp.ndarray, force: jnp.ndarray = None):
                    # If force_enabled and no force provided, use a simple constant force for testing
                    if self.force_enabled and force is None:
                        # Example: uniform force in x-direction
                        force = jnp.ones((self.grid.nx, self.grid.ny, 1, 2)) * jnp.array([0.01, 0.0])
                    rho, u = self.macroscopic(f, force=force) if self.force_enabled else self.macroscopic(f)
                    feq = self.equilibrium(rho, u)
                    fcol = self.collision(f, feq)
                    fstream = self.streaming(fcol)
                    if self.boundary_condition is not None:
                        fstream = self.boundary_condition(fstream, fcol)
                    return fstream
            --- End of update.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            update_multiphase.py
            --- Code in update_multiphase.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision.collision_multiphase import CollisionMultiphase
            from wblbm.operators.update.update import Update
            from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
            from wblbm.operators.boundary_condition.boundary_condition import BoundaryCondition
            
            
            class UpdateMultiphase(Update):
                def __init__(
                        self,
                        grid: Grid,
                        lattice: Lattice,
                        tau: float,
                        kappa: float,
                        interface_width: int,
                        rho_l: float,
                        rho_v: float,
                        bc_config: dict = None,
                        force_enabled: bool = False
                ):
                    super().__init__(grid, lattice, tau, bc_config, force_enabled=force_enabled)
                    self.macroscopic = MacroscopicMultiphase(grid, lattice, kappa, interface_width, rho_l, rho_v)
                    self.collision = CollisionMultiphase(grid, lattice, tau)
                    if bc_config is not None:
                        self.boundary_condition = BoundaryCondition(grid, lattice, bc_config)
                    else:
                        self.boundary_condition = None
                    self.force_enabled = force_enabled
            
                @partial(jit, static_argnums=(0,))
                def __call__(self, f: jnp.array, force: jnp.ndarray = None):
                    # If force_enabled and no force provided, use a simple constant force for testing
                    if self.force_enabled and force is None:
                        force = jnp.ones((self.grid.nx, self.grid.ny, 1, 2)) * jnp.array([0.01, 0.0])
                    rho, u, force_int = self.macroscopic(f, force=force) if self.force_enabled else self.macroscopic(f)
                    feq = self.equilibrium(rho, u)
                    source = self.source_term(rho, u, force_int)
                    fcol = self.collision(f, feq, source)
                    fstream = self.streaming(fcol)
                    if self.boundary_condition is not None:
                        fstream = self.boundary_condition(fstream, fcol)
                    return fstream
            --- End of update_multiphase.py ---

            __pycache__/
                update_multiphase.cpython-312.pyc
                update.cpython-312.pyc
                __init__.cpython-312.pyc
        stream/
            __init__.py
            --- Code in __init__.py ---
            from .stream import Streaming
            --- End of __init__.py ---

            stream.py
            --- Code in stream.py ---
            import jax.numpy as jnp
            from wblbm.lattice.lattice import Lattice
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            
            class Streaming:
                """
                Callable class to perform the streaming step of the LBM.
                """
            
                def __init__(self, lattice: Lattice):
                    self.c = lattice.c  # Shape: (2, Q)
                    self.q = lattice.q
            
                @time_function(enable_timing=TIMING_ENABLED)
                def __call__(self, f):
                    """
                    Perform the streaming step of the LBM.
            
                    Args:
                        f (jnp.ndarray): Distribution function, shape (nx, ny, q, 1)
            
                    Returns:
                        jnp.ndarray: Post-streaming distribution function.
                    """
                    for i in range(self.q):
                        f = f.at[:, :, i, 0].set(
                            jnp.roll(
                                jnp.roll(f[:, :, i, 0], self.c[0, i], axis=0),
                                self.c[1, i], axis=1))
                    return f
            --- End of stream.py ---

            __pycache__/
                stream.cpython-312.pyc
                __init__.cpython-312.pyc
        initialise/
            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            init.py
            --- Code in init.py ---
            import jax.numpy as jnp
            import numpy as np
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.operators.equilibrium.equilibirum import Equilibrium
            
            
            class Initialise:
                """
                Handles the initialisation of the simulation for various scenarios.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice):
                    self.grid = grid
                    self.lattice = lattice
                    self.nx, self.ny = grid.nx, grid.ny
                    self.q = self.lattice.q
                    self.equilibrium = Equilibrium(self.grid, self.lattice)
            
                def initialise_standard(self, density: float = 1.0, velocity: np.ndarray = np.array([0.0, 0.0])):
                    """
                    Initialises a standard simulation with uniform density and velocity.
            
                    Args:
                        density (float): Initial uniform density.
                        velocity (np.ndarray): Initial uniform velocity [ux, uy].
            
                    Returns:
                        jnp.ndarray: Initialised population distribution f.
                    """
                    # Create density and velocity fields with the correct 4D shape
                    rho = jnp.full((self.nx, self.ny, 1, 1), density)
            
                    u = jnp.broadcast_to(
                        jnp.array(velocity).reshape(1, 1, 1, 2),
                        (self.nx, self.ny, 1, 2)
                    )
            
                    # Return the equilibrium distribution for this state
                    return self.equilibrium(rho, u)
            
                def initialise_multiphase_droplet(self, rho_l: float, rho_v: float, interface_width: int):
                    """
                    Initialises a multiphase simulation with a low-density bubble in the center.
            
                    Args:
                        rho_l (float): Liquid phase density.
                        rho_v (float): Vapour phase (bubble) density.
            
                    Returns:
                        jnp.ndarray: Initialised population distribution f.
                    """
                    # Create a density field with a bubble in the center
                    x, y = jnp.meshgrid(jnp.arange(self.nx), jnp.arange(self.ny), indexing='ij')
                    center_x, center_y = self.nx // 2, self.ny // 2
                    radius = min(self.nx, self.ny) // 4
            
                    # Use tanh for a smooth, stable interface
                    distance = jnp.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
                    rho_field_2d = (rho_l + rho_v) / 2 - (rho_l - rho_v) / 2 * jnp.tanh((distance - radius) / interface_width)
            
                    # Reshape to 4D
                    rho = rho_field_2d.reshape((self.nx, self.ny, 1, 1))
            
                    # Initialise with zero velocity
                    u = jnp.zeros((self.nx, self.ny, 1, 2))
            
                    # Return the equilibrium distribution
                    return self.equilibrium(rho, u)
            
                def initialise_multiphase_bubble(self, rho_l: float, rho_v: float, interface_width: int):
                    """
                    Initialises a multiphase simulation with a low-density bubble in the center.
            
                    Args:
                        rho_l (float): Liquid phase density.
                        rho_v (float): Vapour phase (bubble) density.
            
                    Returns:
                        jnp.ndarray: Initialised population distribution f.
                    """
                    # Create a density field with a bubble in the center
                    x, y = jnp.meshgrid(jnp.arange(self.nx), jnp.arange(self.ny), indexing='ij')
                    center_x, center_y = self.nx // 2, self.ny // 2
                    radius = min(self.nx, self.ny) // 4
            
                    # Use tanh for a smooth, stable interface
                    distance = jnp.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
                    rho_field_2d = (rho_l + rho_v) / 2 + (rho_l - rho_v) / 2 * jnp.tanh((distance - radius) / interface_width)
            
                    # Reshape to 4D
                    rho = rho_field_2d.reshape((self.nx, self.ny, 1, 1))
            
                    # Initialise with zero velocity
                    u = jnp.zeros((self.nx, self.ny, 1, 2))
            
                    # Return the equilibrium distribution
                    return self.equilibrium(rho, u)
            --- End of init.py ---

            __pycache__/
                init.cpython-312.pyc
                __init__.cpython-312.pyc
        __pycache__/
            __init__.cpython-312.pyc
        boundary_condition/
            boundary_condition.py
            --- Code in boundary_condition.py ---
            from functools import partial
            import jax.numpy as jnp
            from jax import jit
            from typing import Dict
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            class BoundaryCondition:
                """
                Applies boundary conditions to the post-streaming distribution function.
                Supports bounce-back, symmetry, and periodic BCs on specified grid edges.
                Uses dynamic indices from Lattice class instead of hardcoding.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, bc_config: Dict[str, str]):
                    self.grid = grid
                    self.lattice = lattice
                    self.bc_config = bc_config
                    self.opp_indices = lattice.opp_indices
                    self.edges = grid.get_edges()
                    valid_edges = ['top', 'bottom', 'left', 'right']
                    valid_types = ['bounce-back', 'symmetry', 'periodic']
                    for edge, bc_type in bc_config.items():
                        if edge not in valid_edges:
                            raise ValueError(f"Invalid edge: {edge}. Must be one of {valid_edges}.")
                        if bc_type not in valid_types:
                            raise ValueError(f"Invalid BC type: {bc_type}. Must be one of {valid_types}.")
            
                @time_function(enable_timing=TIMING_ENABLED)
                @partial(jit, static_argnums=(0,))
                def __call__(self, f_streamed: jnp.ndarray, f_collision: jnp.ndarray) -> jnp.ndarray:
                    for edge, bc_type in self.bc_config.items():
                        if bc_type == 'bounce-back':
                            f_streamed = self._apply_bounce_back(f_streamed, f_collision, edge)
                        elif bc_type == 'symmetry':
                            f_streamed = self._apply_symmetry(f_streamed, f_collision, edge)
                        elif bc_type == 'periodic':
                            f_streamed = self._apply_periodic(f_streamed, edge)
                    return f_streamed
            
                @partial(jit, static_argnums=(0, 3))
                def _apply_bounce_back(self, f_streamed: jnp.ndarray, f_collision: jnp.ndarray, edge: str) -> jnp.ndarray:
                    lattice = self.lattice
                    if edge == 'bottom':
                        idx = 0
                        incoming_dirs = lattice.construct_top_indices
                        for i in incoming_dirs:
                            opp_i = self.opp_indices[i]
                            f_streamed = f_streamed.at[:, idx, i, 0].set(f_collision[:, idx, opp_i, 0])
                    elif edge == 'top':
                        idx = -1
                        incoming_dirs = lattice.construct_bottom_indices
                        for i in incoming_dirs:
                            opp_i = self.opp_indices[i]
                            f_streamed = f_streamed.at[:, idx, i, 0].set(f_collision[:, idx, opp_i, 0])
                    elif edge == 'left':
                        idx = 0
                        incoming_dirs = lattice.construct_right_indices
                        for i in incoming_dirs:
                            opp_i = self.opp_indices[i]
                            f_streamed = f_streamed.at[idx, :, i, 0].set(f_collision[idx, :, opp_i, 0])
                    elif edge == 'right':
                        idx = -1
                        incoming_dirs = lattice.construct_left_indices
                        for i in incoming_dirs:
                            opp_i = self.opp_indices[i]
                            f_streamed = f_streamed.at[idx, :, i, 0].set(f_collision[idx, :, opp_i, 0])
                    return f_streamed
            
                @partial(jit, static_argnums=(0, 3))
                def _apply_symmetry(self, f_streamed: jnp.ndarray, f_collision: jnp.ndarray, edge: str) -> jnp.ndarray:
                    lattice = self.lattice
                    if edge == 'bottom':
                        idx = 0
                        top_dirs = lattice.construct_top_indices
                        bottom_dirs = lattice.construct_bottom_indices
                        diag_top_right = lattice.construct_top_indices[2]
                        diag_bottom_right = lattice.construct_bottom_indices[2]
                        diag_top_left = lattice.construct_top_indices[1]
                        diag_bottom_left = lattice.construct_bottom_indices[1]
                        f_streamed = f_streamed.at[:, idx, top_dirs[0], 0].set(f_collision[:, idx, bottom_dirs[0], 0])
                        f_streamed = f_streamed.at[:, idx, diag_top_right, 0].set(f_collision[:, idx, diag_bottom_right, 0])
                        f_streamed = f_streamed.at[:, idx, diag_top_left, 0].set(f_collision[:, idx, diag_bottom_left, 0])
                    elif edge == 'top':
                        idx = -1
                        bottom_dirs = lattice.construct_bottom_indices
                        top_dirs = lattice.construct_top_indices
                        f_streamed = f_streamed.at[:, idx, bottom_dirs[0], 0].set(f_collision[:, idx, top_dirs[0], 0])
                        f_streamed = f_streamed.at[:, idx, bottom_dirs[1], 0].set(jnp.roll(f_collision[:, idx, top_dirs[1], 0], 1, axis=0))
                        f_streamed = f_streamed.at[:, idx, bottom_dirs[2], 0].set(jnp.roll(f_collision[:, idx, top_dirs[2], 0], -1, axis=0))
                    elif edge == 'left':
                        idx = 0
                        right_dirs = lattice.construct_right_indices
                        left_dirs = lattice.construct_left_indices
                        f_streamed = f_streamed.at[idx, :, right_dirs[0], 0].set(f_collision[idx, :, left_dirs[0], 0])
                        f_streamed = f_streamed.at[idx, :, right_dirs[1], 0].set(f_collision[idx, :, left_dirs[1], 0])
                        f_streamed = f_streamed.at[idx, :, right_dirs[2], 0].set(f_collision[idx, :, left_dirs[2], 0])
                    elif edge == 'right':
                        idx = -1
                        left_dirs = lattice.construct_left_indices
                        right_dirs = lattice.construct_right_indices
                        f_streamed = f_streamed.at[idx, :, left_dirs[0], 0].set(f_collision[idx, :, right_dirs[0], 0])
                        f_streamed = f_streamed.at[idx, :, left_dirs[1], 0].set(f_collision[idx, :, right_dirs[1], 0])
                        f_streamed = f_streamed.at[idx, :, left_dirs[2], 0].set(f_collision[idx, :, right_dirs[2], 0])
                    return f_streamed
            
                @partial(jit, static_argnums=(0, 2))
                def _apply_periodic(self, f_streamed: jnp.ndarray, edge: str) -> jnp.ndarray:
                    if edge in ['left', 'right']:
                        axis = 0
                    elif edge in ['bottom', 'top']:
                        axis = 1
                    f_streamed = jnp.roll(f_streamed, shift=1, axis=axis)
                    return f_streamed
            --- End of boundary_condition.py ---

            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            __pycache__/
                boundary_condition.cpython-312.pyc
                __init__.cpython-312.pyc
        equilibrium/
            __init__.py
            --- Code in __init__.py ---
            --- End of __init__.py ---

            equilibirum.py
            --- Code in equilibirum.py ---
            from functools import partial
            
            import jax.numpy as jnp
            from jax import jit
            
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.utils.timing import time_function, TIMING_ENABLED
            
            
            class Equilibrium:
                """
                Callable class to calculate the equilibrium population distribution for LBM.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice) -> None:
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.w = lattice.w
                    self.cx = lattice.c[0]
                    self.cy = lattice.c[1]
            
                @time_function(enable_timing=TIMING_ENABLED)
                @partial(jit, static_argnums=(0,))
                def __call__(self, rho_, u_):
                    """
                    Calculate the equilibrium distribution function.
            
                    Args:
                        rho_ (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                        u_ (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
            
                    Returns:
                        jnp.ndarray: Equilibrium distribution function, shape (nx, ny, q, 1)
                    """
                    nx, ny, q = self.nx, self.ny, self.q
                    w = self.w
                    cx, cy = self.cx, self.cy
            
                    # Extract velocity components
                    ux = u_[..., 0]  # Shape: (nx, ny, 1)
                    uy = u_[..., 1]  # Shape: (nx, ny, 1)
            
                    # Squeeze density to match velocity dimensions
                    rho = rho_.squeeze(axis=-1)  # Shape: (nx, ny, 1)
            
                    # Initialize equilibrium distribution - note the 4D shape
                    f_eq = jnp.zeros((nx, ny, q, 1))
            
                    # Calculate equilibrium for each velocity direction
                    for i in range(q):
                        cu = cx[i] * ux + cy[i] * uy
                        cu2 = cu * cu
                        u2 = ux * ux + uy * uy
            
                        f_eq = f_eq.at[:, :, i, :].set(
                            w[i] * rho * (3 * cu + 4.5 * cu2 - 1.5 * u2)
                        )
                    f_eq = f_eq.at[:, :, 0, :].set(rho[:, :, :] * (1 - w[0] * (3 / 2 * (ux * ux + uy * uy))))
            
                    return f_eq
            --- End of equilibirum.py ---

            __pycache__/
                equilibirum.cpython-312.pyc
                __init__.cpython-312.pyc
        run/
            run.py
            --- Code in run.py ---
            import jax.numpy as jnp
            import numpy as np
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.initialise.init import Initialise
            from wblbm.operators.update.update import Update
            from wblbm.operators.update.update_multiphase import UpdateMultiphase
            from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
            from wblbm.utils.io import SimulationIO
            from wblbm.utils.profiler import JAXProfiler
            from wblbm.operators.boundary_condition.boundary_condition import BoundaryCondition
            
            
            class Run:
                """
                Main class to configure and run lattice Boltzmann simulations.
                """
            
                def __init__(
                        self,
                        grid_shape: tuple,
                        lattice_type: str = "D2Q9",
                        tau: float = 1.0,
                        nt: int = 1000,
                        multiphase: bool = False,
                        kappa: float = 0.1,
                        rho_l: float = 1.0,
                        rho_v: float = 0.1,
                        interface_width: int = 4,
                        save_interval: int = 100,
                        results_dir: str = "results",
                        bc_config: dict = None,
                        force_enabled: bool = False,
                        force_obj=None  # New parameter for force object
                ):
                    self.grid_shape = grid_shape
                    self.nt = nt
                    self.multiphase = multiphase
                    self.save_interval = save_interval
            
                    # Store multiphase params
                    self.rho_l = rho_l
                    self.rho_v = rho_v
                    self.interface_width = interface_width if multiphase else None
                    self.force_enabled = force_enabled
                    self.force_obj = force_obj
            
                    # Initialize core components
                    self.grid = Grid(grid_shape)
                    self.lattice = Lattice(lattice_type)
                    self.initialiser = Initialise(self.grid, self.lattice)
            
                    # Boundary condition handler
                    self.boundary_condition = None
                    if bc_config is not None:
                        self.boundary_condition = BoundaryCondition(self.grid, self.lattice, bc_config)
            
                    # Select the appropriate update and macroscopic operators
                    if multiphase:
                        from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
                        self.update = UpdateMultiphase(
                            self.grid, self.lattice, tau, kappa, interface_width, rho_l, rho_v, bc_config=bc_config, force_enabled=force_enabled
                        )
                        self.macroscopic_multiphase = MacroscopicMultiphase(self.grid, self.lattice, kappa, interface_width, rho_l, rho_v)
                    else:
                        from wblbm.operators.macroscopic.macroscopic import Macroscopic
                        self.update = Update(self.grid, self.lattice, tau, bc_config=bc_config, force_enabled=force_enabled)
                        self.macroscopic = Macroscopic(self.grid, self.lattice, force_enabled=force_enabled)
            
                    # Prepare config dictionary for the IO handler
                    self.config = {
                        'grid_shape': grid_shape,
                        'lattice_type': lattice_type,
                        'tau': tau,
                        'nt': nt,
                        'multiphase': multiphase,
                        'save_interval': save_interval,
                        'kappa': kappa if multiphase else None,
                        'beta': self.update.macroscopic.beta if multiphase else None,
                        'rho_l': rho_l if multiphase else None,
                        'rho_v': rho_v if multiphase else None,
                        'interface_width': self.interface_width,
                        'bc_config': bc_config,
                        'force_enabled': force_enabled,
                        'force_obj': str(type(force_obj)) if force_obj is not None else None
                    }
                    self.io_handler = SimulationIO(base_dir=results_dir, config=self.config)
            
                def run(self, init_type: str = 'standard', verbose: bool = True):
                    """
                    Main function to run the LBM simulation.
            
                    Args:
                        init_type (str): Type of initialisation ('standard' or 'multiphase_bubble').
                        verbose (bool): Whether to print progress updates to the console.
                    """
                    # Initialize the population distribution based on the simulation type
                    if self.multiphase and init_type == 'multiphase_droplet':
                        f_prev = self.initialiser.initialise_multiphase_droplet(self.rho_l, self.rho_v, self.interface_width)
                    elif self.multiphase and init_type == 'multiphase_bubble':
                        f_prev = self.initialiser.initialise_multiphase_bubble(self.rho_l, self.rho_v, self.interface_width)
                    else:
                        f_prev = self.initialiser.initialise_standard()
            
                    if verbose:
                        print(f"Starting LBM simulation with {self.nt} time steps...")
                        print(f"Config -> Grid: {self.grid_shape}, Multiphase: {self.multiphase}")
            
                    # Main simulation loop
                    for it in range(self.nt):
                        force = None
                        if self.force_enabled and self.force_obj is not None:
                            # Compute force using the force object (optionally pass rho if needed)
                            if self.multiphase:
                                rho, _, _ = self.macroscopic_multiphase(f_prev)
                            else:
                                rho, _ = self.macroscopic(f_prev)
                            force = self.force_obj.compute_force(rho)
                        elif self.force_enabled:
                            force = jnp.ones((self.grid.nx, self.grid.ny, 1, 2)) * jnp.array([0.01, 0.0])
                        f_next = self.update(f_prev, force=force) if self.force_enabled else self.update(f_prev)
                        # Apply boundary conditions if present
                        if self.boundary_condition is not None:
                            f_next = self.boundary_condition(f_next, f_next)
                        f_prev = f_next
            
                        # Save data at the specified interval
                        if it % self.save_interval == 0 or it == self.nt - 1:
                            if self.multiphase:
                                rho, u, force = self.macroscopic_multiphase(f_prev)
                                data_to_save = {
                                    'rho': np.array(rho), 'u': np.array(u), 'force': np.array(force)
                                }
                            else:
                                rho, u = self.macroscopic(f_prev)
                                data_to_save = {'rho': np.array(rho), 'u': np.array(u)}
            
                            self.io_handler.save_data_step(it, data_to_save)
            
                            if verbose:
                                avg_rho = np.mean(rho)
                                max_u = np.max(np.sqrt(u[..., 0] ** 2 + u[..., 1] ** 2))
                                print(f"Step {it}/{self.nt}: avg_rho={avg_rho:.4f}, max_u={max_u:.6f}")
            
                    if verbose:
                        print("Simulation completed!")
                        print(f"Results saved in: {self.io_handler.run_dir}")
            
                def run_with_profiling(self, init_type: str = 'standard', verbose: bool = True, profile_steps: int = 100):
                    """
                    Run simulation with JAX profiling enabled for a subset of steps.
            
                    Args:
                        profile_steps (int): Number of steps to profile (should be small, e.g., 100-1000)
                    """
                    # Initialize as normal
                    if self.multiphase and init_type == 'multiphase_bubble':
                        f_prev = self.initialiser.initialise_multiphase_bubble(self.rho_l, self.rho_v, self.interface_width)
                    else:
                        f_prev = self.initialiser.initialise_standard()
            
                    if verbose:
                        print(f"Starting LBM simulation with profiling for {profile_steps} steps...")
            
                    # Warm up JAX compilation first (shorter warmup)
                    for it in range(5):
                        force = None
                        if self.force_enabled and self.force_obj is not None:
                            if self.multiphase:
                                rho, _, _ = self.macroscopic_multiphase(f_prev)
                            else:
                                rho, _ = self.macroscopic(f_prev)
                            force = self.force_obj.compute_force(rho)
                        elif self.force_enabled:
                            force = jnp.ones((self.grid.nx, self.grid.ny, 1, 2)) * jnp.array([0.01, 0.0])
                        f_next = self.update(f_prev, force=force) if self.force_enabled else self.update(f_prev)
                        if self.boundary_condition is not None:
                            f_next = self.boundary_condition(f_next, f_next)
                        f_prev = f_next
            
                    # Profile the actual operations
                    with JAXProfiler("./profiler_output"):
                        for it in range(profile_steps):
                            force = None
                            if self.force_enabled and self.force_obj is not None:
                                if self.multiphase:
                                    rho, _, _ = self.macroscopic_multiphase(f_prev)
                                else:
                                    rho, _ = self.macroscopic(f_prev)
                                force = self.force_obj.compute_force(rho)
                            elif self.force_enabled:
                                force = jnp.ones((self.grid.nx, self.grid.ny, 1, 2)) * jnp.array([0.01, 0.0])
                            f_next = self.update(f_prev, force=force) if self.force_enabled else self.update(f_prev)
                            if self.boundary_condition is not None:
                                f_next = self.boundary_condition(f_next, f_next)
                            f_prev = f_next
                            # Ensure computation completes before continuing
                            if hasattr(f_next, 'block_until_ready'):
                                f_next.block_until_ready()
            
                            if verbose and it % 10 == 0:
                                print(f"Profiling step {it}/{profile_steps}")
            
                    print("Profiling completed! Check ./profiler_output directory")            --- End of run.py ---

            __init__.py
            --- Code in __init__.py ---
            from .run import Run
            --- End of __init__.py ---

            __pycache__/
                run.cpython-312.pyc
                __init__.cpython-312.pyc
        collision/
            collision_multiphase.py
            --- Code in collision_multiphase.py ---
            import jax.numpy as jnp
            
            from wblbm.grid import Grid
            from wblbm.lattice import Lattice
            from wblbm.operators.collision import Collision
            from wblbm.operators.macroscopic.macroscopic_multiphase import MacroscopicMultiphase
            
            
            class CollisionMultiphase(Collision):
                def __init__(self, grid: Grid, lattice: Lattice, tau: float) -> None:
                    super().__init__(grid, lattice, tau)
            
                def __call__(self, f: jnp.ndarray, feq: jnp.ndarray, source: jnp.ndarray = None) -> jnp.ndarray:
                    result = super().__call__(f, feq)
                    if source is not None:
                        result += (1 - (1 / (2 * self.tau))) * source
                    return result
            --- End of collision_multiphase.py ---

            __init__.py
            --- Code in __init__.py ---
            from .collision import Collision
            from .source import SourceTerm            --- End of __init__.py ---

            collision.py
            --- Code in collision.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            
            
            class Collision:
                """
                Callable class to perform the collision step of the LBM.
                Implements the BGK collision operators with source terms.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice, tau: float) -> None:
                    """
                    Initialize the Collision operators.
            
                    Args:
                        grid (Grid): Grid object containing simulation domain information
                        lattice (Lattice): Lattice object containing lattice properties
                        tau (float): Relaxation time parameter
                    """
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.tau: float = tau
            
                def __call__(self, f: jnp.ndarray, feq: jnp.ndarray) -> jnp.ndarray:
                    """
                    Perform the collision step of the LBM.
            
                    Args:
                        f (jnp.ndarray): Distribution function.
                        feq (jnp.ndarray): Equilibrium distribution function.
            
                    Returns:
                        jnp.ndarray: Post-collision distribution function.
                    """
                    return (1 - (1 / self.tau)) * f + (1 / self.tau) * feq
            --- End of collision.py ---

            source.py
            --- Code in source.py ---
            import jax.numpy as jnp
            from wblbm.grid.grid import Grid
            from wblbm.lattice.lattice import Lattice
            from wblbm.operators.differential.gradient import Gradient
            
            
            class SourceTerm:
                """
                Callable class to calculate the source term for the LBM equation.
                """
            
                def __init__(self, grid: Grid, lattice: Lattice):
                    self.nx: int = grid.nx
                    self.ny: int = grid.ny
                    self.q: int = lattice.q
                    self.d: int = lattice.d
                    self.w = lattice.w
                    self.cx = lattice.c[0]
                    self.cy = lattice.c[1]
                    self.gradient = Gradient(lattice)
            
                def __call__(self, rho: jnp.ndarray, u: jnp.ndarray, force: jnp.ndarray) -> jnp.ndarray:
                    """
                    Calculate the source term for the LBM equation.
            
                    Args:
                        rho (jnp.ndarray): Density field, shape (nx, ny, 1, 1)
                        u (jnp.ndarray): Velocity field, shape (nx, ny, 1, 2)
                        force (jnp.ndarray): Force field, shape (nx, ny, 1, 2)
            
                    Returns:
                        jnp.ndarray: Source term, shape (nx, ny, q, 1)
                    """
                    nx, ny, q = self.nx, self.ny, self.q
                    w = self.w
                    c = (self.cx, self.cy)
                    d = self.d
                    gradient = self.gradient
            
                    # Extract 2D data from 4D arrays
                    u_2d = u[:, :, 0, :]  # Shape: (nx, ny, 2)
                    force_2d = force[:, :, 0, :]  # Shape: (nx, ny, 2)
                    rho_2d = rho[:, :, 0, 0]  # Shape: (nx, ny)
            
                    # Calculate gradient of rho
                    grad_rho = gradient(rho)  # Shape: (nx, ny, 1, 2)
                    grad_rho_2d = grad_rho[:, :, 0, :]  # Shape: (nx, ny, 2)
            
                    def source_term(u_2d_, force_2d_, grad_rho_2d_):
                        cx, cy = c[0], c[1]
                        fx, fy = force_2d_[:, :, 0], force_2d_[:, :, 1]
                        ux, uy = u_2d_[:, :, 0], u_2d_[:, :, 1]
                        grad_rho_x, grad_rho_y = grad_rho_2d_[:, :, 0], grad_rho_2d_[:, :, 1]
            
                        fx_cor = fx + (grad_rho_x / 3)
                        fy_cor = fy + (grad_rho_y / 3)
                        source_ = jnp.zeros((nx, ny, q))
            
                        for i in range(q):
                            source_ = source_.at[:, :, i].set(w[i] * (
                                    3 * (cx[i] * fx + cy[i] * fy) +
                                    9 * (cx[i] * fx_cor + cy[i] * fy_cor) * (cx[i] * ux + cy[i] * uy) -
                                    3 * (ux * fx_cor + uy * fy_cor) +
                                    0.5 * (3 * (cx[i] * cx[i] + cy[i] * cy[i]) - d) * (
                                            ux * grad_rho_x + uy * grad_rho_y)
                            ))
            
                        return source_
            
                    source_2d = source_term(u_2d, force_2d, grad_rho_2d)
            
                    # Convert to 4D format: (nx, ny, q, 1)
                    source_4d = jnp.expand_dims(source_2d, axis=-1)
            
                    return source_4d
            --- End of source.py ---

            __pycache__/
                collision.cpython-312.pyc
                collision_multiphase.cpython-312.pyc
                source.cpython-312.pyc
                __init__.cpython-312.pyc
    utils/
        plotting.py
        --- Code in plotting.py ---
        import os
        import numpy as np
        import matplotlib.pyplot as plt
        
        
        def visualise(sim_instance, title="LBM Simulation Results"):
            """
            Visualizes simulation results by loading and plotting every saved timestep.
            This version includes a vector plot overlay on the velocity magnitude heatmap.
        
            Args:
                sim_instance: The completed simulation instance from the Run class.
                title (str): The base title for the plots.
            """
            try:
                # Get the directory where data files are stored
                data_dir = sim_instance.io_handler.data_dir
        
                # Create a new directory within the run to store the plots
                plot_dir = os.path.join(sim_instance.io_handler.run_dir, "plots")
                os.makedirs(plot_dir, exist_ok=True)
                print(f"Saving plots to: {plot_dir}")
        
                # Get all data files and sort them by timestep
                files = [f for f in os.listdir(data_dir) if f.endswith('.npz')]
                if not files:
                    print("No data files found to visualize.")
                    return
        
                # Sort files based on the iteration number in the filename
                files.sort(key=lambda f: int(f.split('_')[-1].split('.')[0]))
        
                # Loop through each timestep file and generate a plot
                for filename in files:
                    file_path = os.path.join(data_dir, filename)
                    timestep = int(filename.split('_')[-1].split('.')[0])
        
                    data = np.load(file_path)
                    final_rho = data['rho']
                    final_u = data['u']
                    final_force = data.get('force', None)
        
                    fig, axes = plt.subplots(1, 2 if final_force is None else 3, figsize=(12 if final_force is None else 18, 5))
        
                    # Plot density
                    im1 = axes[0].imshow(final_rho[:, :, 0, 0].T, origin='lower', cmap='viridis')
                    axes[0].set_title(f'Density (t={timestep})')
                    plt.colorbar(im1, ax=axes[0], label="Density")
        
                    # --- Velocity Plotting with Vector Overlay ---
        
                    # 1. Plot velocity magnitude heatmap
                    vel_mag = np.sqrt(final_u[:, :, 0, 0] ** 2 + final_u[:, :, 0, 1] ** 2)
                    im2 = axes[1].imshow(vel_mag.T, origin='lower', cmap='plasma')
                    axes[1].set_title('Velocity Magnitude & Vectors')
                    plt.colorbar(im2, ax=axes[1], label="Velocity Magnitude")
        
                    # 2. Overlay velocity vector plot (quiver)
                    nx, ny = final_u.shape[0], final_u.shape[1]
                    x = np.arange(0, nx)
                    y = np.arange(0, ny)
                    X, Y = np.meshgrid(x, y)
        
                    # Extract velocity components
                    U = final_u[:, :, 0, 0]
                    V = final_u[:, :, 0, 1]
        
                    # Downsample the vectors to avoid a cluttered plot
                    # Plot one vector every `skip` grid points
                    skip = 10
        
                    # Plotting quiver requires transposing U and V to match the meshgrid and imshow orientation
                    axes[1].quiver(X[::skip, ::skip], Y[::skip, ::skip], U.T[::skip, ::skip], V.T[::skip, ::skip],
                                   color='white', scale=None, scale_units='xy', angles='xy')
        
                    # --- End of Velocity Plotting Section ---
        
                    if final_force is not None:
                        # Plot force magnitude and vectors
                        force_mag = np.sqrt(final_force[:, :, 0, 0] ** 2 + final_force[:, :, 0, 1] ** 2)
                        im3 = axes[2].imshow(force_mag.T, origin='lower', cmap='cividis')
                        axes[2].set_title('Force Magnitude & Vectors')
                        plt.colorbar(im3, ax=axes[2], label="Force Magnitude")
                        U_force = final_force[:, :, 0, 0]
                        V_force = final_force[:, :, 0, 1]
                        axes[2].quiver(X[::skip, ::skip], Y[::skip, ::skip], U_force.T[::skip, ::skip], V_force.T[::skip, ::skip],
                                       color='white', scale=None, scale_units='xy', angles='xy')
        
                    for ax in axes:
                        ax.set_xlabel('x')
                        ax.set_ylabel('y')
        
                    plt.suptitle(f"{title} - Timestep {timestep}")
                    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        
                    # Save the figure to the plots directory
                    plot_filename = os.path.join(plot_dir, f"timestep_{timestep}.png")
                    plt.savefig(plot_filename)
                    plt.close(fig)  # Close the figure to free up memory
        
                print(f"Finished generating plots for all {len(files)} timesteps.")
        
            except ImportError:
                print("Matplotlib not found. Please install it to visualize results.")
            except Exception as e:
                print(f"An error occurred during visualization: {e}")
        --- End of plotting.py ---

        io.py
        --- Code in io.py ---
        import os
        import json
        import numpy as np
        from datetime import datetime
        from typing import Dict
        
        class SimulationIO:
            """
            Handles all I/O operations for the simulation, including logging and saving results.
            """
            def __init__(self, base_dir: str = "results", config: Dict = None):
                """
                Initializes the IO handler.
        
                Args:
                    base_dir (str): The base directory to store simulation results.
                    config (Dict, optional): A dictionary containing the simulation configuration to save.
                """
                self.base_dir = base_dir
                self.run_dir = self._create_timestamped_directory()
                self.data_dir = os.path.join(self.run_dir, "data")
                os.makedirs(self.data_dir, exist_ok=True)
        
                if config:
                    self.save_config(config)
        
            def _create_timestamped_directory(self) -> str:
                """Creates a unique, timestamped directory for a single simulation run."""
                timestamp = datetime.now().strftime("%Y-%m-%d/%H-%M-%S")
                run_dir = os.path.join(self.base_dir, timestamp)
                os.makedirs(run_dir, exist_ok=True)
                print(f"Created results directory: {run_dir}")
                return run_dir
        
            def save_config(self, config: Dict):
                """Saves the simulation configuration to a JSON file."""
                config_path = os.path.join(self.run_dir, "config.json")
                
                # Rename boundary condition details if present (avoids duplication)
                if 'bc_config' in config:
                    config['boundary_conditions'] = config.pop('bc_config')  # Rename without copying
                
                with open(config_path, 'w') as f:
                    json.dump(config, f, indent=4)
                print(f"Configuration saved to {config_path}")
        
            def save_data_step(self, iteration: int, data: Dict[str, np.ndarray]):
                """Saves the data for a single timestep to a compressed .npz file."""
                filename = os.path.join(self.data_dir, f"timestep_{iteration}.npz")
                np.savez(filename, **data)
        --- End of io.py ---

        __init__.py
        --- Code in __init__.py ---
        --- End of __init__.py ---

        timing.py
        --- Code in timing.py ---
        import time
        from functools import wraps
        import jax.numpy as jnp
        
        TIMING_ENABLED = False  # Default: no timing print; set to True to enable
        
        
        def time_function(enable_timing=TIMING_ENABLED):
            def decorator(func):
                @wraps(func)
                def wrapper(*args, **kwargs):
                    if not enable_timing:
                        return func(*args, **kwargs)
                    start = time.perf_counter()
                    result = func(*args, **kwargs)
                    # Block until computation completes (important for JAX)
                    if hasattr(result, 'block_until_ready'):
                        result.block_until_ready()
                    elif isinstance(result, tuple):
                        # Handle multiple return values
                        for item in result:
                            if hasattr(item, 'block_until_ready'):
                                item.block_until_ready()
                    end = time.perf_counter()
                    print(f"{func.__name__}: {end - start:.4f} seconds")
                    return result
        
                return wrapper
        
            return decorator
        --- End of timing.py ---

        profiler.py
        --- Code in profiler.py ---
        import jax
        from jax import profiler
        import os
        
        
        class JAXProfiler:
            def __init__(self, output_dir="./profiler_output", create_perfetto_link=True):
                self.output_dir = output_dir
                self.create_perfetto_link = create_perfetto_link
                os.makedirs(output_dir, exist_ok=True)
        
            def __enter__(self):
                # Configure profiler options for better traces
                options = jax.profiler.ProfileOptions()
                options.host_tracer_level = 2  # Include high-level program execution details
                options.python_tracer_level = 1  # Enable Python tracing
        
                profiler.start_trace(self.output_dir, profiler_options=options)
                return self
        
            def __exit__(self, exc_type, exc_val, exc_tb):
                profiler.stop_trace()
                if self.create_perfetto_link:
                    print(f"Profiling completed! Trace saved to: {self.output_dir}")
                    print("To view the trace, you can:")
                    print("1. Use TensorBoard: tensorboard --logdir=" + self.output_dir)
                    print("2. Or upload the .pb files to https://ui.perfetto.dev/")
        --- End of profiler.py ---

        __pycache__/
            io.cpython-312.pyc
            profiler.cpython-312.pyc
            timing.cpython-312.pyc
            __init__.cpython-312.pyc
            plotting.cpython-312.pyc
    __pycache__/
        __init__.cpython-312.pyc
    lattice/
        __init__.py
        --- Code in __init__.py ---
        from .lattice import Lattice
        --- End of __init__.py ---

        lattice.py
        --- Code in lattice.py ---
        import numpy as np
        import re
        from numpy import ndarray
        from typing import Any
        
        
        class Lattice(object):
        
            def __init__(self, name: str) -> None:
                self.name: str = name
                dq = re.findall(r'\d+', name)
                self.d: int = int(dq[0])
                self.q: int = int(dq[1])
        
                # Construct the properties of a lattice
                self.c: ndarray = self.construct_lattice_velocities
                self.w: ndarray = self.construct_lattice_weigths
                self.opp_indices: ndarray = self.construct_opposite_indices
                self.main_indices: ndarray = self.construct_main_indices
                self.right_indices: ndarray = self.construct_right_indices
                self.left_indices: ndarray = self.construct_left_indices
                self.top_indices: ndarray = self.construct_top_indices
                self.bottom_indices: ndarray = self.construct_bottom_indices
                if self.d == 3:
                    self.front_indices: ndarray = self.construct_front_indices
                    self.back_indices: ndarray = self.construct_back_indices
        
            @property
            def construct_lattice_velocities(self) -> ndarray:
                if self.name == "D2Q9":
                    cx = [0, 1, 0, -1, 0, 1, -1, -1, 1]
                    cy = [0, 0, 1, 0, -1, 1, 1, -1, -1]
                    c = np.array(tuple(zip(cx, cy)))
                else:
                    raise ValueError("Lattice not supported, D2Q9 is currently the only supported lattice.")
        
                return c.T
        
            @property
            def construct_lattice_weigths(self) -> ndarray:
                if self.name == "D2Q9":
                    w = np.array([4 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 36, 1 / 36, 1 / 36, 1 / 36])
                elif self.name == "D3Q15":
                    raise NotImplementedError("Dimension larger than 2 not supported.")
                else:
                    raise ValueError("Lattice not supported, D2Q9 is currently the only supported lattice.")
        
                return w
        
            @property
            def construct_opposite_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.array([c.tolist().index((-c[i]).tolist()) for i in range(self.q)])
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_main_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero((np.abs(c[:, 0]) + np.abs(c[:, 1]) == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_right_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 0] == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_left_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 0] == -1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_top_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 1] == 1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_bottom_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    return np.nonzero(np.array(c[:, 1] == -1))[0]
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_front_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    raise ValueError("Only have front indices in 3D.")
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        
            @property
            def construct_back_indices(self) -> ndarray:
                c = self.c.T
                if self.d == 2:
                    raise ValueError("Only have front indices in 3D.")
                if self.d == 3:
                    raise NotImplementedError("Dimension larger than 2 not supported.")
        --- End of lattice.py ---

        __pycache__/
            lattice.cpython-312.pyc
            __init__.cpython-312.pyc
    force/
        force.py
        --- Code in force.py ---
        from abc import ABC, abstractmethod
        import jax.numpy as jnp
        
        
        class Force(ABC):
            """
            Abstract base class for forces in the simulation.
            Holds a force array of shape (nx, ny, 1, d).
            """
        
            def __init__(self, force_array: jnp.ndarray):
                if force_array.ndim != 4 or force_array.shape[2] != 1:
                    raise ValueError("Force array must have shape (nx, ny, 1, d)")
                self.force = force_array
        
            @abstractmethod
            def compute_force(self, rho: jnp.ndarray) -> jnp.ndarray:
                """
                Compute the force field based on the density field rho.
                Must return an array of shape (nx, ny, 1, d).
                """
                pass
        --- End of force.py ---

        __init__.py
        --- Code in __init__.py ---
        --- End of __init__.py ---

        gravitational_force.py
        --- Code in gravitational_force.py ---
        import jax.numpy as jnp
        from wblbm.force.force import Force
        
        class GravityForce(Force):
            """
            Subclass for gravitational force, constant across the grid.
            """
            def __init__(self, nx: int, ny: int, d: int, force_g: float, inclination_angle_deg: float):
                if d != 2:
                    raise ValueError("Currently supports 2D (d=2) only")
        
                force_x = force_g * jnp.sin(jnp.deg2rad(inclination_angle_deg))
                force_y = force_g * -jnp.cos(jnp.deg2rad(inclination_angle_deg))
        
                force_array = jnp.zeros((nx, ny, 1, d))
                force_array = force_array.at[:, :, 0, 0].set(force_x)
                force_array = force_array.at[:, :, 0, 1].set(force_y)
        
                super().__init__(force_array)
        
            def compute_force(self, rho: jnp.ndarray) -> jnp.ndarray:
                """
                Returns the constant gravitational force field.
                Ignores rho as gravity is density-independent.
                """
                return self.force
        
        --- End of gravitational_force.py ---

    grid/
        grid.py
        --- Code in grid.py ---
        from typing import Tuple
        
        import numpy as np
        
        
        class Grid(object):
            def __init__(self, shape: Tuple[int, ...]):
                self.shape = shape
                self.dim = len(self.shape)
                if self.dim == 2:
                    self.nx, self.ny = self.shape
                if self.dim == 3:
                    self.nx, self.ny, self.nz = self.shape
        
            def get_edges(self):
                grid = np.indices(self.shape)
                if self.dim == 2:
                    edges = {
                        "left": (grid[0][0, :], grid[1][0, :]),
                        "right": (grid[0][-1, :], grid[1][-1, :]),
                        "bottom": (grid[0][:, 0], grid[1][:, 0]),
                        "top": (grid[0][:, -1], grid[1][:, -1])
                    }
                    return edges
                elif self.dim == 3:
                    edges = {
                        "left": (grid[0][0, :, :], grid[1][0, :, :], grid[2][0, :, :]),
                        "right": (grid[0][-1, :, :], grid[1][-1, :, :], grid[2][-1, :, :]),
                        "bottom": (grid[0][:, 0, :], grid[1][:, 0, :], grid[2][:, 0, :]),
                        "top": (grid[0][:, -1, :], grid[1][:, -1, :], grid[2][:, -1, :]),
                        "front": (grid[0][:, :, 0], grid[1][:, :, 0], grid[2][:, :, 0]),
                        "back": (grid[0][:, :, -1], grid[1][:, :, -1], grid[2][:, :, -1]),
                    }
                    return edges
                else:
                    raise NotImplementedError("Edge extraction for grids with dim != 2 or 3 is not implemented.")
        --- End of grid.py ---

        __init__.py
        --- Code in __init__.py ---
        from .grid import Grid        --- End of __init__.py ---

        __pycache__/
            grid.cpython-312.pyc
            __init__.cpython-312.pyc
example/
    single_phase_gravity_test.py
    --- Code in single_phase_gravity_test.py ---
    from wblbm.operators.run.run import Run
    from wblbm.force.gravitational_force import GravityForce
    from wblbm.utils.plotting import visualise
    
    grid_shape = (200, 200)
    tau = 1.0
    nt = 10000
    save_interval = 2000
    
    force_g = 0.01
    inclination_angle = 45
    gravity = GravityForce(grid_shape[0], grid_shape[1], 2, force_g, inclination_angle)
    
    sim = Run(
        grid_shape=grid_shape,
        lattice_type="D2Q9",
        tau=tau,
        nt=nt,
        multiphase=False,
        save_interval=save_interval,
        force_enabled=True,
        force_obj=gravity
    )
    sim.run(init_type='standard', verbose=True)
    
    visualise(sim, "Single-Phase with Gravity Force")
    
    --- End of single_phase_gravity_test.py ---

    test_bc.py
    --- Code in test_bc.py ---
    import numpy as np
    from wblbm.operators.run.run import Run
    from wblbm.utils.plotting import visualise
    
    
    def test_boundary_conditions():
        """
        Test various boundary conditions in the LBM simulation.
    
        This function configures a small multiphase simulation with custom boundary conditions,
        runs it for a limited number of steps, and visualizes the results to verify BC behavior.
        """
        print("\n=== Testing LBM Boundary Conditions ===")
    
        # Define boundary configuration
        bc_config = {
            'top': 'bounce-back',  # No-slip wall at top
            'bottom': 'bounce-back',  # Symmetric boundary at bottom
            'left': 'bounce-back',  # Periodic left-right wrapping
            'right': 'bounce-back'
        }
    
        # Set up the simulation
        sim = Run(
            grid_shape=(200, 200),  # Small grid for quick testing
            lattice_type="D2Q9",
            tau=0.8,
            nt=10000,  # Short run to observe BC effects
            multiphase=True,
            kappa=0.01,
            rho_l=1.0,
            rho_v=0.1,
            interface_width=5,
            save_interval=2000,
            bc_config=bc_config  # Apply custom BCs
        )
    
        # Run the simulation with a droplet initialization to test interactions with boundaries
        sim.run(init_type='multiphase_bubble', verbose=True)
    
        # Visualize results
        print("\n=== Visualizing Boundary Condition Effects ===")
        visualise(sim, "LBM Boundary Condition Test")
    
        print("\nTest completed! Check the 'results' directory for saved data and plots.")
    
    
    if __name__ == "__main__":
        test_boundary_conditions()
    --- End of test_bc.py ---

    timing_analysis.py
    --- Code in timing_analysis.py ---
    import time
    import numpy as np
    from wblbm.operators.run.run import Run
    from wblbm.utils.timing import time_function, TIMING_ENABLED
    
    
    def detailed_timing_analysis():
        """Run a small simulation with detailed timing for each component."""
    
        print("=== Detailed Timing Analysis ===")
    
        # Use a moderate grid size for meaningful timing
        sim = Run(
            grid_shape=(1000, 1000),
            lattice_type="D2Q9",
            tau=1.0,
            nt=100,  # Fewer steps for timing analysis
            multiphase=True,
            kappa=0.01,
            rho_l=1.0,
            rho_v=0.1,
            interface_width=4,
            save_interval=50,
            bc_config={'top': 'symmetry', 'bottom': 'bounce-back'}  # Example BCs
        )
    
        # Initialize
        f_prev = sim.initialiser.initialise_multiphase_bubble(
            sim.rho_l, sim.rho_v, sim.interface_width
        )
    
        # Warm up JAX compilation
        print("Warming up JAX compilation...")
        for _ in range(5):
            f_next = sim.update(f_prev)
            # Apply boundary conditions if present
            if hasattr(sim, 'boundary_condition') and sim.boundary_condition is not None:
                f_next = sim.boundary_condition(f_next, f_next)
            f_prev = f_next
    
        print("\nStarting detailed timing analysis...")
    
        # Time individual components
        total_times = {
            'macroscopic': [],
            'equilibrium': [],
            'collision': [],
            'streaming': [],
            'total_update': []
        }
    
        for i in range(50):  # Time 50 iterations
            start_total = time.perf_counter()
    
            # Time macroscopic calculation
            start = time.perf_counter()
            rho, u, force = sim.macroscopic_multiphase(f_prev)
            if hasattr(rho, 'block_until_ready'):
                rho.block_until_ready()
            macro_time = time.perf_counter() - start
    
            # Time equilibrium calculation
            start = time.perf_counter()
            feq = sim.update.equilibrium(rho, u)
            if hasattr(feq, 'block_until_ready'):
                feq.block_until_ready()
            eq_time = time.perf_counter() - start
    
            # Time source term
            start = time.perf_counter()
            source = sim.update.source_term(rho, u, force)
            if hasattr(source, 'block_until_ready'):
                source.block_until_ready()
            source_time = time.perf_counter() - start
    
            # Time collision
            start = time.perf_counter()
            fcol = sim.update.collision(f_prev, feq, source)
            if hasattr(fcol, 'block_until_ready'):
                fcol.block_until_ready()
            collision_time = time.perf_counter() - start
    
            # Time streaming
            start = time.perf_counter()
            fstream = sim.update.streaming(fcol)
            if hasattr(fstream, 'block_until_ready'):
                fstream.block_until_ready()
            stream_time = time.perf_counter() - start
    
            # Apply boundary conditions if present
            if hasattr(sim, 'boundary_condition') and sim.boundary_condition is not None:
                fstream = sim.boundary_condition(fstream, fcol)
                if hasattr(fstream, 'block_until_ready'):
                    fstream.block_until_ready()
            total_time = time.perf_counter() - start_total
    
            # Store times
            total_times['macroscopic'].append(macro_time + source_time)  # Include source term
            total_times['equilibrium'].append(eq_time)
            total_times['collision'].append(collision_time)
            total_times['streaming'].append(stream_time)
            total_times['total_update'].append(total_time)
    
            f_prev = fstream
    
            if i % 10 == 0:
                print(f"Completed {i + 1}/50 timing iterations")
    
        # Calculate and display statistics
        print("\n=== Timing Results (milliseconds) ===")
        print(f"{'Component':<15} {'Mean':<8} {'Std':<8} {'Min':<8} {'Max':<8} {'% of Total':<12}")
        print("-" * 70)
    
        total_mean = np.mean(total_times['total_update']) * 1000
    
        for component, times in total_times.items():
            if component != 'total_update':
                times_ms = np.array(times) * 1000
                mean_time = np.mean(times_ms)
                std_time = np.std(times_ms)
                min_time = np.min(times_ms)
                max_time = np.max(times_ms)
                percentage = (mean_time / total_mean) * 100
    
                print(
                    f"{component:<15} {mean_time:<8.3f} {std_time:<8.3f} {min_time:<8.3f} {max_time:<8.3f} {percentage:<12.1f}")
    
        # Total
        times_ms = np.array(total_times['total_update']) * 1000
        mean_time = np.mean(times_ms)
        std_time = np.std(times_ms)
        min_time = np.min(times_ms)
        max_time = np.max(times_ms)
    
        print("-" * 70)
        print(f"{'TOTAL':<15} {mean_time:<8.3f} {std_time:<8.3f} {min_time:<8.3f} {max_time:<8.3f} {'100.0':<12}")
    
    
    if __name__ == "__main__":
        detailed_timing_analysis()
    --- End of timing_analysis.py ---

    complexity_analysis.py
    --- Code in complexity_analysis.py ---
    import time
    import numpy as np
    import matplotlib.pyplot as plt
    from wblbm.operators.run.run import Run
    
    
    def complexity_analysis():
        """Analyze how timing scales with grid size."""
    
        grid_sizes = [(50, 50), (100, 100), (150, 150), (200, 200), (1000, 1000)]
        timing_results = []
    
        for nx, ny in grid_sizes:
            print(f"\nTesting grid size: {nx}x{ny}")
    
            sim = Run(
                grid_shape=(nx, ny),
                lattice_type="D2Q9",
                tau=1.0,
                nt=10,  # Just a few steps for timing
                multiphase=True,
                kappa=0.01,
                rho_l=1.0,
                rho_v=0.1,
                interface_width=4,
                save_interval=10,
                bc_config={'top': 'symmetry', 'bottom': 'bounce-back'}  # Example BCs
            )
    
            f_prev = sim.initialiser.initialise_multiphase_bubble(
                sim.rho_l, sim.rho_v, sim.interface_width
            )
    
            # Warm up
            for _ in range(3):
                f_next = sim.update(f_prev)
                # Apply boundary conditions if present
                if hasattr(sim, 'boundary_condition') and sim.boundary_condition is not None:
                    f_next = sim.boundary_condition(f_next, f_next)
                f_prev = f_next
    
            # Time multiple iterations
            times = []
            for _ in range(10):
                start = time.perf_counter()
                f_next = sim.update(f_prev)
                # Apply boundary conditions if present
                if hasattr(sim, 'boundary_condition') and sim.boundary_condition is not None:
                    f_next = sim.boundary_condition(f_next, f_next)
                if hasattr(f_next, 'block_until_ready'):
                    f_next.block_until_ready()
                end = time.perf_counter()
                times.append(end - start)
                f_prev = f_next
    
            avg_time = np.mean(times) * 1000  # Convert to ms
            grid_points = nx * ny
    
            timing_results.append({
                'grid_size': f"{nx}x{ny}",
                'grid_points': grid_points,
                'avg_time_ms': avg_time,
                'time_per_point_us': (avg_time * 1000) / grid_points
            })
    
            print(f"Average time per iteration: {avg_time:.3f} ms")
            print(f"Time per grid point: {(avg_time * 1000) / grid_points:.3f} s")
    
        # Display results
        print("\n=== Complexity Analysis Results ===")
        print(f"{'Grid Size':<12} {'Points':<10} {'Time (ms)':<12} {'s/point':<12}")
        print("-" * 50)
    
        for result in timing_results:
            print(f"{result['grid_size']:<12} {result['grid_points']:<10} "
                  f"{result['avg_time_ms']:<12.3f} {result['time_per_point_us']:<12.3f}")
    
    
    if __name__ == "__main__":
        complexity_analysis()
    --- End of complexity_analysis.py ---

    test_bubble_profiler.py
    --- Code in test_bubble_profiler.py ---
    from wblbm.operators.run.run import Run
    
    
    def profile_lbm():
        """Profile a small LBM simulation to identify bottlenecks."""
    
        # Use a smaller grid for profiling to focus on computational patterns
        sim = Run(
            grid_shape=(50, 50),  # Smaller grid for profiling
            lattice_type="D2Q9",
            tau=1.0,
            nt=100,  # Only profile 100 steps
            multiphase=True,  # Profile the more complex multiphase case
            kappa=0.01,
            rho_l=1.0,
            rho_v=0.1,
            interface_width=4,
            save_interval=50
        )
    
        # Run with profiling
        sim.run_with_profiling(init_type='multiphase_bubble', profile_steps=100)
    
    
    if __name__ == "__main__":
        profile_lbm()
    --- End of test_bubble_profiler.py ---

    test.py
    --- Code in test.py ---
    import numpy as np
    from wblbm.operators.run.run import Run
    from wblbm.utils.plotting import visualise  # Import the new function
    
    
    def test_basic_simulation():
        """Test a basic single-phase LBM simulation."""
        print("\n=== Basic LBM Simulation Test ===")
        sim = Run(
            grid_shape=(100, 50),
            lattice_type="D2Q9",
            tau=1.0,
            nt=500,
            save_interval=100,
            multiphase=False
        )
        sim.run(init_type='standard', verbose=True)
        return sim
    
    
    def test_multiphase_simulation():
        """Test a multiphase LBM simulation with a central bubble."""
        print("\n=== Multiphase LBM Simulation Test ===")
        sim = Run(
            grid_shape=(400, 400),
            lattice_type="D2Q9",
            tau=0.9,
            nt=500000,
            save_interval=1000,
            multiphase=True,
            kappa=0.01,
            rho_l=1.0,
            rho_v=0.001,
            interface_width=10
        )
        sim.run(init_type='multiphase_droplet', verbose=True)
        return sim
    
    
    if __name__ == "__main__":
        print("Testing LBM Codebase with Refactored IO and Initialization")
        print("=" * 60)
    
        # Run simulations
        sim_basic = test_basic_simulation()
        sim_multiphase = test_multiphase_simulation()
    
        # Visualize results using the new, centralized function
        print("\n=== Visualizing Results ===")
        visualise(sim_basic, "Basic LBM Simulation")
        visualise(sim_multiphase, "Multiphase LBM Simulation")
    
        print("\nAll tests completed!")
    --- End of test.py ---

    bubble_high_density.py
    --- Code in bubble_high_density.py ---
    from wblbm.operators.run.run import Run
    from wblbm.utils.plotting import visualise
    
    
    def test_multiphase_simulation():
        """
        Test a multiphase LBM simulation with a central bubble.
    
        This function sets up and runs a multiphase lattice Boltzmann method (LBM) simulation
        using a high density ratio and a central bubble. The simulation parameters are specified
        for a 2D grid with D2Q9 lattice, and the results are returned for further analysis or visualization.
    
        Returns:
            Run: The simulation object after running the multiphase bubble test.
        """
        print("\n=== Multiphase LBM Simulation Test ===")
        sim = Run(
            grid_shape=(400, 400),
            lattice_type="D2Q9",
            tau=0.9,
            nt=5000,
            save_interval=1000,
            multiphase=True,
            kappa=0.01,
            rho_l=1.0,
            rho_v=0.001,
            interface_width=10
        )
        sim.run(init_type='multiphase_bubble', verbose=True)
        return sim
    
    
    if __name__ == "__main__":
        """
        Main entry point for running and visualizing the high density ratio static bubble simulation.
    
        This script runs the multiphase LBM simulation and visualizes the results using the centralized
        plotting function. It prints status messages to indicate progress and completion.
        """
        print("Testing LBM Codebase with high density ratio static bubble simulation.")
        print("=" * 60)
    
        sim_multiphase = test_multiphase_simulation()
    
        # Visualize results using the new, centralized function
        print("\n=== Visualizing Results ===")
        # visualize_all_steps(sim_basic, "Basic LBM Simulation")
        visualise(sim_multiphase, "Multiphase LBM Simulation")
    
        print("\nAll tests completed!")
    --- End of bubble_high_density.py ---

    multiphase_gravity_test.py
    --- Code in multiphase_gravity_test.py ---
    from wblbm.operators.run.run import Run
    from wblbm.force.gravitational_force import GravityForce
    from wblbm.utils.plotting import visualise
    
    grid_shape = (400, 400)
    tau = 0.9
    nt = 50000
    save_interval = 5000
    kappa = 0.01
    rho_l = 1.0
    rho_v = 0.001
    interface_width = 10
    
    force_g = 0.005
    inclination_angle = 30
    gravity = GravityForce(grid_shape[0], grid_shape[1], 2, force_g, inclination_angle)
    
    sim = Run(
        grid_shape=grid_shape,
        lattice_type="D2Q9",
        tau=tau,
        nt=nt,
        multiphase=True,
        kappa=kappa,
        rho_l=rho_l,
        rho_v=rho_v,
        interface_width=interface_width,
        save_interval=save_interval,
        force_enabled=True,
        force_obj=gravity
    )
    sim.run(init_type='multiphase_droplet', verbose=True)
    
    visualise(sim, "Multiphase with Gravity Force")
    
    --- End of multiphase_gravity_test.py ---

    results/
        2025-07-10/
            14-28-58/
                config.json
                data/
                    timestep_120000.npz
                    timestep_397000.npz
                    timestep_297000.npz
                    timestep_31000.npz
                    timestep_52000.npz
                    timestep_143000.npz
                    timestep_389000.npz
                    timestep_289000.npz
                    timestep_285000.npz
                    timestep_385000.npz
                    timestep_132000.npz
                    timestep_7000.npz
                    timestep_23000.npz
                    timestep_40000.npz
                    timestep_151000.npz
                    timestep_68000.npz
                    timestep_179000.npz
                    timestep_15000.npz
                    timestep_104000.npz
                    timestep_481000.npz
                    timestep_167000.npz
                    timestep_76000.npz
                    timestep_116000.npz
                    timestep_175000.npz
                    timestep_493000.npz
                    timestep_64000.npz
                    timestep_108000.npz
                    timestep_19000.npz
                    timestep_439000.npz
                    timestep_368000.npz
                    timestep_268000.npz
                    timestep_444000.npz
                    timestep_315000.npz
                    timestep_215000.npz
                    timestep_427000.npz
                    timestep_376000.npz
                    timestep_276000.npz
                    timestep_207000.npz
                    timestep_307000.npz
                    timestep_456000.npz
                    timestep_264000.npz
                    timestep_364000.npz
                    timestep_435000.npz
                    timestep_219000.npz
                    timestep_319000.npz
                    timestep_448000.npz
                    timestep_97000.npz
                    timestep_231000.npz
                    timestep_460000.npz
                    timestep_331000.npz
                    timestep_186000.npz
                    timestep_252000.npz
                    timestep_403000.npz
                    timestep_352000.npz
                    timestep_198000.npz
                    timestep_89000.npz
                    timestep_85000.npz
                    timestep_194000.npz
                    timestep_323000.npz
                    timestep_472000.npz
                    timestep_223000.npz
                    timestep_340000.npz
                    timestep_411000.npz
                    timestep_240000.npz
                    timestep_266000.npz
                    timestep_366000.npz
                    timestep_437000.npz
                    timestep_278000.npz
                    timestep_378000.npz
                    timestep_429000.npz
                    timestep_205000.npz
                    timestep_305000.npz
                    timestep_454000.npz
                    timestep_425000.npz
                    timestep_374000.npz
                    timestep_274000.npz
                    timestep_458000.npz
                    timestep_309000.npz
                    timestep_209000.npz
                    timestep_446000.npz
                    timestep_317000.npz
                    timestep_217000.npz
                    timestep_342000.npz
                    timestep_413000.npz
                    timestep_242000.npz
                    timestep_99000.npz
                    timestep_188000.npz
                    timestep_196000.npz
                    timestep_321000.npz
                    timestep_470000.npz
                    timestep_221000.npz
                    timestep_87000.npz
                    timestep_250000.npz
                    timestep_401000.npz
                    timestep_350000.npz
                    timestep_233000.npz
                    timestep_462000.npz
                    timestep_333000.npz
                    timestep_184000.npz
                    timestep_95000.npz
                    timestep_153000.npz
                    timestep_42000.npz
                    timestep_299000.npz
                    timestep_399000.npz
                    timestep_5000.npz
                    timestep_21000.npz
                    timestep_287000.npz
                    timestep_387000.npz
                    timestep_130000.npz
                    timestep_141000.npz
                    timestep_50000.npz
                    timestep_9000.npz
                    timestep_33000.npz
                    timestep_122000.npz
                    timestep_395000.npz
                    timestep_295000.npz
                    timestep_66000.npz
                    timestep_177000.npz
                    timestep_491000.npz
                    timestep_169000.npz
                    timestep_78000.npz
                    timestep_114000.npz
                    timestep_74000.npz
                    timestep_483000.npz
                    timestep_165000.npz
                    timestep_118000.npz
                    timestep_106000.npz
                    timestep_17000.npz
                    timestep_229000.npz
                    timestep_329000.npz
                    timestep_478000.npz
                    timestep_254000.npz
                    timestep_354000.npz
                    timestep_405000.npz
                    timestep_237000.npz
                    timestep_337000.npz
                    timestep_466000.npz
                    timestep_180000.npz
                    timestep_91000.npz
                    timestep_417000.npz
                    timestep_346000.npz
                    timestep_246000.npz
                    timestep_192000.npz
                    timestep_474000.npz
                    timestep_325000.npz
                    timestep_225000.npz
                    timestep_83000.npz
                    timestep_409000.npz
                    timestep_358000.npz
                    timestep_258000.npz
                    timestep_370000.npz
                    timestep_421000.npz
                    timestep_270000.npz
                    timestep_313000.npz
                    timestep_442000.npz
                    timestep_213000.npz
                    timestep_262000.npz
                    timestep_433000.npz
                    timestep_362000.npz
                    timestep_201000.npz
                    timestep_450000.npz
                    timestep_301000.npz
                    timestep_70000.npz
                    timestep_487000.npz
                    timestep_161000.npz
                    timestep_102000.npz
                    timestep_13000.npz
                    timestep_499000.npz
                    timestep_62000.npz
                    timestep_173000.npz
                    timestep_495000.npz
                    timestep_110000.npz
                    timestep_138000.npz
                    timestep_29000.npz
                    timestep_145000.npz
                    timestep_54000.npz
                    timestep_37000.npz
                    timestep_126000.npz
                    timestep_391000.npz
                    timestep_291000.npz
                    timestep_157000.npz
                    timestep_46000.npz
                    timestep_1000.npz
                    timestep_25000.npz
                    timestep_283000.npz
                    timestep_383000.npz
                    timestep_134000.npz
                    timestep_58000.npz
                    timestep_149000.npz
                    timestep_112000.npz
                    timestep_489000.npz
                    timestep_171000.npz
                    timestep_497000.npz
                    timestep_60000.npz
                    timestep_11000.npz
                    timestep_100000.npz
                    timestep_485000.npz
                    timestep_163000.npz
                    timestep_72000.npz
                    timestep_281000.npz
                    timestep_381000.npz
                    timestep_136000.npz
                    timestep_3000.npz
                    timestep_27000.npz
                    timestep_39000.npz
                    timestep_128000.npz
                    timestep_44000.npz
                    timestep_155000.npz
                    timestep_124000.npz
                    timestep_393000.npz
                    timestep_293000.npz
                    timestep_35000.npz
                    timestep_159000.npz
                    timestep_48000.npz
                    timestep_56000.npz
                    timestep_147000.npz
                    timestep_81000.npz
                    timestep_190000.npz
                    timestep_476000.npz
                    timestep_327000.npz
                    timestep_227000.npz
                    timestep_468000.npz
                    timestep_339000.npz
                    timestep_239000.npz
                    timestep_415000.npz
                    timestep_344000.npz
                    timestep_244000.npz
                    timestep_93000.npz
                    timestep_235000.npz
                    timestep_335000.npz
                    timestep_464000.npz
                    timestep_182000.npz
                    timestep_248000.npz
                    timestep_348000.npz
                    timestep_419000.npz
                    timestep_256000.npz
                    timestep_356000.npz
                    timestep_407000.npz
                    timestep_203000.npz
                    timestep_452000.npz
                    timestep_303000.npz
                    timestep_260000.npz
                    timestep_431000.npz
                    timestep_360000.npz
                    timestep_311000.npz
                    timestep_440000.npz
                    timestep_211000.npz
                    timestep_372000.npz
                    timestep_423000.npz
                    timestep_272000.npz
                    timestep_199000.npz
                    timestep_88000.npz
                    timestep_402000.npz
                    timestep_353000.npz
                    timestep_253000.npz
                    timestep_96000.npz
                    timestep_461000.npz
                    timestep_330000.npz
                    timestep_187000.npz
                    timestep_230000.npz
                    timestep_241000.npz
                    timestep_341000.npz
                    timestep_410000.npz
                    timestep_84000.npz
                    timestep_0.npz
                    timestep_222000.npz
                    timestep_195000.npz
                    timestep_322000.npz
                    timestep_473000.npz
                    timestep_277000.npz
                    timestep_426000.npz
                    timestep_377000.npz
                    timestep_214000.npz
                    timestep_445000.npz
                    timestep_314000.npz
                    timestep_269000.npz
                    timestep_438000.npz
                    timestep_369000.npz
                    timestep_318000.npz
                    timestep_449000.npz
                    timestep_218000.npz
                    timestep_365000.npz
                    timestep_434000.npz
                    timestep_265000.npz
                    timestep_306000.npz
                    timestep_457000.npz
                    timestep_206000.npz
                    timestep_480000.npz
                    timestep_166000.npz
                    timestep_77000.npz
                    timestep_14000.npz
                    timestep_105000.npz
                    timestep_69000.npz
                    timestep_178000.npz
                    timestep_109000.npz
                    timestep_18000.npz
                    timestep_174000.npz
                    timestep_492000.npz
                    timestep_65000.npz
                    timestep_117000.npz
                    timestep_288000.npz
                    timestep_388000.npz
                    timestep_53000.npz
                    timestep_142000.npz
                    timestep_296000.npz
                    timestep_121000.npz
                    timestep_396000.npz
                    timestep_30000.npz
                    timestep_41000.npz
                    timestep_150000.npz
                    timestep_384000.npz
                    timestep_133000.npz
                    timestep_284000.npz
                    timestep_22000.npz
                    timestep_6000.npz
                    timestep_115000.npz
                    timestep_168000.npz
                    timestep_79000.npz
                    timestep_67000.npz
                    timestep_176000.npz
                    timestep_490000.npz
                    timestep_107000.npz
                    timestep_16000.npz
                    timestep_119000.npz
                    timestep_75000.npz
                    timestep_482000.npz
                    timestep_164000.npz
                    timestep_20000.npz
                    timestep_4000.npz
                    timestep_386000.npz
                    timestep_131000.npz
                    timestep_286000.npz
                    timestep_398000.npz
                    timestep_298000.npz
                    timestep_152000.npz
                    timestep_43000.npz
                    timestep_32000.npz
                    timestep_294000.npz
                    timestep_123000.npz
                    timestep_394000.npz
                    timestep_8000.npz
                    timestep_140000.npz
                    timestep_51000.npz
                    timestep_220000.npz
                    timestep_197000.npz
                    timestep_320000.npz
                    timestep_471000.npz
                    timestep_86000.npz
                    timestep_98000.npz
                    timestep_189000.npz
                    timestep_243000.npz
                    timestep_499999.npz
                    timestep_343000.npz
                    timestep_412000.npz
                    timestep_463000.npz
                    timestep_332000.npz
                    timestep_185000.npz
                    timestep_232000.npz
                    timestep_94000.npz
                    timestep_400000.npz
                    timestep_351000.npz
                    timestep_251000.npz
                    timestep_304000.npz
                    timestep_455000.npz
                    timestep_204000.npz
                    timestep_379000.npz
                    timestep_428000.npz
                    timestep_279000.npz
                    timestep_367000.npz
                    timestep_436000.npz
                    timestep_267000.npz
                    timestep_216000.npz
                    timestep_447000.npz
                    timestep_316000.npz
                    timestep_208000.npz
                    timestep_459000.npz
                    timestep_308000.npz
                    timestep_275000.npz
                    timestep_424000.npz
                    timestep_375000.npz
                    timestep_36000.npz
                    timestep_290000.npz
                    timestep_127000.npz
                    timestep_390000.npz
                    timestep_144000.npz
                    timestep_55000.npz
                    timestep_139000.npz
                    timestep_28000.npz
                    timestep_59000.npz
                    timestep_148000.npz
                    timestep_24000.npz
                    timestep_382000.npz
                    timestep_135000.npz
                    timestep_282000.npz
                    timestep_156000.npz
                    timestep_47000.npz
                    timestep_498000.npz
                    timestep_103000.npz
                    timestep_12000.npz
                    timestep_71000.npz
                    timestep_486000.npz
                    timestep_160000.npz
                    timestep_111000.npz
                    timestep_63000.npz
                    timestep_172000.npz
                    timestep_494000.npz
                    timestep_212000.npz
                    timestep_312000.npz
                    timestep_443000.npz
                    timestep_271000.npz
                    timestep_371000.npz
                    timestep_420000.npz
                    timestep_451000.npz
                    timestep_300000.npz
                    timestep_200000.npz
                    timestep_432000.npz
                    timestep_363000.npz
                    timestep_263000.npz
                    timestep_336000.npz
                    timestep_467000.npz
                    timestep_181000.npz
                    timestep_236000.npz
                    timestep_90000.npz
                    timestep_355000.npz
                    timestep_404000.npz
                    timestep_255000.npz
                    timestep_328000.npz
                    timestep_479000.npz
                    timestep_228000.npz
                    timestep_259000.npz
                    timestep_408000.npz
                    timestep_359000.npz
                    timestep_224000.npz
                    timestep_193000.npz
                    timestep_475000.npz
                    timestep_324000.npz
                    timestep_82000.npz
                    timestep_247000.npz
                    timestep_416000.npz
                    timestep_347000.npz
                    timestep_430000.npz
                    timestep_361000.npz
                    timestep_261000.npz
                    timestep_453000.npz
                    timestep_302000.npz
                    timestep_202000.npz
                    timestep_273000.npz
                    timestep_373000.npz
                    timestep_422000.npz
                    timestep_210000.npz
                    timestep_310000.npz
                    timestep_441000.npz
                    timestep_245000.npz
                    timestep_414000.npz
                    timestep_345000.npz
                    timestep_238000.npz
                    timestep_469000.npz
                    timestep_338000.npz
                    timestep_80000.npz
                    timestep_226000.npz
                    timestep_191000.npz
                    timestep_477000.npz
                    timestep_326000.npz
                    timestep_357000.npz
                    timestep_406000.npz
                    timestep_257000.npz
                    timestep_349000.npz
                    timestep_418000.npz
                    timestep_249000.npz
                    timestep_92000.npz
                    timestep_334000.npz
                    timestep_465000.npz
                    timestep_183000.npz
                    timestep_234000.npz
                    timestep_45000.npz
                    timestep_154000.npz
                    timestep_38000.npz
                    timestep_129000.npz
                    timestep_380000.npz
                    timestep_137000.npz
                    timestep_280000.npz
                    timestep_26000.npz
                    timestep_2000.npz
                    timestep_57000.npz
                    timestep_146000.npz
                    timestep_158000.npz
                    timestep_49000.npz
                    timestep_292000.npz
                    timestep_125000.npz
                    timestep_392000.npz
                    timestep_34000.npz
                    timestep_170000.npz
                    timestep_496000.npz
                    timestep_61000.npz
                    timestep_488000.npz
                    timestep_113000.npz
                    timestep_484000.npz
                    timestep_162000.npz
                    timestep_73000.npz
                    timestep_10000.npz
                    timestep_101000.npz
                plots/
                    timestep_389000.png
                    timestep_289000.png
                    timestep_52000.png
                    timestep_143000.png
                    timestep_397000.png
                    timestep_120000.png
                    timestep_297000.png
                    timestep_31000.png
                    timestep_40000.png
                    timestep_151000.png
                    timestep_285000.png
                    timestep_132000.png
                    timestep_385000.png
                    timestep_7000.png
                    timestep_23000.png
                    timestep_167000.png
                    timestep_481000.png
                    timestep_76000.png
                    timestep_15000.png
                    timestep_104000.png
                    timestep_68000.png
                    timestep_179000.png
                    timestep_108000.png
                    timestep_19000.png
                    timestep_493000.png
                    timestep_175000.png
                    timestep_64000.png
                    timestep_116000.png
                    timestep_376000.png
                    timestep_427000.png
                    timestep_276000.png
                    timestep_315000.png
                    timestep_444000.png
                    timestep_215000.png
                    timestep_368000.png
                    timestep_439000.png
                    timestep_268000.png
                    timestep_219000.png
                    timestep_448000.png
                    timestep_319000.png
                    timestep_264000.png
                    timestep_435000.png
                    timestep_364000.png
                    timestep_207000.png
                    timestep_456000.png
                    timestep_307000.png
                    timestep_198000.png
                    timestep_89000.png
                    timestep_252000.png
                    timestep_352000.png
                    timestep_403000.png
                    timestep_97000.png
                    timestep_231000.png
                    timestep_186000.png
                    timestep_331000.png
                    timestep_460000.png
                    timestep_411000.png
                    timestep_340000.png
                    timestep_240000.png
                    timestep_85000.png
                    timestep_472000.png
                    timestep_323000.png
                    timestep_194000.png
                    timestep_223000.png
                    timestep_205000.png
                    timestep_454000.png
                    timestep_305000.png
                    timestep_278000.png
                    timestep_429000.png
                    timestep_378000.png
                    timestep_266000.png
                    timestep_437000.png
                    timestep_366000.png
                    timestep_317000.png
                    timestep_446000.png
                    timestep_217000.png
                    timestep_309000.png
                    timestep_458000.png
                    timestep_209000.png
                    timestep_374000.png
                    timestep_425000.png
                    timestep_274000.png
                    timestep_470000.png
                    timestep_321000.png
                    timestep_196000.png
                    timestep_221000.png
                    timestep_87000.png
                    timestep_99000.png
                    timestep_188000.png
                    timestep_413000.png
                    timestep_342000.png
                    timestep_242000.png
                    timestep_233000.png
                    timestep_184000.png
                    timestep_333000.png
                    timestep_462000.png
                    timestep_95000.png
                    timestep_250000.png
                    timestep_350000.png
                    timestep_401000.png
                    timestep_5000.png
                    timestep_21000.png
                    timestep_287000.png
                    timestep_130000.png
                    timestep_387000.png
                    timestep_299000.png
                    timestep_399000.png
                    timestep_153000.png
                    timestep_42000.png
                    timestep_33000.png
                    timestep_395000.png
                    timestep_122000.png
                    timestep_295000.png
                    timestep_9000.png
                    timestep_141000.png
                    timestep_50000.png
                    timestep_114000.png
                    timestep_169000.png
                    timestep_78000.png
                    timestep_66000.png
                    timestep_491000.png
                    timestep_177000.png
                    timestep_106000.png
                    timestep_17000.png
                    timestep_118000.png
                    timestep_74000.png
                    timestep_165000.png
                    timestep_483000.png
                    timestep_237000.png
                    timestep_180000.png
                    timestep_466000.png
                    timestep_337000.png
                    timestep_91000.png
                    timestep_254000.png
                    timestep_405000.png
                    timestep_354000.png
                    timestep_229000.png
                    timestep_478000.png
                    timestep_329000.png
                    timestep_358000.png
                    timestep_409000.png
                    timestep_258000.png
                    timestep_325000.png
                    timestep_474000.png
                    timestep_192000.png
                    timestep_225000.png
                    timestep_83000.png
                    timestep_346000.png
                    timestep_417000.png
                    timestep_246000.png
                    timestep_442000.png
                    timestep_313000.png
                    timestep_213000.png
                    timestep_421000.png
                    timestep_370000.png
                    timestep_270000.png
                    timestep_201000.png
                    timestep_301000.png
                    timestep_450000.png
                    timestep_262000.png
                    timestep_362000.png
                    timestep_433000.png
                    timestep_499000.png
                    timestep_102000.png
                    timestep_13000.png
                    timestep_70000.png
                    timestep_161000.png
                    timestep_487000.png
                    timestep_110000.png
                    timestep_62000.png
                    timestep_495000.png
                    timestep_173000.png
                    timestep_37000.png
                    timestep_391000.png
                    timestep_126000.png
                    timestep_291000.png
                    timestep_145000.png
                    timestep_54000.png
                    timestep_138000.png
                    timestep_29000.png
                    timestep_58000.png
                    timestep_149000.png
                    timestep_1000.png
                    timestep_25000.png
                    timestep_283000.png
                    timestep_134000.png
                    timestep_383000.png
                    timestep_157000.png
                    timestep_46000.png
                    timestep_497000.png
                    timestep_171000.png
                    timestep_60000.png
                    timestep_489000.png
                    timestep_112000.png
                    timestep_163000.png
                    timestep_485000.png
                    timestep_72000.png
                    timestep_11000.png
                    timestep_100000.png
                    timestep_44000.png
                    timestep_155000.png
                    timestep_39000.png
                    timestep_128000.png
                    timestep_281000.png
                    timestep_136000.png
                    timestep_381000.png
                    timestep_3000.png
                    timestep_27000.png
                    timestep_56000.png
                    timestep_147000.png
                    timestep_159000.png
                    timestep_48000.png
                    timestep_393000.png
                    timestep_124000.png
                    timestep_293000.png
                    timestep_35000.png
                    timestep_344000.png
                    timestep_415000.png
                    timestep_244000.png
                    timestep_339000.png
                    timestep_468000.png
                    timestep_239000.png
                    timestep_81000.png
                    timestep_327000.png
                    timestep_476000.png
                    timestep_190000.png
                    timestep_227000.png
                    timestep_256000.png
                    timestep_407000.png
                    timestep_356000.png
                    timestep_248000.png
                    timestep_419000.png
                    timestep_348000.png
                    timestep_93000.png
                    timestep_235000.png
                    timestep_182000.png
                    timestep_464000.png
                    timestep_335000.png
                    timestep_260000.png
                    timestep_360000.png
                    timestep_431000.png
                    timestep_203000.png
                    timestep_303000.png
                    timestep_452000.png
                    timestep_423000.png
                    timestep_372000.png
                    timestep_272000.png
                    timestep_440000.png
                    timestep_311000.png
                    timestep_211000.png
                    timestep_96000.png
                    timestep_187000.png
                    timestep_330000.png
                    timestep_461000.png
                    timestep_230000.png
                    timestep_353000.png
                    timestep_402000.png
                    timestep_253000.png
                    timestep_199000.png
                    timestep_88000.png
                    timestep_0.png
                    timestep_84000.png
                    timestep_222000.png
                    timestep_473000.png
                    timestep_322000.png
                    timestep_195000.png
                    timestep_241000.png
                    timestep_410000.png
                    timestep_341000.png
                    timestep_269000.png
                    timestep_369000.png
                    timestep_438000.png
                    timestep_214000.png
                    timestep_314000.png
                    timestep_445000.png
                    timestep_277000.png
                    timestep_377000.png
                    timestep_426000.png
                    timestep_457000.png
                    timestep_306000.png
                    timestep_206000.png
                    timestep_434000.png
                    timestep_365000.png
                    timestep_265000.png
                    timestep_449000.png
                    timestep_318000.png
                    timestep_218000.png
                    timestep_69000.png
                    timestep_178000.png
                    timestep_14000.png
                    timestep_105000.png
                    timestep_166000.png
                    timestep_480000.png
                    timestep_77000.png
                    timestep_117000.png
                    timestep_492000.png
                    timestep_174000.png
                    timestep_65000.png
                    timestep_109000.png
                    timestep_18000.png
                    timestep_296000.png
                    timestep_396000.png
                    timestep_121000.png
                    timestep_30000.png
                    timestep_53000.png
                    timestep_142000.png
                    timestep_288000.png
                    timestep_388000.png
                    timestep_133000.png
                    timestep_384000.png
                    timestep_284000.png
                    timestep_22000.png
                    timestep_6000.png
                    timestep_41000.png
                    timestep_150000.png
                    timestep_67000.png
                    timestep_490000.png
                    timestep_176000.png
                    timestep_168000.png
                    timestep_79000.png
                    timestep_115000.png
                    timestep_75000.png
                    timestep_164000.png
                    timestep_482000.png
                    timestep_119000.png
                    timestep_107000.png
                    timestep_16000.png
                    timestep_152000.png
                    timestep_43000.png
                    timestep_398000.png
                    timestep_298000.png
                    timestep_20000.png
                    timestep_4000.png
                    timestep_131000.png
                    timestep_386000.png
                    timestep_286000.png
                    timestep_140000.png
                    timestep_51000.png
                    timestep_8000.png
                    timestep_32000.png
                    timestep_294000.png
                    timestep_394000.png
                    timestep_123000.png
                    timestep_243000.png
                    timestep_499999.png
                    timestep_412000.png
                    timestep_343000.png
                    timestep_98000.png
                    timestep_189000.png
                    timestep_220000.png
                    timestep_471000.png
                    timestep_320000.png
                    timestep_197000.png
                    timestep_86000.png
                    timestep_351000.png
                    timestep_400000.png
                    timestep_251000.png
                    timestep_185000.png
                    timestep_332000.png
                    timestep_463000.png
                    timestep_232000.png
                    timestep_94000.png
                    timestep_436000.png
                    timestep_367000.png
                    timestep_267000.png
                    timestep_428000.png
                    timestep_379000.png
                    timestep_279000.png
                    timestep_455000.png
                    timestep_304000.png
                    timestep_204000.png
                    timestep_275000.png
                    timestep_375000.png
                    timestep_424000.png
                    timestep_208000.png
                    timestep_308000.png
                    timestep_459000.png
                    timestep_216000.png
                    timestep_316000.png
                    timestep_447000.png
                    timestep_139000.png
                    timestep_28000.png
                    timestep_144000.png
                    timestep_55000.png
                    timestep_36000.png
                    timestep_290000.png
                    timestep_390000.png
                    timestep_127000.png
                    timestep_156000.png
                    timestep_47000.png
                    timestep_24000.png
                    timestep_135000.png
                    timestep_382000.png
                    timestep_282000.png
                    timestep_59000.png
                    timestep_148000.png
                    timestep_71000.png
                    timestep_160000.png
                    timestep_486000.png
                    timestep_103000.png
                    timestep_12000.png
                    timestep_498000.png
                    timestep_63000.png
                    timestep_494000.png
                    timestep_172000.png
                    timestep_111000.png
                    timestep_271000.png
                    timestep_420000.png
                    timestep_371000.png
                    timestep_212000.png
                    timestep_443000.png
                    timestep_312000.png
                    timestep_363000.png
                    timestep_432000.png
                    timestep_263000.png
                    timestep_300000.png
                    timestep_451000.png
                    timestep_200000.png
                    timestep_479000.png
                    timestep_328000.png
                    timestep_228000.png
                    timestep_404000.png
                    timestep_355000.png
                    timestep_255000.png
                    timestep_181000.png
                    timestep_467000.png
                    timestep_336000.png
                    timestep_236000.png
                    timestep_90000.png
                    timestep_247000.png
                    timestep_347000.png
                    timestep_416000.png
                    timestep_224000.png
                    timestep_324000.png
                    timestep_475000.png
                    timestep_193000.png
                    timestep_82000.png
                    timestep_259000.png
                    timestep_359000.png
                    timestep_408000.png
                    timestep_302000.png
                    timestep_453000.png
                    timestep_202000.png
                    timestep_361000.png
                    timestep_430000.png
                    timestep_261000.png
                    timestep_210000.png
                    timestep_441000.png
                    timestep_310000.png
                    timestep_273000.png
                    timestep_422000.png
                    timestep_373000.png
                    timestep_80000.png
                    timestep_226000.png
                    timestep_326000.png
                    timestep_477000.png
                    timestep_191000.png
                    timestep_238000.png
                    timestep_338000.png
                    timestep_469000.png
                    timestep_245000.png
                    timestep_345000.png
                    timestep_414000.png
                    timestep_92000.png
                    timestep_183000.png
                    timestep_465000.png
                    timestep_334000.png
                    timestep_234000.png
                    timestep_418000.png
                    timestep_349000.png
                    timestep_249000.png
                    timestep_406000.png
                    timestep_357000.png
                    timestep_257000.png
                    timestep_137000.png
                    timestep_380000.png
                    timestep_280000.png
                    timestep_26000.png
                    timestep_2000.png
                    timestep_38000.png
                    timestep_129000.png
                    timestep_45000.png
                    timestep_154000.png
                    timestep_292000.png
                    timestep_392000.png
                    timestep_125000.png
                    timestep_34000.png
                    timestep_158000.png
                    timestep_49000.png
                    timestep_57000.png
                    timestep_146000.png
                    timestep_113000.png
                    timestep_488000.png
                    timestep_496000.png
                    timestep_170000.png
                    timestep_61000.png
                    timestep_10000.png
                    timestep_101000.png
                    timestep_162000.png
                    timestep_484000.png
                    timestep_73000.png
        2025-07-11/
            14-05-43/
                config.json
                data/
                    timestep_0.npz
                    timestep_6000.npz
                    timestep_4000.npz
                    timestep_8000.npz
                    timestep_9999.npz
                    timestep_2000.npz
                plots/
                    timestep_0.png
                    timestep_6000.png
                    timestep_4000.png
                    timestep_8000.png
                    timestep_9999.png
                    timestep_2000.png
            15-38-48/
                config.json
                data/
                    timestep_4999.npz
                    timestep_1000.npz
                    timestep_3000.npz
                    timestep_0.npz
                    timestep_4000.npz
                    timestep_2000.npz
                plots/
                    timestep_4999.png
                    timestep_1000.png
                    timestep_3000.png
                    timestep_0.png
                    timestep_4000.png
                    timestep_2000.png
